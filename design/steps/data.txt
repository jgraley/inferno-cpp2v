(C) Copyright 2006 John Graley
Available under the terms of the BSD license. 

Data Phase - Steps for data staticisation including dealing with pointers

C++ and most software languages provide a dazzling array of different ways in
which data may be allocated and accessed: statics, locals, members, dynamic
allocation. Pointers and references may be added as additional ways of accessing
data that has been allocated by some other means.

Verilog provides two methods: registers, which are a hardware primitive, and
intermediate values in procedural blocks, which are removed during combing-out.

We must reconcile this discrepancy. Registers resemble statics and we rely on
that correspondence throughout the process. Procedural block intermediates
resemble locals, but are less expressive since they do not persist across as
many different kinds of operations as locals do (locals within main() have
nearly whole-program lifetime) therefore we choose not to maintain that
correspondence.

The solution is to convert all of the aforementioned C++ data formats into
static allocation and direct (static-style) access.

In early versions of the design, the lowering of C++ data was close to the
lowering of corresponding code and there would not have been an identifiable
data phase. However, maintining support for such constructs varied from
confusing to impossible during structural and other data steps (pointers in
particular). So they gravitated up to a position just below the C++-specific
phase. See extensive notes in design forum and against tasks.

Losing familiar data mechanisms may be inconvenient in later steps, and in a
couple of cases there is a little smear, but this is the lesser evil.

We therefore propose a phase in which dynamic data, locals, pointer and
references are all lowered into static data and direct accesses. Member data
does not need attention because by induction if top-level objects are all static
then members are effectively static and members of members etc.

This phase uses purely software implementations (test executables are just C++)
like the C++ phase before it. However, we are now moving away from a style that
con reasonably be called a natural software style, due to the hoops we must now
jump through to deal with the absence of C++ data formats.

Dynamic allocation is dealt with by building dynamic allocation pools. At this
point, we still have pointers so the pools only need to release a pointer to the
allocated object. We prefer to allocate by object to be consistent with the
general thesis of keeping objects self-sufficient, physically containing their
own data and functions.

Locals are handled by the introduction of explicit stacks. Originally, stack
creation was seen as part of the sequential phase, but analysis revealed that
the need to eliminate locals was much more urgent then the need to state-out. We
do so simply by creating a data structure containing all required locals and
then implementing an explicit stack which is then declared as a member. This
should be sufficient to support all forms of recursion that may be present in
the program at the cost of a little multiplexing.

Set/get functions are created for all data members and have the same public/
privateness. These are used for setting/getting data in all cases.

The most complex part of this phase is the pointer solution - this will be the
most work - and so keeping it in a pure SW implementation is a welcome
simplification. We lower pointers at a local level by simply enumerating
variables. This enum corresponds to an address that is valid only at a local
level. When pointers are passed between objects, the recipient treats the
pointer like a black box and passes the pointer beck to the object that supplied
it (we call that object the referee) for dereferencing. This is called
referring-back. When applied recursively, this ensures that all dereferences can
be carried out locally. The resulting increase in the number of inter-object
calls is believed essential to turn a pointer-rich C++ program into a
distributed system as required by the project's philosophy.

Further, when a dereference precedes a member call on the dereferenced object
(eg p->foo()) we choose to refer-back a package of work including the deref and
the call itself. Conceptually this amounts to bringing the action to the object
(as opposed to bringing the object to the action). We prefer to pass the
parameters of the call than to try and move or copy the dereferenced object to
the dereferencing code. In fact, it is now not necessary to move objects around
at all, which fits in with the idea of generating physical hardware for each
object.

We don't really have an answer to casting as yet; most likely, it will be
supported at some cost in efficiency (though cast-to-base-type should be
efficient).

The steps in this phase follow...


----------------------------------------------------------------------------
Staticise heap

Explicitly implement new/delete to allocate objects from pools implemented as 
static arrays. A separate pool will be needed for each data type that may be 
newed. Array new (new[x]) should also be supported and since the size is a 
runtime variable, fragmentation may occur. Fundamental types should be 
supported with one pool for each sizeof() value.

Each pool will be implemented as a C++ class containing the new and delete 
functions and the array of allocatable objects. This class will have one static 
global instance.

Invariant: No dynamic allocation. All const-member pointers are now globally
constant.

Note: No need to worry about constructors/destructors since they should have
been dealt with in the cplusplus phase. We only need to implement the actual
allocation.

todo: Maybe place inside an existing class if use cases are all within that class 
and its members, to increase locality.

Note: Q: do we not want to use a template over allocated type for this? 
A: No we don't because we can generate code and repeated patterns such as 
this are easy. Code generation is like templates but a bazillion
times more powerful and a gazillion times more readable. Templates would 
be useful if we were trying to use inversion, but we aren't.

Note: The required size of the pool depends on run-time considerations. 
If known, it may be hinted by the programmer. Otherwise it must be determined
by testing (possibly with an "engineering margin"). Finally, a caching approach
based on casting to an array of some fundamental type may be considered, but it
will be very inefficient.

todo: tactics for new on specified size types/bitfields

Example output for call to new and delete:

void f()
{
    A *a_ptr = type_A_allocator.New(); // was new A;
    
    ...blah...
    
    type_A_allocator.Delete( a_ptr ); 
}

Example implementation (details omitted):

static class
{
public:
    A *New() { ...find one with allocated==false; set allocated=true... }
    void Delete(A *) { ...set allocated=false... }
    
private:
    struct { A object, bool allocated } pool[A_SIZE];

} type_A_allocator;


----------------------------------------------------------------------------
Eliminate this->

Remove dereferences through the "this" pointer or any const pointer known 
equal to "this".

Invariant: All known accesses to something in the same module do not use
pointers.

Note: Strictly an optimisation, but the invariant helps to clarify.

----------------------------------------------------------------------------
Create global object

Enclose everything at global scope and all statics (base level and in classes)
with a single class that has a single instance. Rename statics based on 
compilation unit name or class name to avoid name conflicts.

Invariant: everything is in a class/object.

Example output:

class
{
public:
    int temp_input; // int temp from source file input.c
    int temp_output; // int temp from source file output.c
    ...
} global;

----------------------------------------------------------------------------
Use get()/set()

Generate a set and a get function for each public member of a class. Make 
the set/get functions public and make the data member private. Use these 
functions for all direct (non-pointer) accesses between objects. Internal
usage may be left alone.

Invariant: every inter-object interaction is a function call; all data members
private.

Note: trivial get/set functions are considered bad style since they're no better
than just making the member public. We only do this for the invariant which
helps later on.

Note: just classes, not structs.

Note: do all non-private data members, regardless of whether they actually get
used.

Note: no point in using these for internal accesses as we get no new invariant
from doing that - either way local member functions are accessing local member
data.

Note: this step is best done before the pointers lowering so that the pointer
steps can rely on the invariant given here. This slightly simplifies the search
for incoming/outgoing pointers.

Example output:

class A
{
public:
    A Get_a() { return a; }      // new accessor
    void Set_a(A _a) { a = _a; } // new modifier
private:      
    A a; // used to be public
};

----------------------------------------------------------------------------
Lower NULL pointers

Replace every pointer with a non-null pointer and a bool. If the bool
is false, the pointer is considered NULL. Otherwise the pointer is not NULL and
it may be dereferenced.

Invariant: all pointers are non-NULL

Example declaration and usage:

void f()
{
   struct { A *non_null_ptr, bool is_null } a_ptr; // used to be A *a;

   if( ...stuff... ) // determine whether object x exists
   {
       a_ptr.is_null = false;   // a_ptr = &x;
       a_ptr.non_null_ptr = &x; // ...
   }
   else
   {
       a_ptr.is_null = true; // a_ptr = NULL;
   }
   
   if( !a_ptr.is_null ) // was if( a != NULL )
   {
      a_ptr.non_null_ptr->g(); // was a_ptr->g();
   }
}

----------------------------------------------------------------------------
Lower pointer arithmetic

Associate every pointer with an int, which begins at zero, and is then
the subject of all pointer arithmetic. Then use array style for derefs. 

Invariant: No pointer arithmetic; pointers only created and overwritten

Note: try to merge with the above struct if easy, otherwise just add 
a new surrounding struct.

Note: this assumes that you can't go off the end of an array legally, which
is true iff the relative locations of separate data items (including arrays) 
are undefined. We rely on the assumption that the SW is written to not assume
otherwise. 

Example declaration and usage:

void f()
{
   struct { A *non_null_ptr, bool is_null, int index } a_ptr;

   a_ptr.index++; // was a_ptr++; 
   y = a_ptr.non_null_ptr[x]; // was y = a_ptr[x]; 
   return a_ptr.non_null_ptr[a_ptr.index]; // was return *a_ptr; 
}


----------------------------------------------------------------------------
Lower references

Implement references using pointers

Invariant: no references

Note: do this after lowering NULL and pointer arithmetic because the pointers
that we will generate for refs don't need to support either of these things. 
This is why this step is not part of the cplusplus phase.

@todo maybe we can turn pointers into refs instead of refs into pointers.

Example output:

void f( A *r ) // used to be f( A &r )
{
    r->Thang(); // used to be r.Thang();
}

----------------------------------------------------------------------------
Memberise locals

Add a stack pointer for each member function in each class. It should be an 
integer member variable big enough to represent the max recursion depth. Add
code to increment the stack pointer on entry and decrement on leaving the 
corresponding function. Add code to initialise the stack pointers to the 
constructor function.

For each local variable, move the variable to be a private class member 
(uniquified for the function it came from), and make it an array. Update 
every access in the function to index the array using the function's stack 
pointer.

Invariant: all variables are static or members

Note: we have to do this before any SystemC stuff, because it needs all objects
to be static (or members). But we will add more locals later on and so this step
will be repeated. Hopefully re-use implementation!

Note: furthermore, "add dereferencing layer" lowering needs *all* locals to be
memberised first, so moved up again and now applies to all locals

Note: arrays of raw variables are a supported primative right through into the
verilog phase, so we're allowed to leave them lying around at the end of this 
phase.

todo: detect "leaf scopes" where there are no outgoing function calls during
the scope of a local. Do not stack these but just make them class members.

Example output:

class A
{
     int x_f_stack[A_f_STACKSIZE]; 
     B b_f_stack[A_f_STACKSIZE]; 
     int f_stack_pointer;
     
     void f()
     {
         // was int x; 
         // was B b; 
         f_stack_pointer++; // on entry
         
         g( x_f_stack[f_stack_pointer] ); // was g( x );
         b_f_stack[f_stack_pointer].h(); // was b.h();
         
         ...maybe recurse f here...
         
         f_stack_pointer--; // on exit
     }
     
     A()
     {
         // init stack pointers
         f_stack_pointer=-1; // it gets incremented on the first call 
                             // (though the actual init value doesn't really matter)
     }
};


----------------------------------------------------------------------------
Add class-level dereferencing layer

For each class C add deref functionas as follows: for each object A whose address 
gets taken within C's member functions, add functions to C that forward 
dereferenced function calls to A. So if objects a and b of class D have a function 
footle( int x ) and we take the address of either a or b in any member function
of C, then we create deref_D_footle( D *p, int x ) which invokes the correct 
footle() based on the value of p.

When the address of a raw data type or a pointer is taken add eg deref_int_get( 
int *p ) and deref_int_set( int * p, int val ). These should call through to 
the corresponding get and set functions introduced in an earlier step.
 
When a pointer type can be obetained internally by taking the address *or* 
externally via incoming call or return value, associate the pointer with an
enum that indicates how the pointer was obtained.

Replace all pointer dereferences and through-pointer invocations with the 
corresponding local deref function. 

Deref functions should be implemented to use switch() on the pointer value using
case values that are explicitly taken addresses when the pointer was generated
internally. Cast to int if necessary to compile this. When the pointer was received
from outside, it should be directly dereferenced (this will be taken care of later).

Invariant: class explicitly handles all derefs of data whose address is 
taken by the class.

Note: p->f() and equivalently (*p).f() should *not* be broken down into the *p
and the .f() but should be treated as a unit (becomes deref_type_f(p)). Because 
of this, there's no need to copy the data because we always bring the action to 
the data, not the other way around


todo: member function pointers

todo: pointers to array elements

Example output:

int x;

class A
{
    int y;
   
    struct int_ptr
    {
        int *ptr;
        enum 
        { 
             LOCAL, 
                EXTERNAL 
          } whence;
    } p;
        
    void f() // generate internally
    {
        int_ptr p; // these lines were int *p = &x;
      p.ptr = &x;
        p.whence = LOCAL;
        
        ... maybe modify p, but in accordance with this step...
     
        deref_int_set( p, 99 ); // was *p = 99;
    }
    
     void g( int *inp ) // get from outside
     {
        int_ptr p; // these lines were int *p = inp;
          p.ptr = inp;
        p.whence = EXTERNAL;
     }
    
    // completely new function
    void deref_int_set( int_ptr p, int val )
    {
         switch( p.whence )
          {
          case LOCAL: // local case: avoid dereferencing by switching over possible values
            switch( p.ptr )
            {
            case &x:
                x = val;
                break;
            case &y:
                y = val;
                break;
                }
                break;
          case EXTERNAL: // external case: just leave the deref, it'll get changed later
              *p.ptr = val;
        }
    }    
};

----------------------------------------------------------------------------
Enumerate local addresses

For each class C and each type T, create an enum with a different value for each 
object of type T whose address gets taken within the C's member functions. This 
includes taking the address of objects not members of C.

If pointers to T can be obtained externally, create a union of the enum and the 
original pointer type, and substitute that into the pointer representation 
created in the "Add class-level dereferencing layer" step in place of the 
actual pointer member.

Example output:


   enum{ ADDRESSOF_GLOBAL_X, ADDRESSOF_Y } Local_Int_Ptr; // anything whose


int x;

class A
{
    int y;
    
     struct int_ptr
     {
         union
          {
              enum
               { 
                   ADDRESSOF_GLOBAL_X, 
                    ADDRESSOF_Y 
                } local_ptr;
            int *external_ptr;            
        enum 
        { 
            LOCAL, 
            EXTERNAL 
        } whence;
    } p;
        
    void f() // generate internally
    {
        int_ptr p; // these lines were int *p = &x;
        p.local_ptr = ADDRESSOF_GLOBAL_X;
        p.whence = LOCAL;
      
        ... maybe modify p, but in accordance with this step...
     
        deref_int_set( p, 99 ); // was *p = 99;
    }
   
    void g( int *inp ) // get from outside
    {
        int_ptr p; // these lines were int *p = inp;
        p.external_ptr = inp;
        p.whence = EXTERNAL;
    }
    
    // completely new function
    void deref_int_set( int_ptr p, int val )
    {
        switch( p.whence )
        {
        case LOCAL: // local case: avoid dereferencing by switching over possible values
            switch( p.local_ptr )
            {
            case ADDRESSOF_GLOBAL_X:
                x = val;
                break;
            case ADDRESSOF_Y:
                y = val;
                break;
            }
            break;
        case EXTERNAL: // external case: just leave the deref, it'll get changed later
            *p.external_ptr = val;
        }
    }    
};

----------------------------------------------------------------------------
Add SystemC modules

Each class should derive from sc_module, thereby making it a SystemC
module. Add an empty SC_CTOR to each module definition. 

Note: Do not change structs - these will not become modules

Note: We regard SC_CTOR and its contents as a SystemC construct for
expressing static binding, processes and sensitivity lists. SC_CTOR
has no relationship to the constructors that were present in the 
original input program.

Note: do not use SC_MODULE macro - it cannot be extended for 
interfaces etc

Invariant: SystemC features now available.

Example:

class C
{
    ...
};

becomes:

class C : public sc_module
{
    SC_CTOR(C) // SC_CTOR really means SC_ELABORATION_STUFF
    { // nothing here yet
    }
    ...
};

----------------------------------------------------------------------------
Make static calls though ports

For each call to a function in another object that is *not* routed using
a pointer (eg a.b.foo() but not p->foo()), add a SystemC port to the 
calling module definition, bind the port in the SC_CTOR() and then make
the calls though the port.

Example:

class C : public sc_module
{
    SC_CTOR(C) 
    { 
    }
    void f()
    {
        d.g(); // d is an instance of some other module with function g()
    }
};

becomes:

class C : public sc_module
{
    sc_port<D> portd; // D is the module definition of d
    SC_CTOR(C) 
    { 
        portd(d); // bind statically
    }
    void f()
    {
        portd.g(); // call through the port
    }
};

----------------------------------------------------------------------------
Refer-back pointers

This step must iterate over every example in the code that satisfies the 
following condition. Each iteration should result in a valid runnable test render.

The refer-back condition is like this:
- There exist 2 module definitions, C and D which could be the same.
- There exists a pointer type P *
- Either: 1. C contains a call to a D where a P * is one of the parameters
       or 2. D contains a call to a C where a P * is the return value

Determine the data type used internally in C to represent the supplied 
pointer where P * would ordinatily be used. This type may be P * or a
struct generated by the earlier pointer steps. Call this type Q.

Make the actual parameter or return value that conveys P * from C to D
actually use type Q. Also use type Q internally within D in place of P *.

Create a referral interface for Q, called refer_P_x where the number x
differentialtes between all different Q that can be generated for P. 
This interface should resemble the interface to P except that: all 
function names prefixed with "refer_Q_x_" and all calls have an additional 
parameter of type Q.

Make module C implement this referral interface. Functions should simply
dereference the supplied pointer P using the supplied params and return the
return value.

In the implementation of D, search through the definition of type Q looking 
for a dynamic id to C or D (ie sc_dyn_id< refer_Q_x > or sc_dyn_id< refer_S_x >). 
If found make type R the same as Q. Bascially since dyn id binding addresses 
every instance of a module, any existing id to D will just get us more directly 
to the correct instance of d. And an id to D means we can use the instances of 
D for forwarding (nearly as good).

If no suitable dyn id was found, associate the recieved Q with a dynamic binding
id of type sc_dyn_id< refer_Q_x > (see design/SystemC/back port.txt). Refit this
compound type throughout module D in place of Q. This new type is R. 

At the point of receiving the pointer value from C, initialise the dynamic id
to refer to the module instance that supplied the pointer (which should 
by now implement the referral interface refer_Q_x.

Whenever the pointer was dereferenced, instead issue a dynamically bound 
call to the referral function in whichever module instance the id selects.

If an instance of D passes the pointer back to an instance of another 
module (via param or return value), just pass the pointer and ignore the
dynamic id (this will get updated in a future iteration).

Invariant: all inter-object calls now go through bound ports

todo: object pointers need to be distinct for objects in the same virtual 
hierarchy so that they can be used interchangably.

todo more on pointers to raw data types.

todo more examples?

Example referral interface:

class refer_Q_0 : public sc_interface
{
    virtual int f( Q q, char c );
    // in P's interface, this function is int f( char c );
};

Example types/structures:

class P; // the original type and a pointer to it
P *p;

typedef ... Q; // Q can represent what P * can represent as far as C knows, but
               // we don't care how it's implemented

struct R // C can interpret q, and this struct has the id of C
{
    Q q; // came from instance of C
    sc_dyn_id< refer_Q_0 > referee_id; // the id of that instance
}

