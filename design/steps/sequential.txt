(C) Copyright 2006 John Graley
Available under the terms of the BSD license. 

Sequential phase - steps that deal with intra-object code, including stating-out
and recursion.

This phase contains the recognisable transformations that implement sequential
algorithms by spacing a number of combable operations out over time.

Our input consists of a number of servers connected up by wires (sc_signal) and
we act upon each server individually. A server resembles a simplified computer
and runs in a server context (SC_THREAD). In addition to user functionality, the
servers contain generated code from all three previous phases. In particular,
the structural phase generates significant executive and protocol marshaling
code. This is why the present phase occurs late-on in the transformation
process; we can generate functionality in sequential C style and let it pass
through this phase, instead of trying to generate the Verilog directly for the
new functionality.
 
Broadly speaking, the phase begins with steps that correspond to compilation
(some more closely than others) followed by steps that introduce the minimal
computer-like infrastructure required to execute the compiled program. Viewing
the phase in this way leads us to question what instructions are available, to
which the answer is that any combable block of code found in the initial server
algorithm can become an instruction. However, there is no fundamental reason for
compilation and computer recreation steps not to be swapped around if that
helps.

We firstly merge all the functions in the server into a single one. This
corresponds to the linking performed by a software toolchain. We bring it out to
near the start of the phase because it is reasonably separable, and the
remaining work is simpler. In particular all recursions are just calls back to
the merged (big) function - so the recursion call pattern is simplified.

We now perform the classic compilation task of lowering constructs such as while
loops down into conditional gotos (a goto in an if). Gotos and labels will later
turn into state transitions, therefore anything we lower to gotos will get
stated out. We can also sometimes leave constructs in place in which case they
will appear in the output Verilog and hence be combed-out during synthesis.
Therefore this step decides what gets stated and what gets combed.

Switch statements demand special attention - we choose to use a lookup table
followed by a "goto a variable" primitive to get to the right case. In the ideal
situation, the lookup can be optimised to identity by choosing matching label
(=state) values and the goto-a-variable will just copy the variable over the
state.

We remove recursion by simply arranging to jump back to the start of the
function instead of (re-)invoking it. This requires that we have an explicit
stack (which we already have courtesy of the data phase) and an explicit state
variable so that we can use the "goto a variable" primitive to implement return.
We do not wish to actually state out before this step, so instead we insert the
state variable in parallel with the gotos and labels just before doing this step
(so that it is available for return).

We now have a single function in each server that will be called once at startup
and will simply execute forever - not calling any other functions and not being
called by any other functions. 

When we state-out, we choose to create a state for each label. The states are
reached by means of an overall switch statement and gotos are implemented by
assigning a new value to the state variable. The overall switch statement must
be iterated indefinitely but this is the behaviour of SC_THREAD anyway, no no
actual loop needs to be created. 

Since a state may contain conditional gotos followed by code, we need to place
that code in an else clause of the if otherwise it will get executed when it
shouldn't when the gotos are removed. We do this just before state-out.

State-out may be regarded as turning a program that is manifestly implemented as
a series of combable sections of code (similar to machine instructions) into a
microprocessor implementation that may execute any such instruction at any time
and chooses which one to execute based on stored data (the state variable, which
may be regarded as analogous to a program counter).

Finally, we move from SC_THREAD via SC_CTHREAD to SC_METHOD in a few simple
steps. First, we replace all minor delays with a single one at the end of the
function, then convert it according to process model: we have delay() under
SC_THREAD, wait(clk) under SC_CTHREAD and nothing under SC_METHOD. These steps
progressively define the synchronous timing model, and would differ
substantially in an asynchronous implementation.

Once we reach SC_METHOD, we have got rid of the need for a server context.
Furthermore whenever SystemC invokes our code, it will perform only nominally
instantaneous actions which (a) are combable and (b) do not violate protocol
rules by causing combinational loops. Note that this is distinct from the
situation before server contexts were introduced, where a function could run for
as long as it wanted and possibly indeterminately.

The steps within this phase follow:

----------------------------------------------------------------------------
Add poll loops

Replace all wait() calls with a poll loop that checks the condition repeatedly.
Insert a minor delay into the loop in order to explicitly spread it out over
time. This is really associated with "add clock/reset" but we do it up here 
so we can state-out the loop.

This step arguably finishes off the protocol generation step. However the choice
of a poll loop as a way of waiting for an event is a decision local to servers
and whereas wait-for-event is fairly generic, a poll loop is quite a specific
sequential construction.

Invariant: our reliance on SystemC eventing is hidden and the need for poll
loops made explicit.

Note: we may not need this if using asynchronous technology. State-out should be
able to still work if we skip this step leaving wait(x) in place of delay()
loops.

Example output:

void f()
{
   // x is some event or group of events
   while(!x) delay(); // used to be wait(x)
}

----------------------------------------------------------------------------
Merge member functions

Merge all the member functions in a server into a single one that uses a big
switch statement to select the implementation based on a new enum parameter.
Parameters of the original functions should be grouped into a struct for each of
the original member functions then unioned together for the big function. Return
value should be handled similarly.

Invariant: all calls are simple recursions on the big function (apart from
SystemC primatives) since there's nothing else to call.

Note: this single function is now the server's run (process) function. Since
SystemC expects the run function to be void(void) we will have to add a
primitive to forward the call. The "which" enum value supplied should be 0 for
the run function; this thunk can be removed after flattening recursion.

Note: originally was before memberise locals, but that proved impossible due to
pointer lowering steps. This must be done after structural steps to ensure we
keep separate call interfaces for separate call sites (1:1 wiring).

Note: also merge the explicit stacks for the functions @todo maybe more
efficient not to; but we need somewhere to put the stacked state. 

@todo Need to stack the new locals added here 

Example output (initial functions were char f(char) and int g(int, int)):

struct g_params { int p1, int p2 };

union big_params { char f, g_params g };
union big_result { int f, char g };

enum which { F, G };

big_result big_function( which w, big_params bp )
{
    big_result br;
    switch( which )
    {
        case F:
            param = bp.f;
            ...algorithm from f...
            br.f = return_value;
            break;
            
        case G:
            param_1 = bp.g.p1;
            param_2 = bp.g.p2;
            ...algorithm from f...
            br.g = return_value;
            break;                                    
    }
    return br;
}

----------------------------------------------------------------------------
Lower constructs

Lower constructs that are not supported in combable (synthesisable) Verilog into
conditional branches ie if(cond) goto label; Also force a state transition for
each delay(). 

Lower the following in all cases:
    for - lower into a while loop (@todo should this be a separate step?)
         while - test at start and jump out if fail; jump back to start at the
end. Break jumps out; continue jumps to test.
    do-while - test at end and jump back to start if pass. Break as   
               per while() continue jumps to the condition test at the bottom.
    delay() - add a trivial "goto here" and label, but keep the delay() call.
    
    
Lower if a label is contained within the construct (after the above lowering):
    if - test and jump past "then" block if fail; end of "then" block jumps   
         past "else" block.
    switch - build a lookup table of case values to real labels (enumerated).
             Generate the "goto x" primitive. Break jumps out.
       
Invariant: all constructs combable or can be trivially stated-out

Note: there's some flexibility here in how much stuff we lower. It corresponds
to design tradeoffs in the final hardware. Any construct surrounding a label
must itself be lowered. 

Note: Ifs etc could be partially stated if for example the "then" block
contains a label but the "else" block does not. Likewise switch statements.
    
Note: the "goto x" primitive is needed when lowering recursion in order to jump
back to the correct state when returning - ensure same primitive is used.

Note: switch statements may be optimised by choosing the enum values for states
to match the suer-supplied case values, or by making the mapping simple (eg
prepend a bit pattern). Since multiple switch statements will tend to overload
the space, the optimisation should be performed after this step. This will help
allow a manually written state machine in the input program to be preserved as
such.

Note: Retain local scope structure for now. @todo check whether we will break
goto/scope rules here.

@todo early returns

Example, lowering for( x, y, z ) {...} 

{ 
    x; 
    while( y ) 
    { 
        {...} 
        z; 
    } 
}

Example, lowering while(x) {...}

{
    CONTINUE:
    if( !x ) goto BREAK;
    {...} // break becomes goto BREAK, continue becomes goto CONTINUE
    goto CONTINUE;
    BREAK: 
}
       
Example, lowering do {...} while(x)

{
    DO:
    {...} // break becomes goto BREAK, continue becomes goto CONTINUE
    CONTINUE:
    if( x ) goto DO;
    BREAK: 
}
       
Example, lowering delay()

{
    delay();
    goto DELAY; // create a state change. 
    // Maybe put a barrier here to stop this construct getting optimised away.
    DELAY:
}
       
Example, fully lowering if(x) {...} else {,,,}

{
    if( !x ) goto ELSE;
    {...}
    goto ENDIF;
    ELSE:
    {,,,}
    ENDIF:
}

Example, fully lowering switch(x) { case 1: ...; case 2: ,,,; }    

{
    Label y = primitive_lookup(x); // @todo what, exactly do we want here?
    goto y; // goto-a-variable primitive (will optimise out later)
    CASE_1:
    ...; // break becomes goto BREAK;
    CASE_2:
    ,,,; 
    BREAK:    
}


----------------------------------------------------------------------------
Add state variable

Add an enum with a value for each label, add a local variable of that type
called state and maintain it correctly by assigning to it immediately before
each goto. Initialise to eg INIT_STATE at start of the function (regardless of
recursion depth).

Note: assert this at each label as a double check since we have a little
redundancy at this point. Treat assert as a primitive (and use the "standard"
kind of assert as in assert.h).

Note: the state variable should be inserted into the local variables data
structure so that it gets stacked when the function recurses.

Example output:

void f()
{
    // initialising the state
    locals[stack_pointer].state = INIT_STATE;

    
    // if( x ) goto FOO; becomes...
    if( x ) { locals[stack_pointer].state = STATE_FOO; goto FOO; }
    
    ...
    
    // FOO: becomes...
    FOO:
    assert( locals[stack_pointer].state==STATE_FOO );
}

----------------------------------------------------------------------------
Remove scopes

Scoped blocks (surrounded by {}) should now be completely redundant. Get rid of
them.

Note: was part of memberise locals, but that got moved up into the data phase.

@todo we can't remove all scopes - we want to keep scopes on constructs that
have not been lowered (because they will be combed-out by Verilog) and indeed
the "else clauses" step actually adds scopes. So need a criterion for deciding
which scopes to remove. Maybe the invariant should be no scopes around labels?

Invariant: No scopes (apart from overall function scope)

----------------------------------------------------------------------------
Lower recursion

Turn each recursion call point into a goto to the start of the function and at
the very end of the function insert a goto to the label implied by the state
variable. Add a new primitive for this.
 
Invariant: no recursion; no non-trivial function calls 

Note: the "goto a variable" primitive would have to become eg a switch statement
for the purposes of testing this step. It vanishes in the "State-out" step.

Note: every LABEL: must have an assert( state==LABEL_STATE ); otherwise
state-out won't work. This is why we have to duplicate the sp++ and state=INIT
for each fn call. But we're close enough to Verilog that synth tools should be
able to help ;-)

@todo deal with params/return value

Note: at the end of this stage, the only caller to the function will be to start
the process - so can fold in the thunk we added in at function merge.

Example output:

void f()
{
    locals[stack_pointer].state = INIT_STATE; // from add state variable step
    INIT_STATE: // new
    assert( state==AFTER_RECURSION_STATE );

    ...
    
    // used to be f();
    locals[stack_pointer].state = AFTER_RECURSION;
    stack_pointer++;
    locals[stack_pointer].state = INIT_STATE; 

    AFTER_RECURSION:
    assert( state==AFTER_RECURSION_STATE )
    
    ...
    
    // end of function
    stack_pointer--;
    goto locals[stack_pointer].state;
}    

----------------------------------------------------------------------------
Else clauses for skipped code

Place code after a conditional goto (a goto in an if) up to the next label into
an else clause if it isn't already in one. If there is code between an
unconditional goto and the next label, it is an error (the code is unreachable).
In general, there may be more than one goto in between each consecutive pair of
labels and these gotos may be combed out so that there is a state for each
label. This could be regarded as an optimisation (compared to adding a state for
each goto), but we include it because it permits the result of state-out to
resemble what one would expect from the lower-constructs step.

The idea is to ensure that there is no code in an executable path between a goto
and the next label.

Invariant: gotos do not need to be enacted until the next label is reached

Note: at the start of this step, there should be 0 or more if(something) goto
SOMEWHERE; and then one unconditional goto SOMEWHERE_ELSE; just before the
label. If this is not true, it is an error.

Example:

LABEL1:
if(x) { state = X; goto X; }
...
if(y) { state = Y; goto Y; }
,,,
{ state = Z; goto Z; }
LABEL2:

becomes:

LABEL1:
if(x) { state = X; goto X; }
else
{
    ...
    if(y) { state = Y; goto Y; }
    else
    {
        ,,,
        { state = Z; goto Z; }
    }
}
LABEL2:

----------------------------------------------------------------------------
State-out

Surround the entire function with a switch statement on the state variable.
Generate a case for each label ending just before the next label. Insert a break
at the end of each case. Remove the gotos, leaving only the assignments to the
state variable. 

Invariant: context is released between each combable block

Note: we are taking advantage of the fact that SC_THREAD loops infinitely 

Example:

void f()
{
    LABEL1:
    ...
    { state = LABEL3; goto LABEL3; }
    LABEL2:
    if( x )
        { state = LABEL1; goto LABEL1; }
    else
    {
        ,,,
        { state = LABEL3; goto LABEL3; }
    }
    LABEL3:
    '''
    { state = LABEL2; goto LABEL2; }
}

becomes:

void f()
{
    switch( state )
    {
    case LABEL1:
        ...
        state = LABEL3;
        break;
    
    case LABEL2:
        if( x )
            state = LABEL1;
        else
        {  
            ,,,
            state = LABEL3;
        } 
        break;
    
    case LABEL3:
        '''
        state = LABEL2;
        break;
    }
    // When switch falls out we exit the function, but function is a SC_THREAD
    // and SC will just call it again in an infinite loop.
}

----------------------------------------------------------------------------
Extract waits

Replace all delay() calls with a single one at the bottom of the function. We
now have a minor delay for all the minor delays that were explicitly requested,
and also for each state transition. This is the step that establishes the states
as being spread out over time, in the manner of a computer.

Invariant: no non-trivial context across a delay()

Note: this is possible because all the delay() calls are at the ends of state
cases and there's now nothing after them until you get to the bottom of the
function.

Example output:

void f()
{
    switch( state )
    {
       ...blah blah, but we've removed all the delay() calls
    }
    delay();
}

----------------------------------------------------------------------------
Insert clock and reset

Move all servers to SC_CTHREAD. Replace the delay() at the bottom with 
wait(clk). @todo or whatever you do in an SC_CTHREAD to await a clock pulse.

This step is simply a clarification of the fact that we will generate a clocked
architecture, and not eg an asynchronous design. We are implementing the minor
delay as a period of time equal to 1/Fc. This step also implies the existence of
clock signal routing.

Invariant: no more delay() primitive - all events explicitly controlled 
by clock

@todo not sure about clock distribution or how to handle reset. Maybe reset 
should zero all stored data as a first step in startup. @todo

----------------------------------------------------------------------------
Remove server context

Move to SC_METHOD. Remove the wait(clk) primitive. This step is simply a result
of the fact that we are able to use SystemC's process model that invokes
functionality once per clock instead of on a continuous basis. The underlying
condition for this to be possible is that the only wait(clk) is in a trivial
position - just before returning. Since function return and delay are together,
the implication is that we do not need to keep any execution context across a
wait(clk). We can therefore release the context after each combable (=nominally
instantaneous) bit of work. Consequently, we don't need our own context any
more, we can just borrow some common shared context. 

The test rendering from this step will therefore not be multi-threaded.

Invariant: no persistent implicit context

Note: this is really a pattern reduction: SC_CTHREAD{ ...; wait(); } becomes
SC_METHOD{ ...; }. If any functions don't match the pattern we have an error.

