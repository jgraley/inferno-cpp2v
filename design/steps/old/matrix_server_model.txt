
Metrix server model
===================

A server (as defined here) looks like this:

+-----------------------------------+
|-> call_valid        return_valid->|   
|<- call_ready        return_ready<-|
|-> call_data          return_data->|
+-----------------------------------+

An analogue 2-port network element looks like this:

+--------------------------+
|--signal in   signal out--|
|--ground in   ground out--|
+--------------------------+

Analogue network theory divides a network up into blocks of this sort in cascade, parallel and series combinations. If the elements are deemed linear time-invariant, then they can be represented, at a given frequency omega, by a 2*2 matrix over the complex numbers. There are a few (6 I think) different way of writing the matrix which may be converted between each other and which may be added or multipled together to represent various types of interconnection. The result is another matrix of the same form as the input matrices which represents the whole. Therefore, the representation is hierarchical and can represent complex systems via decomposition.

The fundamental reason for needing 2*2 matrices is that there are 2 degrees of freedom at each interconneciton in an analogue network, for example voltage and current. An element maps a pair of these at input to a pair at output in a single step.

Suppose we write a matrix to represent the outputs of a server in terms of its inputs (assume it's combinational and has no state):

cr       rr  
rv  = M  cv
rd       cd

We can incorporate simple delays into our linear anlysis by using z-domain representation. z is defined as the complex result of exp( 2*pi*i*f/fs ). fs is the sample rate, which will be the clock rate in our anlysis. s can be any frequency, but for us it makes sense if f is a simple divisor of the sample rate, say fs/N. Then z = exp( 2*pi*i/N ). We now consider different powers of z at different values of N:

N z^0 z^1 z^2 z^3 z^4 z^5 z^6...
1 1   1   1   1   1   1   1
2 1   -1  1   -1  1   -1  1
3 1   a   b   1   a   b   1
4 1   c   -1  d   1   c   -1
...

a, b, c and d are complex numbers with unit length pointing in various different directions. [@todo more]

We can represent delays using powers of z. A matrix for a combinational server looks like this

return_value = comb_func( call_params ); // Always process the function
call_ready = return_ready; // We can accept a call in the same cycle that the client can accept the return
return_valid = call_valid; // Want to return as soon as the call is made

1 0 0
0 1 0
0 0 F

A matrix for a one-cycle delay looks like this:

return_value = prev comb_func( call_params ); // Always process the function
call_ready = call_valid; // We can accept a call in the same cycle that the client can accept the return
return_valid = prev call_valid && !prev return_ready; // Want to return as soon as the call is made

 0 1  0
-z z  0
 0 0 Fz

[@todo probably not right. Need to mix transitions and levels ie need x (for eXtend) st a rising edge * x is a 1-clock pulse and a 1 clock puse * x^-1 is a rising edge. Then return_valid = cr/x*z-rv. Or soemthing.]

These matrices may be ocmverted into a form in which the call_ signals are derived from the return_ signals eg

cr       rr  
cv  = M  rv
cd       rd

This is non-causal, but since we have moved into a linear time-invariant domain that's OK (we're anlaysing the behavior of the system after it has had infinite time to settle at a given frequency fs/N). They may then be multiplied to generate a resultant matrix that describes one or more servers in cascade.






