
Implementation
==============

Every step of the process treats each server in isolation. All interfaces betwene servers may be deduced from the type of the corresponding C construct.


1. Heap lowering
----------------

We convert all "new" and "delete" statements into special allocator implementations based on static arrays of objects. Each class should be handled seperately (we shouldn't need to deal with fundamental types due to the above "server generation" step.

This should result in valid Gimple and there should be no requirement for a system heap; all data is now statically allocated.


2. Server generation
--------------------

At this stage, we convert functions and fundamental data types (plus typedefs and enums) into classes as specified in "function_calls.txt" and "variables.txt". At this stage we also fix up the use-cases of these constructs:

- The objects for static (=non-member) functions to be instanced statically.
- Calls to functions to go through the corresponding class's interface (perhaps operator()?)
- Accesses to data to go through the corresponding class's interface (perhaps operator= and operator int etc?)

The result of this stage should be correct Gimple. The resulting classes are termed "servers".


3. Combing/stating/piping out
-----------------------------

The algorithms within functions are converted to combinational, state-machine or pipeline form as required. The C function is already inside a server class, so the function boudary may be removed and the logic placed directly in the server, except in cases where Verilog functions will be used.

An interchange placeholder is placed inside the new server.

The complete set of server (incoming) and client (outgoing) interfaces is difficult to generate because we need to look at the implmentations of sub-modules to determine the client interfaces they require. It is a fundamental restriction of the C language that objects need only decalre their incoming calls, not their outgoing calls.

Therefore, at this stage we omit the outgoing calls that would result from sub-servers and the module interface. Instead, we simply wire up all incoming calls from the module's port list to the local functionality and sub-modules as permitted (eg when declared public). 

We wire all outgoing calls that have been generated by internal logic to the port list, but do not do anything about sub-server outgoing calls at this stage.

The result of this stage should be correct Gimple and entirely event-based in nature (similar to the C code a simualtion tool generates). 


4. Server modularaisation
-------------------------

Here, all servers are converted from classes into modules. No algorithmic changes should be required. The output should be Himple, and apart from un-connected signal lines should be synthesisable.

The resulting partial servers are termed "kit-form". 


5. Client routing
-----------------

The final linking stage is to be performed by the HDL simulation/synthesis tool. However, we need to perform an additional step before our representation can be converted into HDL, and this step requires visibility across seperate server implementations.

HDL requires that modules expose ports correponding to *all* interaction with the outside envirnment, including both outgoing and incoming calls. We can only determine the full set of outgoing calls that a module will make by analysing the outgoing calls made by sub-objects, to an arbitrary depth. These will typically reside in seperate "compilation units", so we need to be able to operate across compilation unit boudaries.

We can determine the outgoing calls for aa server with no sub-servers, and we can also do so for a server where the outgoing calls are known for all sub-servers.

We therfore walk the entire server hierarchy tree and determine the outgoing calls recursively. The tool must therefore retain the himple tree representation for all input files and perform this step after all input files have been processed (stages 1 and 2 should still be performed as the files are being read so that the processing time can overlap file-system caching). 

Note that we need to be able to support multiple instances of each module. Therefore, calls to a server embedded in a server hierarchy beginning with a global statc must always be routed through global scope; we cannot short circuit the routing because it routes to another server in the same hierarchy because that can only be true for one instance at most. 

All calls are either based on local data (including the "this" pointer) or global data. At this stage we ignore the former, and route the latter up to global scope and then on to the specified global object. The object should already have the required server interface.


6. Channel routing
------------------

During a depth-first walk of the hierarchy tree we decide the number of bits that will be required to represent the address of each addressible server. 

For each (server, pointer space) we count the number of sub-servers that may be routed to (only counting ones for which a "get address" call is made) and add enough bits to represent the full range of addresses to the length of the longest address rerpesentation among the sub-servers.

This step may be merged with the tree walk in an earlier step.

We then insert pointer support independently on each (server, pointer space) combination. We fill in N extra bits in "address-of" data (whether a parameter to an outgoing call or a return value from an incoming call) by prepending an index to the left of the word which is unique for each sub-server. This value may then be returned from our server.

Where pointers are passed into servers, the internal width remains constant and the data are passed directly. This may require a depth-last walk.

Whenever a pointer is passed in or out of a server, a channel is created in the opposite direction. The channel consists of
1. A copy of the pointed-to server's call (server) interface 
2. A pointer of the same type as the original pointer

The pointer in part 2 has the number of bits determined earlier. Where there are multiple candidate sub-servers (same type, all offered their address) we create a router to multiplex in the correct signals to complete the routing. The router will use the N most-significant bits of the pointer to control routing and will pass on the remaining bits to the sub-server.

Note: A router should consisder the address to be extra parameter data to any call and must respect the protocol even when several routers are beign cascaded. This means either registering the extra bits until the call returns or delaying the call_ready signal until the return.


7. Post processing
------------------

Insert clock/reset logic
Insert hand-coded implementations of servers for int etc
Create "system" module.
Optimisation.
