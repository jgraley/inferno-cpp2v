
(C) Copyright 2006 John Graley
Available under the terms of the BSD license. 


This file lists the steps in the mapping process. Currently rather brief and 
ambiguous I'm afraid, and more detail will go in over time. 

Since this is likely to change repeatedly, it will be kept under version
control. 
Steps are not numbered to avoid the need to renumber after insert or delete; 
instead they are separated by long lines of -.

Invariants will usually be the absence of types of constructs or guarantees
about behaviour/properties of parts of the system. Occasionally they may be
expression of redundancy (duplication of information in the program though
guaranteed equivalences) though this is discouraged.


@todo early steps for templates, RTTI, Exceptions

----------------------------------------------------------------------------
Specify servers

Determine (by whatever means) how the member functions and trivial 
(non-object) member variables will be divided up into servers. Insert servers
as a hierarchical level between class level and individual functions and POD
data members.

Invariant: Sequential/structural divide now explicit 

Note: Member objects exist at same level as servers, but servers are not 
nestable.

Note: Test code generation should strip out the server layer.

Note: We do this early because other steps add functions to classes and in 
some cases we need to specifiy server structure. 

Note: servers do not nest and exist beow objects. Hence a server may not
contain another server or an object. An object may contain both.

----------------------------------------------------------------------------
Make constructors/destructors explicit

All constructors, copy constructors and destructors get turned into regular
member functions and we add explicit calls to them in the code. Need to treat
each kind of scope correctly: static, member, heap, local. If an object is
passed by value and has a copy constructor, we must turn that into pass by
reference and then insert the copy construct call at the top of the function.
New functions go in same server as original con/de-structors.

Invariant: pass-by-value only for memcpy()able objects; actual object lifecycle
may now differ from that in the original program

Note: We choose not to generate any copy constructor if not already there -
these objects will be treated like fundamental types

Note: this means that const members will need to be un-consted except in the
case of static objects with sufficiently simple initialisation algorithms.
Optimisations could include converting member pointers initialised by new()
into member objects and detecting when a constructor parameter is always
supplied from a const.

----------------------------------------------------------------------------
Staticise heap

Explicitly implement new/delete to allocate objects from static arrays. 

Invariant: No dynamic allocation. All const-member pointers are now globally
constant.

Note: No need to worry about constructors/destructors since that should have
been dealt with in the previous step.

Note: Maybe place in a class if use cases are all below that class (ie 
coming from member funcitons or member objects). New and delete for a given 
type go in the same server.

----------------------------------------------------------------------------
Eliminate this->

Remove dereferences through the "this" pointer or any const pointer equal to
"this".

Invariant: All known accesses to something in the same module do not use
pointers.

Note: Strictly an optimisation, but the invariant helps to clarify.

----------------------------------------------------------------------------
Use Get()/Set()

For fundamental types that are exposed publically, make all inter-object reads
and writes be function calls. New functions go in same server as the public 
member.

Invariant: every inter-object interaction is a function call

Note: the pointer *could* equal "this", but only if it's non-constant in which
case we must support the possibility that it is not "this".

----------------------------------------------------------------------------
Call through pointers

Get rid of all direct calls between objects eg x.y() and replace with calls
though a constant pointer initialised at construct time.

Invariant: All inter-object calls go through a pointer

----------------------------------------------------------------------------
Object boundary forwarding

Introduce thunk functions (trivial forwarding of the call) such that any call 
from a member object to an external object or vice-versa is forwarded through 
a new thunk function within the object. The new thunk function should exist
in a new server.

Invariant: call calls into or out of an object are forwarded hence visible at 
the object's class definition.

----------------------------------------------------------------------------
1:1 caller-callee relationship

Whenever a function fd is called by more than one external server, add 
new functions f1, f2, ... within fd's server, one for each calling server. 
The servers should now call the f1, f2 etc and they should forward to fd.

Invariant: Inter-server calls should now be 1:1 correspondence.

Note: This will result in router/arbiter functionality in each server affected.
Servers generated during the object boundary forwarding step will become 
dedicated arbiters. Nice.

----------------------------------------------------------------------------
Lower NULL pointers

Replace every variable pointer with a non-null pointer and a bool. If the bool
is false, the pointer is considered NULL. Otherwise the pointer is not NULL and
it may be dereferenced.

Invariant: all pointers are non-NULL

Note: No need to do this to const pointers

----------------------------------------------------------------------------
Lower pointer arithmetic

Associate every variable pointer with an int, which begins at zero, and is then
the subject of all pointer arithmetic. Then use array style for derefs. Eg 

p++; return *p; 

becomes 

p.index++; return p[p.index];

Invariant: No pointer arithmetic; pointers only created and overwritten

Note: what about const pointers?

----------------------------------------------------------------------------
Remove references

Implement references using pointers

Invariant: no references

Note: do this after lowering NULL and pointer arithmetic because the pointers
that we will generate for refs don't need to support either of these things. 

----------------------------------------------------------------------------
Memberise locals

Generate a data structure to represent the local variables in each server. Use 
unions for variables whose scope does not overlap. Add an array of these 
structures, up to the max nesting depth, as a server member. Create a member 
stack pointer which should be initialised to zero. Increment it at the start 
of the function and decrement just before returning. Change all code to use the 
array indexed by the stack pointer.

Invariant: all variables are static or members

Note: we have to do this before any SystemC stuff, because it needs all objects
to be static (or members). But we will add more locals later and so this step
will be repeated later. Hopefully re-use implementation!

Note: furthermore, "add dereferencing layer" lowering needs *all* locals to be
memberised first, so moved up again and now applies to all locals

----------------------------------------------------------------------------
Add server-level dereferencing layer

For each server, create an enum with a value for each address-of operation on
a different object/POD data item. This include taking the address of objects or
data outside of the server. Substitute the enum value for the address.

Add functions to each server, for each enum value, that forward function calls 
to the corresponding object/POD item. So if member objects a and b of type C both 
have a function footle( int x ) then we create deref_footle( C *p, int x ) which 
invokes the correct footle() based on p. For fundamental types add eg
deref_get( type *p ) and deref_set( type *p, type val ). Replace pointer derefs
with the corresponding function. 

Invariant: server handles all derefs of internal data

Note: p->f() and equivalently (*p).f() should *not* be broken down into the *p
and the .f() but should be treated as a unit (becomes deref_f(p))

Note: there's now no need to copy the data because we always bring the
action to the data, not the other way around

Note: only do this to variable pointers!

Note: assumes we can call anything whose address can be taken @todo may mean 
we have to do object boundary forwarding of address-of somehow.

Note: since >1 server in an object may have deref functions for the same
data type, we need to unique-ise the names, at least for testing.

----------------------------------------------------------------------------
Refer-back variable pointers

With each pointer, associate an enum representing (a) whether the pointer was
taken locally and if not, (b) which server it came from. Or just add values to 
the existing enum. This other server is the referee server. 

In case (b) add a deref function that decodes the pointer then forwards the call
to the referee server's dereferencer function. 

Note: this new call may pass some other pointer, in which case the referee
server may gain a new enum value for which the original server is referee.
Therefore this step must iterate until no more new deref calls are
required. Only two deref calls are needed between each pair of objects for
any given pointed-to type (one in each direction) so the iterations will
terminate.

Invariant: all inter-server calls are now via const pointers; interpretation of
variable pointers is now local

Note: only do this to variable pointers!

Note: new call also needs a backchannel

----------------------------------------------------------------------------
Change const pointers to ports

Replace Obj *p; with SystemC ports eg sc_port<Obj>.

Invariant: no pointers

Note: ports require 1:1 relationships

Note: this gives us SystemC's "direct TLM" style. 

----------------------------------------------------------------------------
Add local context

Add an SC_THREAD for each server. Incoming calls should wake the local context
and wait for it to complete before returning.

Invariant: no cumulative nesting in calls between servers

Note: this gives us SystemC's "blocking TLM" style. 

Note: Possible major problem here supporting inter-server recursion between this
step and the "make transactions non-blocking" step. Since each server's local
context "camps" in the other server's function while awaiting completion of the
call it is not straightforward for it to resume checking for incoming calls
while waiting. Solution is to employ a pool of contexts for each object and use
a "wake one waiter" event mechanism to ensure we select one waiting context for
each incoming call. Hopefully SystemC supports this.

Note: only change callee (upper executive)

----------------------------------------------------------------------------
Move to 2-phase transactions

Turn function calls into "fake" nonblocking by adding a new call back to the
original caller after processing is complete, just before the original called
function returns. This is called a return functrino.
Outgoing calls should wait after making the initial call and then kick
themselves in the return functrino.

Invariant: no return values on inter-server calls

Note: incoming call looks like a functrino to the caller but isn't implemented
as one. Hence "fake" 2-phase.

Note: Since the return functrino and the kick will come *before* the outgoing
call
returns and the wait begins the semaphore should be 1-in-1-out (or a 1-queue 
event).

----------------------------------------------------------------------------
Make transactions non-blocking

The incoming call should return immediately after kicking the local context. The
return functrino should now come from the callee's local context if not already. 

Invariant: all inter-server calls are functrinos

Note: this gives us SystemC's "non-blocking TLM" style. 

Note: only change callee (upper executive)

Note: Now reduce to one local context. Wait for outgoing calls to return by
recursing back into the context's executive function. This supports recursive
calls.

Note: both calls are functrinos.

----------------------------------------------------------------------------
Add channels

Create a new "channel" (in the SystemC TLM sense) for each caller-callee pair of
server. Forward the functrinos. 

Note: the channel implementation we create will not be stated out but instead
will be converted to wires (=signals) by the protocol step(s) (which have not
been added yet at the time of writing). They will mostly be boiler-plate code.

Note: changes caller and callee but trivially (outgoing functrinos go to
channel)

----------------------------------------------------------------------------
Passivate

Modify the channel. Provide it with passive (call-in) 2-phase interfaces for
both caller and callee. All functrinos go into the channel and the channel kicks
(wakes up) the callee which then collects the parameters. 

Invariant: objects do not receive incoming functrinos

Note: after this step, a functrino is still used to pass a message to the
channel, but to get the message out at the other end we have an event followed
by a "get params" type call on the channel. Maybe the latter is an
anti-functrino?

Note: only change functrino recipients

----------------------------------------------------------------------------
Make transactions 0-queue

For each channel, add an "ack" channel which goes the in the other direction
and has no data. The recipient should ack immediately after receiving the event
and the originator should wait for the ack.

Invariant: now all transactions rendez-vous meaning the data doesn't have to 
be stored externally between origination and receipt.

Note: Now there are 4 events: call, call ack, return, return ack. Call ack 
and return events could be merged but we will regard that as an optional future
optimisation.

----------------------------------------------------------------------------
Split out data and event channels

The outgoing channels should be split into 2 channels: an event-only channel
to signal the event and a data-only channel for the data.

Invariant: can now treat the two kinds of channels separately

Note: the ack channel is already an event-only channel

----------------------------------------------------------------------------
Introduce minor delay

Introduce a primitive called delay() which generates an event to the current
thread then waits for it. This is called a minor delay.

Invariant: can now express minor delays

Note: when we add protocols, we need to be able to avoid combinational loops
so we use this primitive to break them. 

----------------------------------------------------------------------------
Move to signals

The event-only channels become sc_signal<bool> backed by a member variable. 
An event is generated by toggling the value: 1 goes to 0; 0 goes to 1. Reset 
value is 0. The data-only channels become sc_signals<x> where x is the data 
type used. Multiple data items (eg multiple parameters) should result in 
multiple signals (no need to put them in a struct or anything). Add a single 
delay() to the originator algorithm just after the transaction. 

Invariant: All communication is via sc_signal

Note: No need for backing members on data channels because the algorithm will
block during the transaction so the supplied data can't change. 

Note: since we are now dealing with wires, we need to take account of the 
need to avoid combinational loops (which are viewed as part of the behaviour 
of wires). We do this by adding a delay() in such a way that no two transactions 
can occur simultaneously (though the ack can be simultaneous)

----------------------------------------------------------------------------
Add poll loops

Replace all occurrences of wait(x) with while(!x) delay().

Invariant: our reliance on SystemC eventing is hidden and the need for poll loops
made explicit.

Note: this is really associated with "add clock/reset" but we do it up here 
so we can state-out the loop.

Note: we may not need this if using asynchronous technology. State-out should be
able to still work if we skip this step leaving wait(x) in place of delay() loops.

----------------------------------------------------------------------------
Merge member functions

Merge all the member functions in a server into a single one that uses a big
switch statement to select the implementation based on a new enum param. Other
parameters should be grouped into a struct for each of the original member
functions then unioned together for the big function.

Invariant: all calls are simple recursions

Note: this single function is now the server's run function. All other calls 
(apart from SystemC ones which don't count) have now become simple recursions 
of this function.

Note: originally was before memberise locals, but that proved impossible due to
pointer lowering steps. This must be done after structural steps to ensure we
keep seperate call interfaces for seperate call sites (1:1 wiring).

----------------------------------------------------------------------------
Lower constructs

Lower constructs that are not supported in combable (synthesisable) verilog into
conditional branches ie if(cond) goto label; Also after each delay(); add a goto
WAIT_STATE; WAIT_STATE:; 

Invariant: all constructs synthesisable or can be trivially stated-out

Note: there's some flexibility here in how much stuff we lower. It corresponds
to design tradeoffs in the final HW. Any construct surrounding a label must
itself be lowered. 

Note: retain local scope structure for now

----------------------------------------------------------------------------
Add state variable

Add an enum with a value for each label, add a local variable of that type
called state and maintain it correctly by assigning to it immediately before
each goto. Initialise to eg INIT_STATE at start of function.

Note: assert this at each label as a double check since we have a little
redundancy at this point.

Note: the point of this is to establish the state as local, i.e. needs to be
stacked when we recurse.

----------------------------------------------------------------------------
Memberise locals

Generate a data structure to represent the local variables. Use unions for
variables whose scope does not overlap. Add an array of these structures, up to
the max nesting depth, as a class member. Create a member stack pointer which
should be initialised to zero. Increment it at the start of the function and
decrement just before returning. Change all code to use the array indexed by the
stack pointer.

Invariant: all data is static or member

Note: includes state

Note: the same step was done on object type locals earlier on - try to build new
locals into same structure.

----------------------------------------------------------------------------
Remove scopes

Scoped blocks (surrounded by {}) should now be completely redundant. Get rid of
them.

Note: was part of memberise locals, but now that step has to be run twice and
the first time doesn't want to do this.

Invariant: No scopes (apart from overall function scope)

----------------------------------------------------------------------------
Lower recursion

Turn each recursion call point into a goto to the start of the function and at
the very end of the function insert a goto to the label implied by the state
variable.
 
Invariant: no recursion; no non-trivial function calls 

Note: the "goto a variable" construct would have to become eg a switch statement
for the purposes of testing this step. It vanishes in the "State-out" step.

----------------------------------------------------------------------------
Else clauses for skipped code

Place code after a conditional goto (a goto in an if) up to the next label into
an else clause if it isn't already in one. If there is code between an
unconditional goto and the next label, it is an error (the code is unreachable)

Invariant: sections of code between labels is now combable

----------------------------------------------------------------------------
State-out

Surround the entire function with a switch statement on the state variable.
Generate a case for each label ending just before the next label. Insert a break
at the end of each case. Remove the gotos, leaving only the assignments to the
state variable. 

Invariant: context is released between each combable block

Note: we are taking advantage of the fact that SC_THREAD loops infinitely

----------------------------------------------------------------------------
Extract waits

Replace all delay() calls with a single one at the bottom of the function.

Invariant: no non-trivial context across a delay()

Note: this is possible because all the delay() calls are at the ends of state
cases and there's nothing after them until you get to the bottom of the
function.

----------------------------------------------------------------------------
Insert clock and reset

Move all classes to SC_CTHREAD. Replace the delay() at the bottom with 
wait(clk).

Invariant: no more arbitrary delay() calls - all events explicitly controlled 
by clock

Note: not sure about clock distribution or how to handle reset.

----------------------------------------------------------------------------
Remove local context

Move to SC_METHOD. Remove the wait() call.

Invariant: no persistent implicit context

Note: this is really a pattern reduction: SC_CTHREAD{ ...; wait(); } becomes
SC_METHOD{ ...; }. If any functions don't match the pattern we have an error.

----------------------------------------------------------------------------
Initialise data

All initialised statics to be initialised in a "initial" block.

Invariant: no inline initialisation

Note: how do initial blocks in SC?

----------------------------------------------------------------------------
Lower types

Convert types like char, int into bit vectors. Support bit fields properly. Bool
becomes a 1-bit type. 

Invariant: no types unknown to Verilog

Note: we will hopefully be able to tolerate arbitrary bit vectors in SC form eg
sc_bitvec<5> all the way through the process.


@todo late steps for dealing with wire vs latch vs flip-flop
@todo replace events with some kind of protocol - maybe just after insert
clock/reset

