(C) Copyright 2006 John Graley
Available under the terms of the BSD license. 

Structural phase - steps relating to program structure (inter-object level)

In this phase, we deliver on the promise made in the philosophy document: that
we would avoid simply re-creating a single computer (by doing state-out and
similar on the whole input program at once) and instead regard the program as a
network of semi-autonomous interacting agents.

These agents will each be stated-out separately. Each one is capable
of implementing whatever code we partition into it as well as any code we choose
to add. Any code we add must confirm to the subset of C++ established in earlier
phases. We partition at object level. 

We choose to replace function calls between objects with pairs of
function-call-like things called functrinos. A functrino has a call event and
parameters but no return or return value. There's a functrino for a function
call and another for its return. Functrinos could probably be used to model
other things like messages, and some "void" functions with the right properties
could be modelled with only a call-functrino, but that's for the future. The
real advantage is that we've get rid of some inconvenient aspects of functions.

We will choose to pass functrinos through a number of "thunks" or forwarding
functrinos that simply call through to another functrino. This is done to
establish the paths that will be taken by what will eventually become wires. We
need to be able to tell Verilog where they go, and we need to marshall them and
avoid blatant duplication. These steps actually give rise to arbiters (and
possibly routers) as structures that emerge from thunks as the later structural
and sequential steps execute. This is a nice result.

Each object, after state-out, will possess its own context of execution in the
form of a physically manifest state variable. In this phase, we choose to model
them using SystemC's SC_THREAD primitive, which is really just a wrapper for an
OS thread. It helps us run tests on intermediates and is also a conceptual aid
since we can "re-use" understanding of multi-threaded programming, admittedly in
SystemC's esoteric style (but remember SystemC is designed to be mappable to
hardware). We ensure that functrino interactions between threads are
non-blocking, so that each functrino may be considered as an instantaneous
event (at least for now). 

Functrinos going between objects are still unacceptable for state-out.
TODO why? We
therefore need to go quite low-level in this phase in terms of describing a
protocol that makes the program structure look like the ends of some
well-defined wires from the perspective of an object. 

We begin by introducing the Transaction Level Modelling concept of a channel for
each functrino. Over a few steps, the channels are modified to avoid making
calls into objects (instead they use SystemC's channel->module wakeup scheme)
and split up into finer, more role-specific channels.

We add an acknowledgement for each functrino. This is to be understood as a
low-level ack that serves protocol functions: flow control and data validity
marshaling. The reader may object that we have divided function calls twice
now: first into call-functrino/return-functrino, then into 
call-request/call-ack/return-request/return-ack. But this is no different to
ARM's AXI bus spec, that has avalid/aready/rvalid/rready for a read transaction.

Finally, we actually insert SystemC's version of wires, the sc_signal<x>
pre-defined channel. In the interests of proper correctness, we also choose now
to add a notional time delay, called a "minor delay" in order to prevent objects
from trying to do impossible things like toggling a wire twice simultaneously.

The steps within this phase follow:

----------------------------------------------------------------------------
Move to 2-phase transactions

Turn function calls between module instances into "fake" nonblocking by adding 
a new call back to the original caller after processing is complete, just before 
the original called function returns. The original call is now called a
call-functrino, and the new call is called a return-functrino.

Replace each interface that is bound to ports in other module instances with two 
functrino interfaces: a call-interface and a return-interface. The call-interface 
should be the same as the original interface except names should be prefixed with 
"call_" and the return types should be void. The return-interface prefixes function 
names with "return_", has a single parameter of the original function's return type, 
and returns void.

Call-interfaces should replace the original interfaces and ports should be bound
to the call interface. Every module that binds a port to a call-interface (either
statically or dynamically due to pointers steps) should implement the corresponding 
return interface.

The original functions should be prefixed with "impl_" and should have no parameters
or return value. The original interface should be removed and the impl functions
should be made private.

Call-functrinos should store the parameters and the dynamic id of the caller 
in new member variables and then call the corresponding impl function. Before each 
return statement, the impl function implementation should invoke the corresponding 
return-functrino through a new unbound port using the supplied id for dynamic 
binding. The return value should be passed to the return functrino and the actual 
return statement should return void (no return value).

Return-functrinos should store the return value in a member variable so that it
may be read by the original calling code.

The idea here is to establish that the return event and return value come via a
second call. Now, each of these calls has no return value and the only important
event is their calls, not their returns. These are the characteristics of
functrinos.

Invariant: only functrinos between objects.

Note: initial call is a functrino as far as the caller is concerned but isn't 
implemented as one by callee. Hence "fake" 2-phase.

Note: Functions that return void may be implemented in a single phase (no return-
functrino) in two ways:
1. Do the work inside the functrino. Basically, we label the function as a 
call-functrino.
2. Let the call-functrino start the function running and return immediately, and 
don't bother with the return-functrino
Both of these have issues: 1. will prevent the calling state machine from executing
concurrently; 2. will have issues if the function has side-effects. 
I suggest always putting both in to start with. If a calling function ignores the
return-functrino, synth tools may optimise out the wires anyway.

Example output:

class return_G : public sc_interface
{
    virtual void return_g( int retval )=0;
}

class call_G : public sc_dyn_interface<return_G>
{
    virtual void call_g( char x )=0; // was virtual int g( char x )=0 in the original interface  
};

class A : public return_G
{
    int stored_retval;
    char stored_x;
    sc_dyn_id< return_G > stored_return_id;
    sc_port<call_G> portb;

    SC_CTOR
    {
        portg(b); // statically bound
    }

    void f()
    {
        ...
        portb.g_call();
        y = stored_retval; // gets the return value from function g()
        ...
    }

public:    
    void return_g( int retval ) // return-functrino
    {
        stored_retval = retval;
    }    
} a;

class B : public call_G // used to inherit from the original G interface
{
    sc_port<return_G> return_port; // new port, dynamically bound

    void impl_g() 
    {
        ... g()'s algorithm ...
        int retval = stored_x*22; // or whatever
        return_port(stored_return_id).return_g(retval);
    }    

public:    
    void call_g( char x ) // call-functrino
    {
        stored_x = x;
        stored_return_id = sc_get_incoming_id();
        impl_g();
    }    
     
    // g used to be 
    // int g() { return x; }
} b;


----------------------------------------------------------------------------
Class boundary forwarding

Introduce thunk functrinos such that any functrino call from a member object to
an external object or vice-versa is forwarded through a new thunk functrino
within the object. The new thunk functrino should be a member of the aforementioned
object.

Verilog modules require that all interaction between "stuff" inside and "stuff"
outside the module is explicitly manifested by wires. This step helps to make
all interactions visible at the required level(s) of the hierarchy.

This step requires a recursive pass over all classes since arbitrarily nested 
member classes need to forward their functrino calls through all enclosing layers.

All classes with no non-trivial members objects should be marked as "forwarded" 
(they do not require this step). Iteratively, any class whose non-trivial members
are all marked as "forwarded" may be modified for forwarding. This iteration will 
terminate once all classes are modified.

The modification is to (a) duplicate all public member functrinos of all member
objects in the enclosing class's interface and (b) duplicate all external functrinos
that are called from member object's member functions. Duplicated functrionos 
should be implemented simply to forward the call. 

Note: We could just use a primitive in the internal representation for this, that
doesn't render to anything in test builds, but the functions we generate will
turn into Arbiters as later steps are applied to them, and will give us the
associated streamlining and reduction of wiring complexity.

Note: since all member functions will be merged into a single state machine,
this means that such functrinos will be sequentialised against all other
similar external/member functrinos as well as the implementations of the 
object's own functions. This limitation may be mitagated by choice of 
class hierarchy in the input program.

Note: we should be forwarding calls between two seperate member obejcts 
of the same class through the enclosing object.

Invariant: calls into or out of an object are forwarded hence visible at 
the object's class definition.

Example output:

class A
{
public:
    void p( int ); // functrino
};

class B
{
private: // used to be public
    A subobject;
    
public:         
    // Thunk functrino just forwards the call
    void subobject_p( int x )
    {
        subobject->p( x );
    }
};

----------------------------------------------------------------------------
1:1 caller-callee relationship

Whenever a functrino pd is called by more than one external object, add 
new functrinos p1, p2, ... within pd's object, one for each calling object. 
These objects should now call the p1, p2 etc which should forward to pd.

We need a 1:1 caller-callee match in order to be able to bind ports and
introduce channels. This step was originally much higher up because it was
thought a prerequisite for pointers and 2-phase. However, those steps are no
harder without, so we now do this as late as channel construction will allow.

Since there is only one state machine in each object, a given object can only 
count as a single caller to a function F even if the code in the object
has multiple call points.

The forwarding has already ensured that external calls can only come from
the enclosing object. So only one call can come from outside the present
object. However, member objects may make calls too. So the original functrino
interface should be preserved for calls from the outside, and duplicates
should be created for as many member objects contain the code to call the
functrino interface.

This will result in router/arbiter functionality in each object affected.

Invariant: Inter-object calls should now be 1:1 caller-callee correspondence.

todo: IMPORTANT 
this step seems to require looking into member object code to spot 
outgoing calls, or to duplicate *every* callable member function for every
member object just in case it makes a call. Neither is very desirable so it 
may be better to add a "designate outgoing calls" step that moves outgoing
call knowledge from implementation to interface. Forwarding and functrino 
generation might benefit from this too. 

@todo do I need to collect together all the outgoing calls eg in object Y 
in the example output?

Example output:

class Y // use p1 for all outgoing calls from this object
{
    void q()
    {
        x.p1();
        x.p1();
    }
    
    void r()
    {
        x.p1();
    }
}

class Z // use p2 since now in a different object
{
    void i()
    {
        x.p2();
    }
}

class X // this class used to just have pd() but has now had the 1:1 step done on it.
{
private:    
    Y y;
    Z z;
    void pd()
    {
        ...blah...
    }
    
    
public:
    void p1() // new functrino
    {
        pd();
    }
    
    void p2() // new functrino
    {
        pd();
    }
} x;

----------------------------------------------------------------------------
Add local context

Each incoming functrino p() should generate an event (after storing its parameters) 
that wakes the SC_THREAD which should be running an upper executive function. 
The upper executive should invoke an implementation function eg p_impl(); An 
enum should be created to differentiate between multiple functrinos.

The idea is to introduce a context (in the form of a SC_THREAD) for each object
and ensure that it is used to execute all existing functrinos within that
object. We have to use events to signal the threads, but we keep the external 
interface of the servers the same. This step does the same thing to all functrinos
regardless.

Invariant: A given object's code is executed within a context that belongs to
it.

Note: at this stage, all events are internal to objects, and do not go between
servers.

Note: Possible major problem here supporting inter-object recursion between this
step and the "make transactions non-blocking" step. Since each object's local
context "camps" in the other object's function while awaiting completion of the
call it is not straightforward for it to resume checking for incoming calls
while waiting. Solution is to employ a pool of contexts for each object and use
a "wake one waiter" event mechanism to ensure we select one waiting context for
each incoming call. Hopefully SystemC supports this @todo check!

Note: maybe use a clean internal format for remembering what's a SC_THREAD etc
and what its sensitivities are, and only generate the SC_CTOR when rendering for
test.

@todo maybe extract a step that splits p() into a trivial p() and a p_impl() and
add the executive in a separate step above this one, lashed up so that p()
invokes the executive directly. That might simplify the changes that are loaded
onto adding contexts (which seem rather heavy atm).

Example output:

SC_MODULE(A)
{
    enum { P, Q } which;
    sc_event X_wake, p_wake, q_wake;

    void X_executive() // upper executive
    {
        while(1)
        {
            wait( X_wake );
            switch( which )
            {
                case P:
                    p_impl();
                    @todo event p_wake             
                    break;
                    
                case Q:
                    q_impl();
                    @todo event q_wake
                    break;
            }            
        }
    }

    SC_CTOR(A)
    {
        SC_THREAD(X_context)
        sensitive << X_wake;
    }
    
    server X
    {
    public:
        void p()
        { 
            which = P;
            @todo event X_wake;
            wait( p_wake );
        }

        void q()
        {
            which = Q;
            @todo event X_wake;
            wait( q_wake );
        }

    private:
        void p_impl()
        {
            ...code taken from original p()...
        }

        void q_impl()
        {
            ...code taken from original g()...
        }
    }
};


----------------------------------------------------------------------------
Make transactions non-blocking

Functrinos should return immediately after kicking the object context.

By allowing the functrinos to return immediately, we are allowing the
execution paths of caller and callee to proceed independently, at least to an
extent. This will be an important step when parallelism becomes important. It
may also be viewed as a natural consequence of having done both "fake 2-phase"
and "add local context" and then cleaning up the resulting code.

The wait_return() primitive must now be implemented properly, since the
call-functrino returns immediately and can no longer be used to discover when
the function call has completed. wait_return() should be implemented as a
recursion into the object's upper executive function. The signal_return()
function should set a flag that causes the upper executive to return (exactly
once). 

All data used in the now-recursive executive must be explicitly stacked with a 
new stack pointer. All new data must be raw integral member data. This is because 
local variables and the stacks that support them have already been lowered out 
in the data phase.

Invariant: all functrinos return immediately

Note: only change callee (upper executive)

Note: Now reduce to one context per object. Wait for outgoing calls to return by
recursing back into the context's upper executive code. This supports recursive
calls.

Note: at this stage, each functrino corresponds to a sub-transaction.

@todo example confusing because there are 2 distinct pairs of
wait_return()/signal_return() in the 2 modules.

@todo split out the wait_return()/signal_return() implementation via recursing
the upper executive into a separate step above this one. Yes, and the explicit 
stack creation.

Example output:

SC_MODULE(A)
{
    event q_done_event; 
    int q_retval;

    void p()
    {
        ...
        b.q_call();
        wait_return( q_done_event ); 
        y = q_retval;
        ...
    }

public:    
    void q_return( int retval ) // functrino
    {
        q_retval = retval;
        signal_return( q_done_event ); 
    }    
} a;

SC_MODULE(B)
{
    enum { Q } which;
    sc_event X_wake;
    bool got_return;
    
    void wait_return() { X_executive(); }
    void signal_return() { got_return=true; }

    void X_executive()
    {
        while(!got_return)
        {
            wait( X_wake );
            switch( which )
            {
                case Q:
                    q_impl();
                    a.q_return()      
                    break;
            }            
        }
        got_return=false;
    }

    SC_CTOR(B)
    {
        SC_THREAD(X_context)
        sensitive << X_wake;
    }
    
    void q_call()
    { 
        which = Q;
        @todo event X_wake;
    }

    void q_impl()
    {
       ...code taken from original q()...
    }
};


----------------------------------------------------------------------------
Add channels

Create a new "channel" (in the SystemC TLM sense) for each sub-transaction. The
channel should forward the functrino calls. The idea is that we turn functrinos
into channels and then progressively modify the channels' implementation towards
being like wires.

Invariant: we have a presence, in the form of a channel, between communicating 
pairs of objects.

Note: the channel implementation we create will not be stated out but instead
will be converted to wires (=signals) by the protocol step(s). It will mostly 
be boiler-plate code.

Note: changes caller and callee but trivially. Code in objects doesn't really 
change - just calls functrinos through the channel implementation instead of 
directly.

Example test render (channel for functrino k(char c)):

// Note: the channel implementation is just for test rendering; it doesn't 
// get fed into later stages.
class Channel_k : public sc_interface
{
    void do_functrino( char c )
    {
        dest.k( c );
    }    
};

----------------------------------------------------------------------------
Passivate

Modify the channels. Provide each with passive (call-in) 2-phase interfaces for
both caller and callee. All functrinos go into the channel and the channel kicks
(wakes up) the callee using an event and the callee then collects the fuctrino
parameters from the channel. 

The passive call model is an essential step since the function call model
produced in the sequential phase (state-out) will only be able to handle
function calls within objects. In this phase, therefore, we must eliminate calls
between objects completely. This phase removes calls that go into objects,
and calls coming out of objects will be broken down into primatives that
correspond to driving or polling inter-object wires.

Invariant: objects do not receive incoming functrinos

Note: after this step, a functrino is still used to initiate a sub-transaction,
but the recipient gets an event and does a "get data" type call on the channel
to get the data. We therefore rely on SystemC to convey events into objects.

Note: the call into the channel to get the params is not a functrino since 
it goes to a communications primitive (the channel) and not an object.

Note: the event mechanism should be counted, so that 2 events cause 2 wakes.
This eliminates the risk of dropped events due to racing.

Note: only change functrino recipients

Example test render (channel for functrino k(char c)):

// Note: the channel implementation is just for test rendering; it doesn't 
// get fed into later stages.
class Channel_k : public sc_interface
{
    char param_c;
    
    void do_functrino( char c )
    {
        param_c = c;
        @todo event the connected destination port
    }
    
    void get_data( char &c )
    {
        return c;
    }
};

do_functrino() replaces f_data() (for call-functrinos) or f_return() (for
return-functrinos). 

----------------------------------------------------------------------------
Make functrinos rendez-vous

For each channel, add an "ack" channel which goes the in the other direction
and has no data (same passive model). The recipient should ack immediately after
receiving the event and the originator should wait for the ack.

The ack serves two purposes: (1) marshaling of interactions to ensure that
events are not sent too rapidly for the recipient to handle them and (2) to
ensure that there is a well defined period of time for the recipient to read the
accompanying data.

This model is a rendez-vous model. The rendez-vous takes place for a finite
period of time beginning at receipt of the request and ending when the ack is
sent. A single request-ack cycle is a sub-transaction and the accompanying data
is valid for the recipient during this period.

It is expected that the request-ack period should be much shorter than the
call-return delay in a real system.

Invariant: now all transactions rendez-vous meaning the data doesn't have to 
be stored externally between origination and receipt.

Note: Now there are 4 events: call, call ack, return, return ack. Call ack 
and return events could be merged but we will regard that as an optional future
optimisation.

Note: transactions now 4-phase; sub-transactions now 2-phase

Note: arrange for the "ack" to clear the stored data, or mark it as
unavailable for testing, to ensure we only consult the data when it is actually
available. Also ensure another request is not sent before the ack from the
previous one.

Example test render (channel for functrino k(char c)):

// Note: this is all just for test rendering; it doesn't get fed into later
// stages.
class Request_k : public sc_interface
{
    char param_c;
    
    void do_request( char c )
    {
        param_c = c;
        @todo event the connected destination port
    }
    
    void get_data( char &c )
    {
        return c;
    }
};

channel Ack_k : public sc_interface
{
    void do_ack()
    {
        event the source port
    }
};

Sender code goes:
    ...
    request_k.do_request('a');
    wait( ack_k );
    ...
    
Recipient event handler code goes:
    case K:
        c = request_k.get_data();
        ack_k.do_ack(); // Ack immediately
        ...do whatever is implied by functrino k...

----------------------------------------------------------------------------
Split out data and event channels

The outgoing request channels should be split into 2 channels: an event-only
channel to signal the event and data-only channels for the data. This step
simply makes the channel structure look more similar to what will be achieved
using wires. In particular we go from having request channels and ack channels
to having event channels and data channels.

Invariant: can now treat event channels and data channels separately

Note: the ack channel is already an event-only channel

Note: if >1 param, create multiple separate data channels one for each param.

Example test render (channel for functrino k(char c)):

// Note: this is all just for test rendering; it doesn't get fed into later
// stages.
class Data_k : public sc_interface
{
    char param_c;
    
    void set_data( char c )
    {
        param_c = c;
    }
    
    void get_data( char &c )
    {
        return c;
    }
};

class Request_k : public sc_interface
{    
    void do_request()
    {     
        @todo event the connected destination port
    }
};

Sender code goes:
    ...
    data_k.SetData('a');
    request_k.do_request();
    wait( ack_k );
    ...
    
Recipient event handler code goes:
    case K:
        c = data_k.get_data();
        ack_k.do_ack(); // Ack immediately
        ...do whatever is implied by functrino k...

----------------------------------------------------------------------------
Introduce minor delay

Introduce a primitive called delay() which generates an event to the current
thread then waits for it. This is called a minor delay.

At present, we do not actually use these anywhere; the significance of this step
is that we have added our first sequential/timing construct apart from the
natural execution sequence of software. We have to do this in the structural
phase because the wire-based protocol cannot be correctly described without it.

Invariant: can now express minor delays

Note: when we add protocols, we need to be able to avoid combinational loops
so we use this primitive to break them. 

todo: get rid of this step because it doesn't actually do anythin, but preserve 
the description of minor delays.

Example test render for delay():

delay()
{
    @todo event current thread
    wait( delay_event );
}

----------------------------------------------------------------------------
Move to signals

The event-only channels become sc_signal<bool> backed by a member variable. 
An event is generated by toggling the value: 1 goes to 0; 0 goes to 1. Reset 
value is 0. The data-only channels become sc_signal<x> where x is the data 
type used. Multiple data items (eg multiple parameters) should be merged into
a single struct. Add a single delay() to the originator algorithm just after 
the transaction. 

Invariant: All communication is via sc_signal

Note: No need for backing members on data channels because the algorithm will
block during the transaction so the supplied data can't change. 

Note: since we are now dealing with wires (which is what signals really are),
we need to avoid combinational loops (which are viewed as part of the behaviour
of wires). We do this by adding a minor delay so that no two transactions
can occur simultaneously (though the ack can be simultaneous).

The protocol allows ack to be derived combinationally from the request
line, i.e. with no delay. A delay is required after the transaction, so that
the next transaction does not occur simulataniously. In an earlier design,
the delay was required to be between request and ack but this prevents us 
from implementing guaranteed instant ack by simply connecting ack line to
request line (which then allows synth tools to remove the ack wire and
maybe also the request wire). For clarification, if both request and ack 
toggle in the same clock cycle, then they correspond to the same transaction
and the data lines are valid for that transaction at the time of the toggle.

Note: we use toggling for our pulse model because: (a) using logic 1 for a
pulse requires that we measure clock cycles as with AXI protocol ready and
valid lines and (b) doing a complete 0-1-0 pulse would require 2 minor 
delays which is >= 2 clock cycles.

Example for a functrino k(char, int):

Channels Data_k, Request_k and Ack_k are replaced by
struct data_k_type { char p1; int p2; };
sc_signal<data_k_type> data_k;
sc_signal<bool> request_k, ack_k;

Sender code goes:
    ...
    data_k.p1 = 'a';
    data_k.p2 = 42;
    request_k = !request_k;
    wait( ack_k );
    delay();
    ...

Recipient event handler code goes:

    case K:
        c = data_k.c;
        i = data_k.i
        ack_k = !ack_k; 
        ...do whatever is implied by functrino k...

Wait function implemented thus:

wait( sc_signal<bool> s )
{
    bool os = s;
    while(os == s) 
    {
    }
}
