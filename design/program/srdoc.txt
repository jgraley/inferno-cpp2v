		Inferno Search and Replace User Guide

1 The SearchReplace class

Inferno uses a search and replace engine for the majority of transformation steps. The generic search and replace implementation may be found in the SearchReplace class and a number of supporting classes. The SearchReplace constructor requires certain data structures that specify search pattern, replace pattern and some other info. Once constructed, a SearchReplace object serves as a tree transforming functor (ie it implements the Transformation interface).

This documentation explains how to set up the correct inputs to the SearchReplace class so that it will create the transformation you desire.

1.1 Search and replace patterns as subtrees

The first two parameters to the SearchReplace constructor are, resectively, the search pattern and the replace pattern. Each is a TreePtr to the root of a subtree of nodes. SearchReplace will search for an occurance of the search pattern and replace it with a duplicate of the replace pattern. You may alternatively construct a SearchReplace with no parameters and then pass the search and replace patterns to Configure().

1.2 Special nodes

S&R supports additional nodes called "special" nodes that are defined by S&R. Special nodes do not appear in the program representations for any language, instead they invoke addional S&R funcitonality when used in search and/or replace patterns. Since Inferno tree pointers are strongly typed (links point to an intermediate type corresponding to the subset of child node types allowed), we allow special nodes to derive from a user-specified type. This type is specified as a template parameter to the special node. Normally, the base type should be the same type as the pointer that will point to the special node, but see pre-restriction under topological wildcarding.

1.3 Termination

The SearchReplace algorithm repeatedly attempts to find a match to the search pattern, and substitutes the replace pattern, until it can no longer find a match to the search pattern. Therefore, it can run forever if for example the replace pattern re-creates a search pattern match. It it the user's responsibility to prevent this from occuring.

The reason for this strategy is that in some cases it is reasonable to recreate the search pattern as long as repeated substitutions eventually "converge" to a final tree that has no matches. This convergent policy reflects the general Inferno approach of seeking to eliminate constructs, thereby reducing the expressivity of the dialect. 

2 Tolopogical wildcarding

Inferno nodes are orgnised in an inheritance hierarchy beginning with Node, from which certain intermedates like Statement and Type are derived, and then the final nodes are derived from the intermediates. In many cases there are multiple levels of intermediates between Node and the final Node, and Multiple inheritance is allowed. This hierarchy is best understood as a Venn diagram, where subclass is synonymous with subset.

The trees for programs are only allowed to consist of final nodes. So Node and the intermediates are not allowed in program trees. They are allowed, however, in search and replace patterns as long as they would not end up in the output of the search and replace transformation. 

When an intermediate node is seen in a search pattern, it serves as a wildcard for any node derived from it. For example, Return and Goto are both derived from Statement, so a Statement node in a search pattern will match Return, Goto and any other node derived from statement. In set theoretic terms, we have restricted the search to the set of statements.

As an example of multiple layers of intermediates, consider that Expression is derived from Statememt, making expressions a subset of statements. This is consistent with the rule in C that an expression may be used in place of a statement, but not the other way around. Consequently, a node of type Statement in a search pattern will match any expression as well as other kinds of statements, but an Expression node in a search pattern will only match expressions.

Due to Inferno's type-safe tree, it is not possible to specify nonsensically broad intermediates in a search pattern. This is because the TreePtrs used in nodes are pointers to intermediates, and only identical or more derived (subset) nodes may be pointed to. Therefore the broadest wildcard possible is one whose type is the same as that of the TreePtr that will point to it. Such a pointer is called maximally wild and will match on all legal input programs.

Such maximally wild pointers may be considered similar to the use of "?" character in filename wildcarding. Other intermediate topological wildcards could be likened to a value range in certain textual schemes for example /a-z,A-Z/ though it should be noted that Inferno's topological (set-theoretic) restriction is more expressive than linear range restriction.

2.1 Can populate intermediates members

In the inferno tree, some intermediate nodes have members: these members would appear in all derived classes. Members may be filled in when intermediates are used in a search pattern. These members will be matched as normal and will serve to restrict the search pattern.

For example, giving the node Integral and pointing the width member to a SpecificInteger of value 32 (which we could write Integral(width:SpecificInteger(32)) ) will match 32-bit signed and unsigned data types since Signed and Unsigned both derive from Integral.

Note: to wildcard the width and fix the signedness we would use eg
Signed(Integer) in other words we use the final node for the type (Signed) and fill in the width with the maximal wildcard, which is Integer in this case. See tree.hpp for the definitions of these nodes.

2.2 NULL in search patterns

In trees for programs, we do not allow NULL (cases of disabled functionality must be dealt with explicitly, for example with nodes such as Nop and Void).

We do allow NULL in search patterns, where it serves as shorthand for the maximal wild card. Therefore, Signed(Integer) is the same as Signed(NULL) as a search pattern.

2.4 Pre-restriction on special nodes

The detailed behaviour of all the different kinds of special nodes is given below. When searching, all special nodes support search restriction via the bass type supplied as the first template parameter (recall that special nodes derive themselves from the supplied base type). Regardless of what the special node is defined to do, all searches will restrict in the usual sense to program nodes that are non-strict subclasses of the base class. 

Type-safety means that a tree pointer can only point to non-strict subclasses of the pointer type. Therefore if the base class is of that type, no restriction will be seen when the search runs. Only if a strict subclass is given will a restriction be seen to take effect. This is called a pre-restriction since it seems to apply before the special node's special algorithm runs (which will typically apply some further restriction independently of the pre-restriction under an "and" rule).

As a final note, the pre-restriction is only a class, not a subtree like restrictor and terminus. If you require the special node to match a subtree, use the MatchAll node documented below. 

2.5 Notes on tolopogy-oriented tree

In order to maximise the utility of toplogical wildcarding (and its coupling support) the inferno tree has been contrived to express as much information as possible in the node hierarchy and through TreePtrs to other nodes. So for example where a node might naturally contain a boolean (such as the signdness of an integral type) or an enum (such as an access specifier which can be public, private or protected) one of two techniques is used:
- the options are expressed in a set of final nodes as with Signed and Unsigned, making the original node (Integral) become an intermediate node or
- a new hierarchy of nodes is created with a common intermediate and final nodes corresponding to the options, as with Public, Private, Protected which are all subclasses of AccessSpec.
In fact, this policy leads most nodes to contain only TreePtr, Collection and Sequence. Only a small number of nodes contain other data types such as int, string etc that cannot be accomodated toplogically. This is termed a toplogically-oriented tree and is a reasonably consistent canonical form for program elements.

3 Couplings

When a wildcard has been specified in a search pattern, it is often useful to be able to make use of the actual subtree in the input program that the wildcard matched. We may wish to:
- restrict the search so that two wildcards in the search pattern must match the same subtree in the input program and/or
- introduce the input program subtree that matched a search pattern wildcard into the output program, as a substitute for part of the replace pattern.

3.1 Restricting with couplings

Suppose we use the wildcard Integral in two places in a search pattern. Each will individually match Signed or Unsigned, giving a total of four matching combinations: SS, SU, US and UU. But suppose we only want to match on SS or UU (perhaps because the two types must be the same for an optimisation to be correct). 

We can achieve this by placing only a single copy of the node (in our example, Integral) in the search pattern. Both of the nodes that would point to the Integral nodes now point to this single node, so that it has two parent nodes. This node is said to be coupled, and Inferno will only find a match when the two types are the same as each other. Couplings point to nodes in the search tree, but they act on the nodes found in the input program tree and will check to make sure they are the same as each other. 

In fact, couplings restrict the entire subtree matched to the coupled nodes to be identical to each other - so the two types in the above example would be restricted to have the same width regardless of what is supplied for the width in the search pattern. 

3.2 Coupling into the repace pattern

We can also allow the replace pattern to point to a node that is already pointed to by the search pattern . Now, whenever the search pattern finds a match, the coupled node will be associated with the subtree of the input program that matched the coupled nodes. SearchReplace will substitute this subtree into the replace pattern. 

3.3 Overlaying

Where a node couples into search and replace pattern, its children do not normally appear in the output. These children only serve to restrict the matches found during search, and during replacement, the matched input program subtree is used for the output tree (instead of the coupled node or its children).

However, it is possible to arrange for some part of the input program subtree to be replaced by nodes provided in the replace pattern. This is done by placing an Overlay node somewhere in the subtree under the coupled node in the search/replace pattern. It has two child pointers: through and overlay. During search, S&R will try to match the subtree pointed to by through. During replace, S&R will substitute the input program subtree that was matched, and then it will "overlay" the subtree pointed to by overlay.

The overlay process is recursive, that is it can overlay a child of the node pointed to by overlay over the equivalent child of the matched input program node. It operates as follows:
- If the overlay node is the same type as the input program node, any TreePtrs that are non-NULL in the overlay node are overlaid over the corresponding TreePtrs in the input program node (recursively). Where overay node TreePtrs are NULL, the input program node's TreePtr is left as it was. 
- If the overlay node is a base for the input program node, the above procerdure is followed for TreePtrs that exist in the overlay node. TreePtrs in the input program node that do not exist in the overlay node are left as they were. 
- If the overlay node is neither the same nor a base for the input program node, the entire overlay node is copied into the output.
- Containers (sequences and collections) cannot be NULL and cannot be overlaid, so they are always copied into the output when they exist in the overlay node.

3.4 Notes on keyability of couplings

Inferno search and replace has an implementation concept called keying, which is the process of choosing a particular input program subtree that will correspond to a particular coupling. Each coupling only needs to be keyed once, and once it is keyed, the key-to-coupling relationship remains unchanged until the replace has completed.

Normally, Inferno search patterns exhibit an implicit "and" rule, in the sense that every node in the search pattern must match a node in the input program tree before a match is considered successful. This would make every node in the search pattern a candidate for keying a coupling. We say such nodes are in a "normal context". But some special nodes permit a match even when some subtree under that node does not match. These subtrees are said to be "abnormal contexts". 

An abnormal context extends throughout the entire subtree under the pattern node that caused it. So a normal context can contain an abnormal context as a subtree, but an abnormal context remains abnormal all the way down to the leaf nodes. The NotMatch node matches when its supplied subtree does not match, making its subtree pattern an abnormal context. See the documentation for NotMatch for more explaination.

Inferno cannot key to nodes in abnormal contexts. Consequently, every coupling that include search pattern nodes must include at least one parent that is in a normal context. Inferno will find a keyable node in the coupling and key to it if one exists, otherwise an error will be reported. I believe such an error indicates a fundamentally ill-defined transformation.

4 Star search pattern

The Inferno tree supports one-to-many relationships using containers, of which two types are available: Sequence, which preserves ordering and Collection, which does not. When creating a search pattern it can be useful to be able to match zero or more elements of a container. We can do this using a special node called Star<>, which is templated on the collection's element type. So a container of TreePtrs to Statements can be wildcarded using Star<Statement>. If a pre-restiction is given, every container element matched by the Star must satisfy the pre-restriction (ie be a non-strict subclass of the supplied base class).

Star nodes may be coupled into collections in the replace pattern, in order to reproduce all the nodes that were matched by the Star in the search pattern. 

A Star may only be placed in a container, never as ordinary member node of another node. 

4.1 In Sequence

A Star node in a Sequence in a search pattern acts like a "*" character in a filename, in other words it can match zero or more elements at the position of the star. It is possible to use * multiple times and at any position in the pattern sequence. But it is not possible to place two stars consecutively. For example the Sequence (Star<Statement>, If, Star<Statement>, For, Star<Statement>) is a search pattern for any Sequence of Statements that contains an If and a For, and which places the If before the For.

4.2 In Collection

A Star in a Collection acts similarly as when in a Sequence. However, since Collections are unordered, the semantics differ slightly. A Collection in a search pattern may only contain zero or one Star node. If a star node is present, it will match all nodes not matched by other (non-Star) elements of the Collection. For example, the Collection (Star<Declaration>, Typedef, Static) will match any Collection of Declarations that include Typedef and Static, and these may appear in any order.

4.3 Notes on collection matching

To clarify, Inferno uses a non-order-preserving implementation to store all Collections, including ones in search and replace patterns. This means that the order in which elements are specified when constructing a Collection should not affect behaviour. So for example (Static, Typedef, Star<Declaration>) will be equivalent to the above example.

5 Stuff search pattern

Since Inferno search and replace operates on trees rather than just linear sequences of tokens, it is often useful to be able to wildcard a subtree. In fact, the maximally wild intermediate node will accomplish this through topological wildcarding, as discussed above. 

But it is useful to be able to explicitly match some part of the subtree, named the terminus, regardless of the path from the root of the subtree to the terminus. This is accomplished using the Stuff<> node. At the base of the subtree we place a Stuff node, templated on the pointed-to type. This node has a member named terminus, which is a TreePtr<Node>, and any Node or subtree of nodes can be referenced from here.

Inferno will search the subtree under the Stuff node for a match to the terminus. If a terminus match is found, the stuff node is considered a match. For example Stuff<Compound> with terminus as If may be given as the body of a function. It will match the terminus to any If node within the body as well as within nested Compund blocks, For or While loop bodies etc.

Stuff nodes may be coupled into the replace pattern in order to reproduce the subtree that Stuff matched to in the output program. When coupling the stuff nodes, it is possible to overlay the terminus with an alternative subtree in order to modify only what is under the terminus. The terminus node itself and any node in the subtree under it may also be coupled into the replace pattern. 

5.1 Recurse restriction

Optionally, another member of the Stuff node called recurse_restriction may be filled in (otherwise it defaults to NULL). recurse_restriction will typically be a subtree or NULL. Whenever the Stuff node is about to recurse through a TreePtr in its search for a terminus match, it will skip any node that is not a match for the subtree at recurse_restriction.

Therefore, Stuff will only find a terminus that can be reached via a path that satisfies the recursion restriction. This may be useful when, extending the above example, we wish to avoid matching an If that might be in a function that is declared inline in a class that is declared inside the function of interest. If we wish to exclude such cases, we can set recurse_restriction to a Statement node. Now an If node (our terminus) can only be found if there is a direct path of nested Statements, which includes Compound, For, While etc but does not include Type nodes. An unwanted If in this case would be within a Type subtree and so not found as the terminus.

Note that the Stuff node recurse_restrictior only applies when the stuff node actually recurses. It does not restrict the base of the Stuff node and it does not restrict the terminus. So a Stuff node whose terminus matches the input program at the location of the Stuff node will match regardless of recurse_restriction. Also, if the Stuff node has recursed into the input program subtree, the terminus can still match nodes that would not match the restrictor.

Compare with the pre-restriction documented above, which applies to all special nodes. This only applies to the root of the input program subtree, as with all other special nodes. In the general case, pre-restriction, recurse_restriction and terminus are all acting to restrict the Stuff node at different places in the input program subtree: pre-restriction at root, terminus at leaf and recurse_restriction at intervening nodes. 

Note that a recurse restriction pattern is an abnormal context.

6 Boolean search patterns

Search patterns may be restricted according to boolean rules, as explained below. 

6.1 NotMatch

NotMatch implements the "not" function (the complement in set theory). The NotMatch node should be placed at the root of the subtree of interest, and the member named pattern should be set to point to the subtree that should not match. The pattern can itself include wildcards, so a NotMatch(Integral) would match nay data type other than signed or unsigned integer types.

The subtree under a NotMatch node in a search pattern is an abnormal context, in other words it cannot key a coupling. Consider a NotMatch node in a search pattern that is coupled to a node in a replace pattern. This will work as expected - the subtree that did not match the NotMatch pattern is subtituted successfully. 

But consider coupling a node within the NotMatch's subtree into the replace pattern. If there was an overall match of the search pattern, that must mean that some node in the NotMatch pattern did not match. It is possible that the NotMatch pattern is not even of the same layout (topology) as the corresponding subtree in the input program. If this is the case, it is not well defined what node or subtree should be substituted in the replace pattern.

6.2 MatchAll

MatchAll implements the "and" function (intersection in set theory). The MatchAll node should be placed at the root of the subtree of interest, and the member named patterns (a collection) should be populated with all the subtrees that should match. MatchAll does *not* create an abnormal context for its pattern subtrees.

6.3 MatchAny

MatchAny implements the "or" function (union in set theory). The MatchAny node should be placed at the root of the subtree of interest, and the member named patterns (a collection) should be populated with all the subtrees that may match. The subtree under a MatchAny node in a search pattern is an abnormal context.

6.4 MatchOdd

MatchOdd implements the "eor" function. The MatchOdd node should be placed at the root of the subtree of interest, and the member named patterns (a collection) should be populated with all the subtrees that may match. This is probably most useful with 2 patterns, in which case a match is achieved when exactly one of them matches. The subtree under a MatchOdd node in a search pattern is an abnormal context. 

7 TransformTo search patterns

Sometimes, a transformation will appear to be mostly suitable for the search and replace approach, but there may be aspects of the requred matching criteria which cannot be described using the above wildcarding techniques. In such cases, inferno supports the ability to run some user supplied algorithm during the search. The user supplies  the algorithm as an implementation of the OutOfPlaceTransformation and TransformTo<X> interfaces. Objects of the resulting type are Nodes and may be placed in the search pattern as long as the type X must is compatible with the context. TransformTo<> adds a member named "pattern" which is a pointer to any Node.

When the search engine encounters a Transformer node, it applies the transformation implemented by the Trnasformer node to the current input program subtree (without modifying the original copy) and then proceeds to compare the result of the transformation with the pattern pointed to by the "pattern" member. This allows Inferno to search for a subtree in the input program that matches a pattern *after transformation*.

Transformer nodes support the usual functionality of pre-restriction (via the type X) and the ability to couple both the transformer node itself (keying as the untransformed input program subtree) and the node pointed to be "pattern" (keying as the input program subtree after transformation).

7.1 TypeOf

TypeOf is a Transformer search pattern (it may also be used directly as a utility). It is used in the context of an expression. During a search, the TypeOf algorithm will determine the type of an expression in the subtree, and then compare that with the type pointed to by the "pattern" member (note that types and expressions are represented as subtrees under Type and Expression, respectively). 

Note that if the pattern is maximally wild, then TypeOf will maych any valid expression. However, it can be convenient to couple the Type wildcard with another Type in the search pattern, to restrict for type equivalence, or with a node in the replace pattern, to reproduce the type in the output program.

7.2 GetDeclaration

GetDeclaration is a Transformer search pattern (it may also be used directly as a utility). It is used in the context of an InstanceIdentifier. During a search, the GetDeclaration algorithm will search for the declaration of an identifier in the subtree, and then compare that with the declaration pointed to by the "pattern" member. 

7.3 Notes on transformation interface

The search engine requires the presence of TransformTo<X> interface, which supplies the custom comparison functionality which includes invoking the OutOfPlaceTransformation functor. The OutOfPlaceTransformation interface guarantees not to modify the supplied tree and to return a newly created one; this is essential for search and replace usage.

OutOfPlaceTransformation can indicate failure by returning a NULL pointer. Failure results in a non-match.

8 Builder replace patterns

Similar to TransformTo patterns, described above, it is sometimes desirable to generate subtrees using some algorithm apart from the search and replace, and embed these in the output program tree. This is done using builder nodes. At present, the identifier builder is only kind of builder node. 

In general, builder nodes are able to key a coupling. Therefore, it is possible to create a coupling entirely in a replace pattern, as long as it contains exactly one builder node.

8.1 BuildIdentifier

BuildIdentifier is a builder node that constructs identifiers with new names using a printf format string. At present, InstanceIdentifier can be built using BuildInstanceIdentifier, and LabelIdentifier can be built using BuildLabelIdentifier. 

These special nodes have source and format members. The format is a string and will be the name of the newly built identifier. If the format contains %s, then the name of the identifier node pointed to by source will be substituted in that position (can be any kind of identifier). The source will normally need to be coupled into the search pattern in order to obtain a name from the input program tree. The builder node itself may be coupled in the replace pattern to create multiple references.

For example, if a replace pattern is to contain a new variable, and that variable is the count of times a label was jumped to, we might create the variable instance in the replace pattern, and for its identifier we point to a BuildInstanceIdentifier node. We might set the format to "%s_count" and point the source to the LabelIdentifier of the label whose jumps we are counting. If a label is seen called "EXIT", we will get a variable called "EXIT_count". 

Usages of the new variable elsewhere in the replace pattern can just couple directly to the BuildInstanceIdentifier node.

9 CompareReplace

As an alternative to SearchReplace, we can use the CompareReplace class. This has a compare pattern and a replace pattern, supplied as parameters to the constructor or via Configure(). It will compare the supplied input tree with the supplied compare pattern, but only at the root, i.e. it will not walk the supplied input tree searching for a match. The replace pattern will be applied at root, so it will replace the entire supplied tree except where couplings are used (CompareReplace supports couplings and all the special nodes in exactly the same way as SearchReplace does).

Typically, a program tree will begin with the Program node so the compare pattern should match the Program node (which is a kind of Scope). Alternatively, it may be used as a slave, as explained below.

9.1 Note on implementation

The bulk of the implementation of the search and replace algorithm is actually inside CompareReplace, since ComapreReplace solves a conceptually simpler problem. Because CompareReplace supports couplings and special nodes, it is possible to emulate SearchReplace functionality by using a Stuff node and an Overlay node at the root of the patterns. This is exactly what SearchReplace actually does: at configure time, it constructs Stuff<Scope>(Overlay<Node>(through:user's search pattern, overlay:user's replace pattern) ) and supplies this as both compare pattern and replace pattern to ComapreReplace. The Stuff<Scope> is coupled and serves to reproduce the portion of input program outside the matched subtree into the output program. This is meant to be invisible to the user, but could be relevent when debugging.

10 Slave search and replace

It can be useful to build a 1:n relationship between two search and replace patterns. For example, we may wish to perform a transformation on a variable that affects the declaration and all the usages of the variable. In this example, we would want each match to a variable's declaration (the master) to correpond with n matches to usages (the slaves), where n can be zero or more.

This is achieved by constructing the search and replace pattens for the master (the variable declaration in the example) and then placing a special node called SlaveSearchReplace into the master's replace pattern. The SlaveSearchReplace node is filled in with search and replace patterns for the slave (a usage of the variable in the example). For each match that master finds, the slave will operate repeatedly and will perform zero or more replace operations depending on how many matches it finds.

SlaveSearchReplace has three members: through, which simply points to the remainder of the master's replace pattern, and search and replace which specify the slave's behaviour as documented for SearchReplace. You can also use SlaveCompareReplace, which has through, compare and replace members and behaves as per CompareReplace described above.

What makes slaves useful (as opposed to just running the program through the master and then the slave as two seperate transformations) is the ability to restrict what the slave can match based on the context of a particular match in the master. This is achieved in two ways:

1. Nodes in the slave search pattern may be coupled into nodes in the master pattern. Each such coupling must be keyed in the master (that is, it must include a node in a normal context in the master search pattern or a builder node in the master replace pattern). In the example, the variable modified by the master would be coupled into the slave to ensure it finds usages of only the corresponding variable.

2. The slave node is placed within the master replace pattern. The through member is simply used to continue the master pattern below the position of the slave. The slave will only match at (SlaveCompareReplace) or under (SlaveSearchReplace) the position where it is found in the master replace pattern. In the example, the slave pattern could be placed inside the scope containing the variable's declaration, to restrict matches to that scope.

Note: in this example, placing the slave in the scope is not necessary because a coupling of the variable provides the require resatriction (though this might serve as an optimisation). In other cases, such as detection of Break and Continue there is nothing to couple to: then, only the placement method can restrict the slave sufficiently.

10.1 Nested

It is possible to use more than one slave in a pattern, they appear nested (that is as direct or indirect children of each other) and can nest in two distinct ways:

1. A second slave may be placed under the through member of the first. These slaves are conceptually at the same level, and the nesting just defines the order in which they operate: child first. Both slave patterns operate for each match of the master in the prescribed order.

2. A second slave may be placed under the replace pattern of the first. This creates a sub-slave, which has the relationship described above to the first slave (so the first slave now acts as master to the second). The second slave acts for each match of the first. Overall, we get a 1:n:nm type of relationship.

Note: having these two nesting options is confusing: the first style looks too much like the second and can be easily confused when reading graphs, so it's important to look out for this.

11 Spinning protection

As described above, SearchReplace and CompareReplace act repeatedly until no further matches are found. This mans the output program tree of a search and replace operation (that terminates) does not match the search pattern. This is a reliable post-invariant and serves the concept of Inferno as a principally reductive or goal-seeking algorithm. However, it is possible to create patterns that would repeat forever if every replace action creates another match. For this reason, any algorithm that re-tries a subtree that has been affected by a replace could spin forever.

Some search and replace solutions guarantee termination by for example traversing the input program exactly once while looking for matches on the way. These can suffer from missed matches when the replace action creates a match that was not present during the initial traversal. This may be considered correct, but it's usefulness is reduced by the lack of a post-invariant - systems would be difficult to debug when unexpected constructs appear in output programs. 

Some existing solutions permit a choice of traversal modes: depth-first etc. Making this choice correctly (based on your patterns) can ensure compete coverage, but since this choice is a single choice appliked to an entire pattern, it acts to segregate patterns into non-overlapping categories. Such a segragation does not appear to correpsond to anything fundamental (I could be wrong).

As a practical matter, a (buggy) search and replace pattern that spins forever may be frustrating, particularly since spinning may only be observed on certain test vectors. However, debugging this scenario is actually more straightforward than the alternative scenario of debugging a pattern that does not match due to traversal rules and thereby breaks the post-invariant condition (in my opinion). 

Typically, one uses the -rn<x> option to permit repeating some finite number of times before terminating without error. In the resulting output program, the results of many (say 10 to 100) repetitions of the pattern should be obvious (in graphs and c renders piped though iindent.sh, the repeating portion will usually be found further to the right than the remainder of the program). 

There follow some methods for preventing spinning - these must be appled seperately to the master and to any slaves. This is unlikely to be a complate list.

11.1 Reducing patterns

Any replace pattern that strictly reduces the number of nodes in the tree for each hit, must eventually terminate. We and estimate whether a pattern has this property by counting the number of non-special nodes in the search and replace pattern and noting that the replace pattern is indeed smaller. Care must be taken around Overlay nodes, to determine the size change that results. 

Further, it suffices to reduce the number of occurances of any single node type, as long as it is explicitly matched by the search pattern. For example, the ForToWhile transformation acts only when a For node is seen, and produces an output tree not including the For node that was matched. Even though the output trees are typically bigger, the number of For nodes strictly reduces and the transformation will terminate when there are no more For nodes in the program. This will also work with wildcards (intermediates) as long as no node that would match the intermediate appears anywhere in the replace pattern.

These patterns are termed "strictly reductive".

11.2 "But" pattern

Where a pattern converts a general form of a construct to a specific form the reduction is less redily apparent. What is being removed are constructs of the general kind but not the specific kind. For example, converting general usage of If into a restricted for of If(value:Expression, then:Goto, else:Nop) is actually trying to reduce away the if statements that are not in the form shown.

A common solution is to insert MatchAll in the search pattern, with a NotMatch node on the other leg. So when reducing X to Y, the search pattern becomes MatchAll( X, NotMatch(Y) ). This provides an and-not or but-not type of restriction. The search pattern subtree Y will resemble the replace pattern, but must be supplied seperately because a coupling would not make sense here (or be allowed because the subtree under NotMatch is an abnormal context).

11.3 GreenGrass node

Inferno S&R supports a special node called GreenGrass to help in tricky cases of non-termination. It is inserted into a search pattern via its through memeber. The immediate child node will be matched as normal, but only if it is a node from the input program tree. GreenGrass restricts the search to not match the node if it was produced by an earlier iteration of the replace algorithm. The specific rules for GreenGrass are as follows:
- During the first search in any SearchReplace, ComapreReplace or slave, the GreenGrass node does not restrict at all
- During sucessive passes, GreenGrass restricts to nodes that reached the program tree via Stuff node substitution. Note this includes the portion outside of the match when SearchReplace is used (see the implementation note by CompareReplace).
- In cases where one pass creates a new node (that GreenGrass would reject) and then a later pass preserves it via Stuff node substituttion, GreenGrass will still reject it.

Broadly speaking, GreenGrass assumes that Stuff substitution is not really changing the nodes, just moving them around. It filters to nodes from the original input tree that may be been moved around. 

Note: arguably, there should always be a way of ensuring termination that does not require GreenGrass, so I suggest considering alternatives first.

12 Worked examples

A small example, two medium examples and one large one follow. 

12.1 removing Nop

CleanupNop uses SearchReplace to eliminate obviously redundant Nops from code. Nop is a do-nothing statement rather like NOP instrucitons in assembly language (except it is not intended to consume processor cycles). The search pattern is a Compound statement with a Star<Declaration> node in the decls. The sequence of statements in the Compound block (an ordered container) contain the following: Star<Statement>, Nop, Star<Statement>. All the Star nodes have no pre-restriction and are maximally wild, so they'll match anything (legal). 

Our search can therefore match a Compound block with any decls, and any statements as long as there is at least one Nop (this transformation only deals with Nops in Compound blocks). The Nop can be anywhere in the sequence of statements: the layout of Star, X, Star resembles *X* in filename globbing.

For replacing, we wish to preserve everything in the compound block except the Nop. And we wish to preserve th statements in the correct order. We  supply a new Compound block in the replace pattern, and fill in its declarations and statements by pointing to the same Star nodes we created in the search pattern. Thus the Star nodes have two parent nodes, and are coupled. The effect of coupling the star nodes is to reproduce whatever they matched (which could be 0 or mode nodes of the appropriate type, complete with any subtrees) in the output program at that position. The two Star<Statement> nodes appear as two statements in sequence under the replace Comound - this ensures that the statements we wish to retain appear in the correct order.

The pattern is strictly reductive: each hit will reduce the number of Nop statements by one, and the transformation will terminate when the program contains no Nop statements. The repeating nature of the Inferno S&R algorithm means we will keep trying until we don't get any hits. This means that a compound block containing many Nop statements will be correctly transformed after multiple hits. On each hit, the Star<Statement> nodes will match different subsequences of the statements in the compound block. For this step (and I believe in general) it does not matter whether the first Nop matched is the one at the top, or bottom or middle of the block.

12.2 Generate implicit casts

12.3 For to While

ForToWhile transforms For loops into semantically equivalent While loops. C makes this easy and hard. Easy because the three elements of a For loop are general C constructs that can simply be moved to the appropriate places in the While loop, and hard because of Break and Continue. We do not have to worry about Break here because it has already been handled by another step, but Contiune requires explicit treatment (Continue works in While loops, but has the wrong semantics: the increment would be skipped).

Our master search pattern describes a general For loop. There is a For node, and its expression (the test) is filled in with an Expression node which is a maximal wildcard that will match any expression. Its init condition, increment and body are all maximally wild Statement nodes. Therefore, any For loop will match (Inferno fills absent statements with Nop, which will match).

The master replace pattern begins with a Compound node. This is there to make the pattern simpler, and there are clean-up steps that remove them where they are redundant. It is generally an encouraged style. The compound has only 2 statements: the init statement from the For loop via a coupling, followed by a While node. The While loop's test expression is coupled in from the For loop's test expression. In the body of the While loop we place the For loop body (but see below) followed by the increment from the For loop. This completes the basic transformation - by inspection, you can determine that the constructs from the For loop are in the right places. Again, wheras the two Compound blocks may not be needed in all cases, we create them for convenience and expect cleanup steps to remove them later if possible.

In order to deal with Continue, we insert a SlaveCompareReplace into the master replace pattern, just above where we couple the body of the For loop. Recall that the trhough member is simply there to allow the master replace pattern to continue. During each master replace (in other words, as S&R is building the While loop) the slave will act on the replaced version of the subtree under the through link. This is the body of the original For loop (via coupling).

In this body, we wish to change the behaviour of Continue: we wish to insert a copy of the increment statement just before each continue, to compensate for continue skipping the increment we placed at the end of the body. The positioning of the slave ensures we do not change continues outside of For loops. Were it not for two awkward issues, we would simply use SlaveSearchReplace, search for continue and replace with a compound containing the increment condition (coupled) followed by continue. This is indeed approximately how the slave is laid out, but there are extra nodes to solve the problems:

1. The slave replace pattern contains continue, so the slave would not terminate. We want each continue in the input program (under a For) to be replaced exactly once by the compound of increment and continue. More or fewer replacements would increment too many or too few times. The GreenGrass node ensures we only replace continues that were in the input tree, and not ones that came from our replace pattern.

2. Not all continue statements under a For loop apply to that loop, because there could be nested loops (see the C spec). We cannot just use a SlaveSearchReplace because it would find continues that we don't want to change. The actual pattern used is a stuff node, which can recurse to find a continue (continue is the terminus, via the Overlay node), and it has a recurse restriction filled in with NotMatch and a Loop wildcard. This part of the pattern means "not any kind of Loop" and the Stuff node will therefore not recurse through any loops as it looks for a terminus match. Stuff is followed by an Overlay node, which allows the new Compound to be overlayed over the original Continue.

Note that the SlaveCompareReplace(Stuff(Overlay)) pattern resembles the pattern that SearchReplace generates to emulate search and replace using the CompareRepalce implementation. The difference here is that we needed to add a recurse restriction, and so we wrote that pattern out long-hand. If there was no need for a recurse restriction, we would use SlaveSearchReplace and get a more readable pattern.

Note also that we see a three-way coupling around the Statement node that represents the For loop's increment statement. This works just fine, Inferno is cool about that sort of thing.

12.4 generate stacks

13 Notes on pattern building in C++
13.1 What you need to do
13.2 Helpful syntactic sugar
13.3 Style tips

