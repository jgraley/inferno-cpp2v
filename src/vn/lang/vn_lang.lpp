
%top{
#include "vn_lang.ypp.hpp"       /* Generated by bison. */
#include "vn_lang.location.hpp"  /* Generated by bison %locations. */
#include "vn_shim.hpp"
}

%class{
}

%option bison-complete
%option bison-cc-namespace=YY
%option bison-cc-parser=VNLangParser 
%option bison-locations

/* throw an exception in the scanner's default rule */
%option exception="YY::VNLangParser::syntax_error(location(), \"Not recognised as part of Vida Nova language.\")"

// Renderer uses tabs (see Indenter::GetString()).
// Add `tabs -4` to your .bashrc to make error messages line up.
%option tabs=4

%option namespace=YY
%option lexer=VNLangScanner
%option fast
%option unicode
%option freespace

%class{
	VN::VNLangRecogniser const *recogniser;
}
%option ctorarg="VN::VNLangRecogniser *shim_"
%option ctorinit="recogniser( shim_ )"

// ASCII must come before unicode otherwise they'd all lex as unicode.
ascii_name				[a-zA-Z_][a-zA-Z0-9_]*
unicode_name			\p{UnicodeIdentifierStart} \p{UnicodeIdentifierPart}*
float_exp_suffix		[Ee] [-+]? \d+
float_num				\d* (\d | \.\d | \d\.) \d* {float_exp_suffix}?
integral_num			\d*[lLuU]*
comp_assign				\|=|^=|&=|<<=|>>=|\+=|-=|\*=|\/=|%=

%%

\s          	// ignore space
‚™Æ				{ return YY::VNLangParser::make_DESIGNATE(location()); };
‚®ü				{ return YY::VNLangParser::make_VN_SEMI(location()); };
‚ö¨				{ return YY::VNLangParser::make_VN_SEP(location()); };
Í©ú				{ return YY::VNLangParser::make_ENGINE(location()); };
‚©®				{ return YY::VNLangParser::make_STUFF(location()); };
‚ñ≤				{ return YY::VNLangParser::make_DELTA(location()); };
‚Øà				{ return YY::VNLangParser::make_DELTA_ARROW(location()); };
‚óº				{ return YY::VNLangParser::make_BUILT_IN(location()); };
‚ØÅ				{ return YY::VNLangParser::make_BUILT_IN_TYPE(location()); };
üûä				{ return YY::VNLangParser::make_SPECIFIC_ID(location()); };
„Äê				{ return YY::VNLangParser::make_OPEN_VN(location()); };
„Äë				{ return YY::VNLangParser::make_CLOSE_VN(location()); };
‚òÜ				{ return YY::VNLangParser::make_ANY(location()); };
‚òÖ				{ return YY::VNLangParser::make_STAR(location()); };
‚äõ				{ return YY::VNLangParser::make_ID_BY_NAME(location()); };
‚ßá				{ return YY::VNLangParser::make_BUILD_ID(location()); };
„Ää				{ return YY::VNLangParser::make_OPEN_CHEVRON(location()); };
„Äã				{ return YY::VNLangParser::make_CLOSE_CHEVRON(location()); };
‚§®				{ return YY::VNLangParser::make_TRANSFORM(location()); };
¬¨				{ return YY::VNLangParser::make_NEGATION(location()); };
‚àß				{ return YY::VNLangParser::make_CONJUNCTION(location()); };
‚à®				{ return YY::VNLangParser::make_DISJUNCTION(location()); };
‚´¥				{ return YY::VNLangParser::make_GRASS(location()); };
‚Æé				{ return YY::VNLangParser::make_POINTER_IS(location()); };
üÑΩ				{ return YY::VNLangParser::make_BUILD_SIZE(location()); };
¬ß				{ return YY::VNLangParser::make_STRINGIZE(location()); };
‚ÄΩ 				{ return YY::VNLangParser::make_PRERESTRICT(location()); };

// Multi-character before single-character
==|!=			{ return YY::VNLangParser::make_C_EQUALITY_OP(str(), location()); }
<|<=|>|>=		{ return YY::VNLangParser::make_C_RELATIONAL_OP(str(), location()); }
{comp_assign} 	{ return YY::VNLangParser::make_C_COMPOUND_ASSIGN(str(), location()); }
\|\|		  	{ return YY::VNLangParser::make_C_LOGICAL_OR_OP(str(), location()); }
&&			  	{ return YY::VNLangParser::make_C_LOGICAL_AND_OP(str(), location()); }
<<|>>		  	{ return YY::VNLangParser::make_C_SHIFT_OP(str(), location()); }

!|~				{ return YY::VNLangParser::make_C_PREFIX_OP(str(), location()); };
\+\+|--			{ return YY::VNLangParser::make_C_PRE_OR_POSTFIX_OP(str(), location()); };
=			  	{ return YY::VNLangParser::make_C_ASSIGN(str(), location()); }
-|\+		  	{ return YY::VNLangParser::make_C_ADD_SUB_OP(str(), location()); }
\/|%		  	{ return YY::VNLangParser::make_C_DIV_MOD_OP(str(), location()); }
&				{ return YY::VNLangParser::make_C_AMPERSAND(str(), location()); }
\|				{ return YY::VNLangParser::make_C_BITWISE_OR_OP(str(), location()); }
\^				{ return YY::VNLangParser::make_C_BITWISE_XOR_OP(str(), location()); }
\*				{ return YY::VNLangParser::make_C_STAR(str(), location()); }
,				{ return YY::VNLangParser::make_COMMA(str(), location()); }

true			{ return YY::VNLangParser::make_BOOL_LITERAL(true, location()); };
false			{ return YY::VNLangParser::make_BOOL_LITERAL(false, location()); };
typename		{ return YY::VNLangParser::make_TYPENAME(str(), location()); };

::				{ return YY::VNLangParser::make_SCOPE_RES(location()); };

[()\{\};,]		{ return YY::VNLangParser::symbol_type(chr(), location()); }

\"[^"]*\"   	{ return YY::VNLangParser::make_STRING_LITERAL(wstr(), location()); }
{integral_num}	{ return YY::VNLangParser::make_INTEGRAL_LITERAL(str(), location()); }
{ascii_name}	{ return recogniser->OnUnquoted(str(), location()); }
{unicode_name}	{ return recogniser->OnUnquoted(wstr(), location()); }

%%
