
%top{
#include "vn_lang.ypp.hpp"       /* Generated by bison. */
#include "vn_lang.location.hpp"  /* Generated by bison %locations. */
}

%class{
}

%option bison-complete
%option bison-cc-namespace=YY
%option bison-cc-parser=VNLangParser 
%option bison-locations

/* throw an exception in the scanner's default rule */
%option exception="YY::VNLangParser::syntax_error(location(), \"Not recognised as part of Vida Nova language.\")"

// Renderer uses tabs (see Indenter::GetString()).
// Add `tabs -4` to your .bashrc to make error messages line up.
%option tabs=4

%option namespace=YY
%option lexer=VNLangScanner
%option fast
%option unicode
%option freespace

// ASCII must come before unicode otherwise they'd all lex as unicode.
ascii_name				[a-zA-Z_][a-zA-Z0-9_]*
ascii_format			[a-zA-Z_%][a-zA-Z0-9_%]*

// We have to exclude delta from identifiers here, otherwise "match longest"
// rule means eg ‚ñ≤d is parsed as a name. TODO ‚ñ≤ should be a keyword, see #866
unicode_name			\p{UnicodeIdentifierStart} \p{UnicodeIdentifierPart}*
float_exp_suffix		[Ee] [-+]? \d+
float_num				\d* (\d | \.\d | \d\.) \d* {float_exp_suffix}?
integral_num			\d*[lLuU]*

%%

\s          	// ignore space
‚™Æ				{ return YY::VNLangParser::make_DESIGNATE(location()); };
‚®ü				{ return YY::VNLangParser::make_VN_SEMI(location()); };
‚ö¨				{ return YY::VNLangParser::make_VN_SEP(location()); };
Í©ú				{ return YY::VNLangParser::make_ENGINE(location()); };
‚©®				{ return YY::VNLangParser::make_STUFF(location()); };
‚ñ≤				{ return YY::VNLangParser::make_DELTA(location()); };
‚Øà				{ return YY::VNLangParser::make_DELTA_ARROW(location()); };
‚ØÅ				{ return YY::VNLangParser::make_BUILT_IN(location()); };
üûä				{ return YY::VNLangParser::make_SPECIFIC_ID(location()); };
„Äê				{ return YY::VNLangParser::make_OPEN_RESTRICT(location()); };
„Äë				{ return YY::VNLangParser::make_CLOSE_RESTRICT(location()); };
‚òÜ				{ return YY::VNLangParser::make_ANY(location()); };
‚òÖ				{ return YY::VNLangParser::make_STAR(location()); };
‚äõ				{ return YY::VNLangParser::make_ID_BY_NAME(location()); };
‚ßá				{ return YY::VNLangParser::make_BUILD_ID(location()); };
„Ää				{ return YY::VNLangParser::make_OPEN_CHEVRON(location()); };
„Äã				{ return YY::VNLangParser::make_CLOSE_CHEVRON(location()); };
‚§®				{ return YY::VNLangParser::make_TRANSFORM(location()); };
¬¨				{ return YY::VNLangParser::make_NEGATION(location()); };
‚àß				{ return YY::VNLangParser::make_CONJUNCTION(location()); };
‚à®				{ return YY::VNLangParser::make_DISJUNCTION(location()); };
‚´¥				{ return YY::VNLangParser::make_GRASS(location()); };
‚Æé				{ return YY::VNLangParser::make_POINTER_IS(location()); };
üÑΩ				{ return YY::VNLangParser::make_BUILD_SIZE(location()); };
¬ß				{ return YY::VNLangParser::make_STRINGIZE(location()); };

true			{ return YY::VNLangParser::make_BOOL_LITERAL(true, location()); };
false			{ return YY::VNLangParser::make_BOOL_LITERAL(false, location()); };

::				{ return YY::VNLangParser::make_SCOPE_RES(location()); };
[-+*/=();,]  	{ return YY::VNLangParser::symbol_type(chr(), location()); }

\"[^"]*\"   	{ return YY::VNLangParser::make_STRING_LITERAL(wstr(), location()); }
{integral_num}	{ return YY::VNLangParser::make_INTEGRAL_LITERAL(str(), location()); }
{ascii_name}	{ return YY::VNLangParser::make_ASCII_NAME(str(), location()); }
{ascii_format}	{ return YY::VNLangParser::make_ASCII_FORMAT(str(), location()); }
{unicode_name}	{ return YY::VNLangParser::make_UNICODE_NAME(wstr(), location()); }

%%
