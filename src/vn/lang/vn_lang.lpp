
%top{
#include "vn_lang.ypp.hpp"       /* Generated by bison. */
#include "vn_lang.location.hpp"  /* Generated by bison %locations. */
}

%class{
 public:
  std::map<std::wstring,double> map;
}

%option bison-complete
%option bison-cc-namespace=YY
%option bison-cc-parser=VNLangParser 
%option bison-locations

/* throw an exception in the scanner's default rule */
%option exception="YY::VNLangParser::syntax_error(location(), \"Unknown token.\")"

%option tabs=4

%option namespace=YY
%option lexer=VNLangScanner
%option fast
%option unicode
%option freespace

// We have to exclude delta from identifiers here, otherwise "match longest"
// rule means eg Î”d is parsed as a name.
name    [\p{UnicodeIdentifierStart}]{-}[Î”] [\p{UnicodeIdentifierPart}{-}[Î”]]*
exp     [Ee] [-+]? \d+
num     \d* (\d | \.\d | \d\.) \d* {exp}?

%%

\s          // ignore space
\"[^"]*\"   { return YY::VNLangParser::make_STR(wstr(), location()); }
{num}       { return YY::VNLangParser::make_NUM(strtod(text(), NULL), location()); }
{name}      { return YY::VNLangParser::make_VAR(wstr(), location()); }
[-+*/=();]  { return YY::VNLangParser::symbol_type(chr(), location()); }
ê©œ			{ return YY::VNLangParser::make_ENGINE(location()); };
â©¨			{ return YY::VNLangParser::make_STUFF(location()); };
Î”			{ return YY::VNLangParser::make_DELTA(location()); };
ðŸ¡º			{ return YY::VNLangParser::make_DELTA_ARROW(location()); };
<<EOF>>     { return YY::VNLangParser::make_EOF(location()); }

%%
