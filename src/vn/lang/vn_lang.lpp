
%top{
#include "vn_lang.ypp.hpp"       /* Generated by bison. */
#include "vn_lang.location.hpp"  /* Generated by bison %locations. */
}

%class{
}

%option bison-complete
%option bison-cc-namespace=YY
%option bison-cc-parser=VNLangParser 
%option bison-locations

/* throw an exception in the scanner's default rule */
%option exception="YY::VNLangParser::syntax_error(location(), \"Not recognised as part of Vida Nova language.\")"

%option tabs=4

%option namespace=YY
%option lexer=VNLangScanner
%option fast
%option unicode
%option freespace

// ASCII must come before unicode otherwise they'd all lex as unicode.
ascii_name				[a-zA-Z_][a-zA-Z0-9_]*
ascii_format			[a-zA-Z_%][a-zA-Z0-9_%]*

// We have to exclude delta from identifiers here, otherwise "match longest"
// rule means eg ▲d is parsed as a name. TODO ▲ should be a keyword, see #866
unicode_name			\p{UnicodeIdentifierStart} \p{UnicodeIdentifierPart}*
float_exp_suffix		[Ee] [-+]? \d+
float_num				\d* (\d | \.\d | \d\.) \d* {float_exp_suffix}?
integral_num			\d*

%%

\s          	// ignore space
⪮				{ return YY::VNLangParser::make_DESIGNATE(location()); };
⨟				{ return YY::VNLangParser::make_VN_SEMI(location()); };
⚬				{ return YY::VNLangParser::make_VN_SEP(location()); };
꩜				{ return YY::VNLangParser::make_ENGINE(location()); };
⩨				{ return YY::VNLangParser::make_STUFF(location()); };
▲				{ return YY::VNLangParser::make_DELTA(location()); };
⯈				{ return YY::VNLangParser::make_DELTA_ARROW(location()); };
⯁				{ return YY::VNLangParser::make_BUILT_IN(location()); };
【				{ return YY::VNLangParser::make_OPEN_RESTRICT(location()); };
】				{ return YY::VNLangParser::make_CLOSE_RESTRICT(location()); };
☆				{ return YY::VNLangParser::make_ANY(location()); };
★				{ return YY::VNLangParser::make_STAR(location()); };
⊛				{ return YY::VNLangParser::make_ID_BY_NAME(location()); };
⧇				{ return YY::VNLangParser::make_BUILD_ID(location()); };
《				{ return YY::VNLangParser::make_OPEN_CHEVRON(location()); };
》				{ return YY::VNLangParser::make_CLOSE_CHEVRON(location()); };
⤨				{ return YY::VNLangParser::make_TRANSFORM(location()); };
¬				{ return YY::VNLangParser::make_NEGATION(location()); };
∧				{ return YY::VNLangParser::make_CONJUNCTION(location()); };
∨				{ return YY::VNLangParser::make_DISJUNCTION(location()); };

::				{ return YY::VNLangParser::make_SCOPE_RES(location()); };
[-+*/=();,]  	{ return YY::VNLangParser::symbol_type(chr(), location()); }

\"[^"]*\"   	{ return YY::VNLangParser::make_STR(wstr(), location()); }
{integral_num}	{ return YY::VNLangParser::make_NUM(strtod(text(), NULL), location()); }
{ascii_name}	{ return YY::VNLangParser::make_ASCII_NAME(str(), location()); }
{ascii_format}	{ return YY::VNLangParser::make_ASCII_FORMAT(str(), location()); }
{unicode_name}	{ return YY::VNLangParser::make_UNICODE_NAME(wstr(), location()); }

%%
