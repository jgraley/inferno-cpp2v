%require "3.2"

%language "c++"
%define api.namespace {YY}
%define api.parser.class {VNLangParser}
%define api.value.type variant
%define api.token.constructor

%define parse.error verbose

%defines

%locations
%define api.location.file "vn_lang.location.hpp"

%code requires {
  namespace YY {
    class VNLangScanner;
  };
  #include "vn_parse.hpp"
  #include "vn_commands.hpp"
}

%code { 
  #include "vn_lang.lpp.hpp"  /* Generated by reflex. */
  #include <iostream>
  #include <fstream>
  #include <locale>  
  #include <codecvt>
  #undef yylex
  #define yylex lexer.lex  /* Within bison's parse() we should invoke lexer.lex(), not the global yylex() */
}

%parse-param { YY::VNLangScanner& lexer }
%parse-param { VN::VNParse *vn }

%define api.token.prefix {TOK_}

%token DESIGNATE;
%token VN_SEMI;
%token '+';
%token '-';
%token '*';
%token '/';
%token '=';
%token '(';
%token ')';
%token ';';
%token SCOPE_RES;
%token ENGINE;
%token STUFF;
%token DELTA;
%token DELTA_ARROW;
%token BUILT_IN;
%token OPEN_RESTRICT;
%token CLOSE_RESTRICT;

%token <std::wstring> 	STR 					"string";
%token <double>       	NUM 					"number";
%token <std::string>  	ASCII_NAME 				"ASCII name"
%token <std::wstring> 	UNICODE_NAME 			"Unicode name";
%token EOF            	0   					"end of file";

%right '='
%left  '+' '-'
%left  '*' '/'
%right PREFIX

%type <VN::Production> 							pattern
%type <std::wstring> 							vn_name
%type <std::list<std::string>> 					scoped_name
%type <VN::Command::List>						commands
%type <std::shared_ptr<VN::Command>>			command
%type <std::shared_ptr<VN::Command>>			weak_command
%type <VN::Itemisation>				itemisation
%type <VN::Itemisation>				items
%type <VN::Item>					item

%%

vnscript 	: commands 									{ vn->OnVNScript($1); }
     
// "Viral" grammar - if there's one command within a sequence separated by â¨Ÿ
// then this "spreads" and they all become commands. In some sense this associates
// "toward" the known command.
commands 	: commands VN_SEMI weak_command 			{ $$ = $1; if( $3->OnParse(vn) ) $$.push_back($3); }
			| weak_command VN_SEMI commands 			{ $$ = $3; if( $1->OnParse(vn) ) $$.push_front($1); }
			| command									{ if( $1->OnParse(vn) ) $$.push_back($1); }
		
weak_command	: command								{ $$ = $1; }
				| pattern                               { $$ = std::make_shared<VN::PatternCommand>($1); }
			
// Add more commands here
command	: vn_name DESIGNATE pattern						{ $$ = std::make_shared<VN::Designation>($1, $3); }
		| ENGINE %prec PREFIX pattern 		   		  	{ $$ = make_shared<VN::EngineCommand>($2); }
             
pattern	: pattern '+' pattern      { $$ = $1; }
		| pattern '-' pattern      { $$ = $1; }
		| pattern '*' pattern      { $$ = $1; }
		| pattern '/' pattern      { $$ = $1; }
		| STUFF %prec PREFIX pattern 		     		 	{ $$ = vn->OnStuff($2); }
		| DELTA pattern DELTA_ARROW pattern   		   		{ $$ = vn->OnDelta($2, $4); }
		| BUILT_IN scoped_name itemisation					{ $$ = vn->OnBuiltIn($2, @2, $3); }
		| '-' %prec PREFIX pattern                 			{ $$ = vn->OnPrefixOperator("-", $2); }
		| '(' commands ')'                          		{ $$ = vn->OnEmbeddedCommands($2); }
		| '(' pattern ')'                          			{ $$ = $2; }
		| OPEN_RESTRICT scoped_name CLOSE_RESTRICT pattern 	{ $$ = vn->OnRestrict($2, @2, $4, @4); }
		| vn_name       						  			{ $$ = vn->OnName($1, @1); }
		| NUM       						      			{ $$ = vn->OnSpecificInteger($1); }
		;

itemisation : '(' items ')'    							{ $$ = $2; }
			| '(' ')'									{ $$ = VN::Itemisation{}; $$.loc = @$; }
  
items     	: items VN_SEMI item   						{ $$ = $1; $$.items.push_back($3); $$.loc = @$; }
			| item										{ $$.items.push_back($1); $$.loc = @$; }

item		: item ',' pattern    						{ $$ = $1; $$.nodes.push_back($3); $$.loc = @$; }
			| pattern									{ $$.nodes.push_back($1); $$.loc = @$; }

vn_name			: UNICODE_NAME    						{ $$ = $1; }
				| ASCII_NAME							{ $$ = std::wstring_convert<std::codecvt_utf8<wchar_t>>().from_bytes($1); }     
     
scoped_name		: ASCII_NAME SCOPE_RES scoped_name		{ $$ = $3; $$.push_front($1); }
				| ASCII_NAME							{ $$.push_front($1); }

%%

void YY::VNLangParser::error(const location& loc, const std::string& msg)
{
  vn->OnError();
  std::cerr << loc << ": " << msg << std::endl;
  if (loc.begin.line == loc.end.line && loc.begin.line == lexer.lineno())
  {
    std::cerr << lexer.matcher().line() << std::endl;
    for (size_t i = 1; i < loc.begin.column; ++i)
      std::cerr << " ";
    for (size_t i = loc.begin.column; i < loc.end.column; ++i)
      std::cerr << "~";
    std::cerr << std::endl;
  }
  else
  {
    FILE *file = lexer.in().file(); // the current file being scanned
    if (file != NULL)
    {
      YY::VNLangScanner::Matcher *m = lexer.new_matcher(file); // new matcher
      lexer.push_matcher(m); // save the current matcher
      off_t pos = ftell(file); // save current position in the file
      fseek(file, 0, SEEK_SET); // go to the start of the file
      for (size_t i = 1; i < loc.begin.line; ++i)
        m->skip('\n'); // skip to the next line
      for (size_t i = loc.begin.line; i <= loc.end.line; ++i)
      {
        std::cerr << m->line() << std::endl; // display the offending line
        m->skip('\n'); // next line
      }
      fseek(file, pos, SEEK_SET); // restore position in the file to continue scanning
      lexer.pop_matcher(); // restore matcher
    }
  }
  if (lexer.size() == 0) // if token is unknown (no match)
    lexer.matcher().winput(); // skip character
}
