%require "3.2"

%language "c++"
%define api.namespace {YY}
%define api.parser.class {VNLangParser}
%define api.value.type variant
%define api.token.constructor
%define parse.error detailed
// Inadequacy Elimination LR
%define lr.type ielr
// Lookahead Correction
%define parse.lac full

%defines

%locations
%define api.location.file "vn_lang.location.hpp"

%code requires {
  // Appears high-ish in the generated .hpp file
  #include "vn_parse.hpp" // TODO we actually only need Item and Itemisation from here
  #include "node/tree_ptr.hpp"
  #include "tree/node_names.hpp"
  #include <string>
  namespace YY {
    class VNLangScanner;  
  	struct NameInfo
	{
		TreePtr<Node> as_designated;
		string as_ascii;
		wstring as_unicode;
		list<string> as_name_res_list;
		const NodeNameBlock *as_node_name_block;
	};     	
  };
  // Things we point to from semantic values
  namespace VN { 
    class Command;
    class Gnomon;
  }
}

%code { 
  // Appears high-ish in the generated .cpp file
  #include "vn_lang.lpp.hpp"  /* Generated by reflex. */
  #include <iostream>
  #include <fstream>
  #include "vn_commands.hpp"
  #undef yylex
  #define yylex lexer.lex  /* Within bison's parse() we should invoke lexer.lex(), not the global yylex() */
  
  // Strings that could be translated have _() around them. 
  // See https://www.gnu.org/software/gettext/manual/gettext.html
  #define _(String) (String)
  #define N_(String) String 
}

%parse-param { YY::VNLangScanner& lexer }
%parse-param { VN::VNParse *vn }
%parse-param { VN::VNShim *shim }

%define api.token.prefix {TOK_}

%token
	DESIGNATE 								"‚™Æ"
	VN_SEMI 								"‚®ü"
	VN_SEP 									"‚ö¨"
	'('
	')'
	';'
	SCOPE_RES 								"::"
	ENGINE	 								"Í©ú"
	STUFF		 							"‚©®"
	DELTA 									"‚ñ≤"
	DELTA_ARROW 							"‚Øà"
	BUILT_IN 								"‚óº"
	BUILT_IN_TYPE							"‚ØÅ"
	OPEN_VN 								"„Äê"
	CLOSE_VN 								"„Äë"
	ANY 									"‚òÜ"
	STAR 									"‚òÖ"
	ID_BY_NAME								"‚äõ"
	SPECIFIC_ID								"üûä"
	BUILD_ID								"‚ßá"
	OPEN_CHEVRON							"„Ää"
	CLOSE_CHEVRON							"„Äã"
	TRANSFORM								"‚§®"
	NEGATION								"¬¨"
	CONJUNCTION								"‚àß"
	DISJUNCTION								"‚à®"
	GRASS									"‚´¥"
	POINTER_IS								"‚Æé"
	BUILD_SIZE								"üÑΩ"
	STRINGIZE								"¬ß"
	PRERESTRICT								"‚ÄΩ"
	<string>	COMMA						_("comma")
	<string>	C_ASSIGN					"="
	<string>	C_COMPOUND_ASSIGN			_("C compound assignment operator")
	<string>	C_LOGICAL_OR_OP				"||"			
	<string>	C_LOGICAL_AND_OP			"&&"			
	<string>	C_BITWISE_OR_OP				"|"
	<string>	C_BITWISE_XOR_OP			"^"
	<string>	C_AMPERSAND					"&"
	<string>	C_EQUALITY_OP				_("C equality operator")
	<string>  	C_RELATIONAL_OP				_("C relation operator")
	<string>	C_SHIFT_OP					_("C shift operator")
	<string>	C_ADD_SUB_OP				_("C add/subtract")
	<string>    C_DIV_MOD_OP				_("C divide/modulo")
	<string> 	C_STAR						"*"
	<string>  	C_PREFIX_OP					_("C prefix operator")
	<string>	C_PRE_OR_INFIX_OP			_("C prefix/infix operator")
	<string>    C_PRE_OR_POSTFIX_OP 		_("C prefix/postfix operator")
	<wstring> 	STRING_LITERAL 				_("string")
	<string> 	INTEGRAL_LITERAL			_("integer literal")
	<bool>		BOOL_LITERAL				_("boolean literal")
	<YY::NameInfo>  	ASCII_NAME 					_("ASCII name")
	<string>  	ASCII_FORMAT 				_("ASCII format string")
	<YY::NameInfo> 	UNICODE_NAME 				_("Unicode name")
	<string>    TYPENAME					"typename"
	<YY::NameInfo> 	NAMED_SUBTREE			_("named subtree")
	<YY::NameInfo> RESOLVED_NAME			_("resolved name")
	
%type <TreePtr<Node>> 				expression expr_unit expr_postfix expr_prefix expr_relational expr_disjunction expr_conjunction type 
%type <TreePtr<Node>> 				expr_assignment expr_equality expr_add_etc expr_logical_or expr_logical_and statements statement
%type <TreePtr<Node>> 				expr_mul_etc expr_shift expr_bitwise_and expr_bitwise_or expr_bitwise_xor expr_no_comma_op 
%type <TreePtr<Node>> 				expr_paren expr_comma_op type_unit type_prefix type_paren
%type <wstring> 					vn_name
%type <YY::NameInfo> 				resolved_name
%type <list<shared_ptr<VN::Command>>>			commands sep_commands
%type <shared_ptr<VN::Command>>		bare_command
%type <VN::Limit>					limit
%type <VN::Itemisation>				itemisation items_bare items_sep
%type <VN::Item>					item
%type <shared_ptr<VN::Gnomon>>		part_resolve
%%

vnscript 		: commands 								{ vn->OnVNScript($1); }
     
// This is to make the ‚®ü optional on last command
commands        : sep_commands							{ $$ = $1; }
				| sep_commands VN_SEMI					{ $$ = $1; }
				
// The ‚®ü turns patterns into commands. This rule must 
// be left-associative so calls to OnParse() happen
// in the correct order. STOP BREAKING THIS!!!
sep_commands 	: sep_commands VN_SEMI bare_command		{ $$ = $1; if( $3->OnParse(vn) ) $$.push_back($3); }	
				| bare_command							{ if( $1->OnParse(vn) ) $$.push_back($1); }
			
// Add more commands here
bare_command	: vn_name DESIGNATE expression			{ $$ = make_shared<VN::Designation>($1, $3, @2); }
				| ENGINE expression   		 		 	{ $$ = make_shared<VN::EngineCommand>($2, @1); }
				| expression 			  				{ $$ = make_shared<VN::PatternCommand>($1, @$); }

// This one dips into ASCII/C because VN doesn't otherwise need equality/inequality operators
limit		: C_ASSIGN INTEGRAL_LITERAL					{ $$ = VN::Limit{ $1, @1, $2, @2 }; }

itemisation : '(' items_bare ')'    					{ $$ = $2; $$.loc = @$; }
			| '(' items_sep ')'	    					{ $$ = $2; $$.loc = @$; $$.items.push_back({{}, @3}); }
			| '(' ')'									{ $$.loc = @$; $$.items.push_back({{}, @2}); }
  
items_bare 	: items_sep item							{ $$ = $1; $$.items.push_back($2); }
			| item										{ $$.items.push_back($1); }

items_sep 	: items_bare VN_SEP		   					{ $$ = $1; } 
			| items_sep VN_SEP		 					{ $$ = $1; $$.items.push_back({{}, @2}); }
			| VN_SEP	 								{ $$.items.push_front({{}, @1}); }

item		: item COMMA expr_no_comma_op				{ $$ = $1; $$.nodes.push_back($3); $$.loc = @$; }
			| expr_no_comma_op							{ $$.nodes.push_back($1); $$.loc = @$; }


statements	: statement

statement	: expression
          
type		: type_prefix          
          
type_prefix : 										     type_paren
			|  									  STUFF type_prefix	 { $$ = vn->OnStuff($2, nullptr, VN::Limit()); }
			| 		  STUFF OPEN_VN expression CLOSE_VN type_prefix	 { $$ = vn->OnStuff($5, $3, VN::Limit()); }
			| 		  STUFF OPEN_VN limit      CLOSE_VN type_prefix	 { $$ = vn->OnStuff($5, nullptr, $3); }
			| 			   DELTA expression DELTA_ARROW type_prefix	 { $$ = vn->OnDelta($2, $4); }
			| PRERESTRICT OPEN_VN resolved_name CLOSE_VN type_prefix { $$ = vn->OnRestrict($3.as_name_res_list, @3, $5, @5); }
			| 	  TRANSFORM OPEN_VN ASCII_NAME CLOSE_VN type_prefix	 { $$ = vn->OnTransform($3.as_ascii, @3, $5, @5); }
			| 								   NEGATION type_prefix	 { $$ = vn->OnNegation($2); }
			| 									  GRASS type_prefix	 { $$ = vn->OnGrass($2); }
			| 								 POINTER_IS type_prefix	 { $$ = vn->OnPointerIs($2); }
			| 								 BUILD_SIZE type_prefix	 { $$ = vn->OnBuildSize($2); }
			| 								  STRINGIZE type_prefix	 { $$ = vn->OnStringize($2); }


type_paren	: type_unit
			| '(' type ')'                          	{ $$ = $2; } // TODO We're losing the ability to embed commands in a type
                                        
type_unit	: BUILT_IN_TYPE resolved_name itemisation		{ $$ = vn->OnBuiltIn($2.as_name_res_list, @2, $3); }
			| BUILT_IN_TYPE resolved_name					{ $$ = vn->OnBuiltIn($2.as_name_res_list, @2, VN::Itemisation{{}, @2}); }
			

                      
expression			: expr_comma_op
                      
expr_comma_op		: expr_no_comma_op
					| expr_no_comma_op COMMA expr_comma_op						{ $$ = vn->OnInfixOperator($2, $1, $3); }

expr_no_comma_op 	: expr_disjunction

expr_disjunction	: expr_conjunction
					| expr_disjunction DISJUNCTION expr_conjunction				{ $$ = vn->OnDisjunction($1, $3); }

expr_conjunction 	: expr_assignment
					| expr_conjunction CONJUNCTION expr_assignment				{ $$ = vn->OnConjunction($1, $3); }
		
expr_assignment 	: 											expr_logical_or 
					| 				   expr_logical_or C_ASSIGN expr_assignment	{ $$ = vn->OnInfixOperator($2, $1, $3); }
					|         expr_logical_or C_COMPOUND_ASSIGN expr_assignment	{ $$ = vn->OnInfixOperator($2, $1, $3); }

expr_logical_or 	: expr_logical_and
					| expr_logical_or C_LOGICAL_OR_OP expr_logical_and			{ $$ = vn->OnInfixOperator($2, $1, $3); }
		
expr_logical_and	: expr_bitwise_or
					| expr_logical_and C_LOGICAL_AND_OP expr_bitwise_or			{ $$ = vn->OnInfixOperator($2, $1, $3); }

expr_bitwise_or 	: expr_bitwise_xor
					| expr_bitwise_or C_BITWISE_OR_OP expr_bitwise_xor			{ $$ = vn->OnInfixOperator($2, $1, $3); }
		
expr_bitwise_xor	: expr_bitwise_and
					| expr_bitwise_xor C_BITWISE_XOR_OP expr_bitwise_and		{ $$ = vn->OnInfixOperator($2, $1, $3); }
		
expr_bitwise_and	: expr_equality
					| expr_bitwise_and C_AMPERSAND expr_equality				{ $$ = vn->OnInfixOperator($2, $1, $3); }

expr_equality 		: expr_relational
					| expr_equality C_EQUALITY_OP expr_relational				{ $$ = vn->OnInfixOperator($2, $1, $3); }

expr_relational 	: expr_shift
					| expr_relational C_RELATIONAL_OP expr_shift				{ $$ = vn->OnInfixOperator($2, $1, $3); }

expr_shift			: expr_add_etc
					| expr_shift C_SHIFT_OP expr_add_etc						{ $$ = vn->OnInfixOperator($2, $1, $3); }
		
expr_add_etc 		: expr_mul_etc
					| expr_add_etc C_ADD_SUB_OP expr_mul_etc					{ $$ = vn->OnInfixOperator($2, $1, $3); }
		
expr_mul_etc 		: expr_prefix
					| expr_mul_etc C_DIV_MOD_OP expr_prefix						{ $$ = vn->OnInfixOperator($2, $1, $3); }
					| expr_mul_etc '*' expr_prefix								{ $$ = vn->OnInfixOperator("*", $1, $3); }
		
expr_prefix : 										   expr_postfix
			|  									  STUFF expr_prefix	{ $$ = vn->OnStuff($2, nullptr, VN::Limit()); }
			| 		  STUFF OPEN_VN expression CLOSE_VN expr_prefix	{ $$ = vn->OnStuff($5, $3, VN::Limit()); }
			| 			 STUFF OPEN_VN limit   CLOSE_VN expr_prefix	{ $$ = vn->OnStuff($5, nullptr, $3); }
			| 			   DELTA expression DELTA_ARROW expr_prefix	{ $$ = vn->OnDelta($2, $4); }
			| 					    C_PREFIX_OP 		expr_prefix	{ $$ = vn->OnPrefixOperator($1, $2); }
			| 					    C_AMPERSAND 		expr_prefix	{ $$ = vn->OnPrefixOperator($1, $2); }
			| 					    C_STAR		 		expr_prefix	{ $$ = vn->OnPrefixOperator($1, $2); }
			| 					    C_ADD_SUB_OP	    expr_prefix	{ $$ = vn->OnPrefixOperator($1, $2); }
			| 					    C_PRE_OR_INFIX_OP   expr_prefix	{ $$ = vn->OnPrefixOperator($1, $2); }
			| 					    C_PRE_OR_POSTFIX_OP expr_prefix	{ $$ = vn->OnPrefixOperator($1, $2); }
			|							   '(' type ')' expr_prefix { $$ = vn->OnCast($2, @2, $4, @4); }
			|  PRERESTRICT OPEN_VN resolved_name CLOSE_VN expr_prefix	{ $$ = vn->OnRestrict($3.as_name_res_list, @3, $5, @5); }
			| 	  TRANSFORM OPEN_VN ASCII_NAME CLOSE_VN expr_prefix	{ $$ = vn->OnTransform($3.as_ascii, @3, $5, @5); }
			| 								   NEGATION expr_prefix	{ $$ = vn->OnNegation($2); }
			| 									  GRASS expr_prefix	{ $$ = vn->OnGrass($2); }
			| 								 POINTER_IS expr_prefix	{ $$ = vn->OnPointerIs($2); }
			| 								 BUILD_SIZE expr_prefix	{ $$ = vn->OnBuildSize($2); }
			| 								  STRINGIZE expr_prefix	{ $$ = vn->OnStringize($2); }

expr_postfix: expr_paren     
			| expr_postfix C_PRE_OR_POSTFIX_OP 				 	{ $$ = vn->OnPostfixOperator($2, $1); }
		
expr_paren	: expr_unit
			| '(' commands ')'                          		{ $$ = vn->OnEmbeddedCommands($2); }

expr_unit	: BUILT_IN resolved_name itemisation					{ $$ = vn->OnBuiltIn($2.as_name_res_list, @2, $3); }
			| BUILT_IN resolved_name								{ $$ = vn->OnBuiltIn($2.as_name_res_list, @2, VN::Itemisation{{}, @2}); }
			| STAR												{ $$ = vn->OnStar(nullptr); }
			| STAR OPEN_VN expression CLOSE_VN					{ $$ = vn->OnStar($3); }
			| INTEGRAL_LITERAL					      			{ $$ = vn->OnIntegralLiteral($1, @1); }
			| STRING_LITERAL					      			{ $$ = vn->OnStringLiteral($1); }
			| BOOL_LITERAL										{ $$ = vn->OnBoolLiteral($1); }
			| ANY												{ $$ = nullptr; }
			| '{' statements '}'                          		{ $$ = $2; }
			| NAMED_SUBTREE       					  			{ $$ = $1.as_designated; }
			| SPECIFIC_ID OPEN_VN resolved_name VN_SEP STRING_LITERAL CLOSE_VN			{ $$ = vn->OnSpecificId($3.as_name_res_list, @3, $5, @5); }
			| SPECIFIC_ID OPEN_VN resolved_name VN_SEP CLOSE_VN							{ $$ = vn->OnSpecificId($3.as_name_res_list, @3, wstring(), @5); }
			| ID_BY_NAME OPEN_VN resolved_name VN_SEP STRING_LITERAL CLOSE_VN			{ $$ = vn->OnIdByName($3.as_name_res_list, @3, $5, @5); } // ASCII_NAME could be format
			| BUILD_ID OPEN_VN resolved_name VN_SEP STRING_LITERAL VN_SEP CLOSE_VN 		{ $$ = vn->OnBuildId($3.as_name_res_list, @3, $5, @5, VN::Item{}); }
			| BUILD_ID OPEN_VN resolved_name VN_SEP STRING_LITERAL VN_SEP item CLOSE_VN	{ $$ = vn->OnBuildId($3.as_name_res_list, @3, $5, @5, $7); }
			| BUILD_ID OPEN_VN resolved_name VN_SEP VN_SEP item CLOSE_VN 				{ $$ = vn->OnBuildId($3.as_name_res_list, @3, wstring(), @5, $6); }

vn_name		: UNICODE_NAME    							{ $$ = $1.as_unicode; }
			| ASCII_NAME								{ $$ = $1.as_unicode; }     
          
// On sight of ::, we inform the naming layer, which returns a shared_ptr which will 
// expire when the production is complete or an error forces unwind. The naming layer
// keeps weak_ptrs to these and will send us RESOLVED_NAME if one exists.
part_resolve	: resolved_name SCOPE_RES				{ $$ = shim->PushScopeRes($1); }
    
// RESOLVED_NAME is strong i.e. there was definitely a ::. resolved_name is weak and
// doesn't require this. See comment by part_resolve for why we don't need a value from it.
resolved_name	: part_resolve RESOLVED_NAME			{ $$ = $2; }
				| ASCII_NAME							{ $$ = $1; }

%%
