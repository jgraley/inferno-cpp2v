%require "3.2"

%language "c++"
%define api.namespace {YY}
%define api.parser.class {VNLangParser}
%define api.value.type variant
%define api.token.constructor
%define parse.error detailed
%define parse.lac full

%defines

%locations
%define api.location.file "vn_lang.location.hpp"

%code requires {
  namespace YY {
    class VNLangScanner;
  };
  #include "vn_parse.hpp"
  #include "vn_commands.hpp"
}

%code { 
  #include "vn_lang.lpp.hpp"  /* Generated by reflex. */
  #include <iostream>
  #include <fstream>
  #undef yylex
  #define yylex lexer.lex  /* Within bison's parse() we should invoke lexer.lex(), not the global yylex() */
  
  // Strings that could be translated have _() around them. 
  // See https://www.gnu.org/software/gettext/manual/gettext.html
  #define _(String) (String)
  #define N_(String) String
}

%parse-param { YY::VNLangScanner& lexer }
%parse-param { VN::VNParse *vn }

%define api.token.prefix {TOK_}

// The order seems to matter here, find out why TODO
%token
	DESIGNATE 								"‚™Æ"
	VN_SEMI 								"‚®ü"
	VN_SEP 									"‚ö¨"
	'+'
	'-'
	'*'
	'/'
	'='
	'('
	')'
	';'
	SCOPE_RES 								"::"
	ENGINE	 								"Í©ú"
	STUFF		 							"‚©®"
	DELTA 									"‚ñ≤"
	DELTA_ARROW 							"ü°∫"
	BUILT_IN 								"‚ØÅ"
	OPEN_RESTRICT 							"„Äê"
	CLOSE_RESTRICT 							"„Äë"
	ANY 									"‚òÜ"
	STAR 									"‚òÖ"
	<wstring> 	STR 						_("string")
	<double>   	NUM 						_("number")
	<string>  	ASCII_NAME 					_("ASCII name")
	<wstring> 	UNICODE_NAME 				_("Unicode name")

%right '='
%left  '+' '-'
%left  '*' '/'
%precedence PREFIX ENGINE STUFF DELTA DELTA_ARROW OPEN_RESTRICT CLOSE_RESTRICT
%precedence BUILT_IN

%type <TreePtr<Node>> 				pattern
%type <wstring> 					vn_name
%type <list<string>> 				scoped_name
%type <VN::Command::List>			commands
%type <VN::Command::List>			sep_commands
%type <shared_ptr<VN::Command>>		bare_command
%type <VN::Itemisation>				itemisation
%type <VN::Itemisation>				items
%type <VN::Item>					item

%%

vnscript 		: commands 						{ vn->OnVNScript($1); }
     
// This is to make the ‚®ü optional on last command
commands        : sep_commands							{ $$ = $1; }
				| sep_commands VN_SEMI					{ $$ = $1; }
				
// The ‚®ü turns patterns into commands. This rule must 
// be left-associative so calls to OnParse() happen
// in the correct order. STOP BREAKING THIS!!!
sep_commands 	: sep_commands VN_SEMI bare_command		{ $$ = $1; if( $3->OnParse(vn) ) $$.push_back($3); }	
				| bare_command							{ if( $1->OnParse(vn) ) $$.push_back($1); }
			
// Add more commands here
bare_command	: vn_name DESIGNATE pattern				{ $$ = make_shared<VN::Designation>($1, $3, @2); }
				| ENGINE pattern   		 			 	{ $$ = make_shared<VN::EngineCommand>($2, @1); }
				| pattern 			  					{ $$ = make_shared<VN::PatternCommand>($1, @$); }
        
pattern	: pattern '+' pattern      { $$ = $1; }
		| pattern '-' pattern      { $$ = $1; }
		| pattern '*' pattern      { $$ = $1; }
		| pattern '/' pattern      { $$ = $1; }
		| STAR												{ $$ = vn->OnStar(); }
		| STUFF pattern 		     					 	{ $$ = vn->OnStuff($2); }
		| DELTA pattern DELTA_ARROW pattern   		   		{ $$ = vn->OnDelta($2, $4); }
		| BUILT_IN scoped_name itemisation					{ $$ = vn->OnBuiltIn($2, @2, $3); }
		| '-' %prec PREFIX pattern                 			{ $$ = vn->OnPrefixOperator("-", $2); }
		| '(' commands ')'                          		{ $$ = vn->OnEmbeddedCommands($2); }
		| OPEN_RESTRICT scoped_name CLOSE_RESTRICT pattern 	{ $$ = vn->OnRestrict($2, @2, $4, @4); }
		| vn_name       						  			{ $$ = vn->OnName($1, @1); }
		| NUM       						      			{ $$ = vn->OnSpecificInteger($1); }
		| ANY												{ $$ = nullptr; }
		;

itemisation : '(' items ')'    							{ $$ = $2; }
			| '(' ')'									{ $$ = VN::Itemisation{}; $$.loc = @$; }
  
items     	: items VN_SEP item   						{ $$ = $1; $$.items.push_back($3); $$.loc = @$; }
			| item										{ $$.items.push_back($1); $$.loc = @$; }

item		: item ',' pattern    						{ $$ = $1; $$.nodes.push_back($3); $$.loc = @$; }
			| pattern									{ $$.nodes.push_back($1); $$.loc = @$; }

vn_name			: UNICODE_NAME    						{ $$ = $1; }
				| ASCII_NAME							{ $$ = ToUnicode($1); }     
     
scoped_name		: ASCII_NAME SCOPE_RES scoped_name		{ $$ = $3; $$.push_front($1); }
				| ASCII_NAME							{ $$.push_front($1); }

%%
