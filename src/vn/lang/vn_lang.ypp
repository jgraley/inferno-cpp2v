%require "3.2"

%language "c++"
%define api.namespace {YY}
%define api.parser.class {VNLangParser}
%define api.value.type variant
%define api.token.constructor
%define parse.error detailed
%define parse.lac full

%defines

%locations
%define api.location.file "vn_lang.location.hpp"

%code requires {
  namespace YY {
    class VNLangScanner;
  };
  #include "vn_parse.hpp"
  #include "vn_commands.hpp"
}

%code { 
  #include "vn_lang.lpp.hpp"  /* Generated by reflex. */
  #include <iostream>
  #include <fstream>
  #undef yylex
  #define yylex lexer.lex  /* Within bison's parse() we should invoke lexer.lex(), not the global yylex() */
  
  // Strings that could be translated have _() around them. 
  // See https://www.gnu.org/software/gettext/manual/gettext.html
  #define _(String) (String)
  #define N_(String) String
}

%parse-param { YY::VNLangScanner& lexer }
%parse-param { VN::VNParse *vn }

%define api.token.prefix {TOK_}

// The order seems to matter here, find out why TODO
%token
	DESIGNATE 								"‚™Æ"
	VN_SEMI 								"‚®ü"
	VN_SEP 									"‚ö¨"
	'('
	')'
	';'
	SCOPE_RES 								"::"
	ENGINE	 								"Í©ú"
	STUFF		 							"‚©®"
	DELTA 									"‚ñ≤"
	DELTA_ARROW 							"‚Øà"
	BUILT_IN 								"‚ØÅ"
	OPEN_VN 								"„Äê"
	CLOSE_VN 								"„Äë"
	ANY 									"‚òÜ"
	STAR 									"‚òÖ"
	ID_BY_NAME								"‚äõ"
	SPECIFIC_ID								"üûä"
	BUILD_ID								"‚ßá"
	OPEN_CHEVRON							"„Ää"
	CLOSE_CHEVRON							"„Äã"
	TRANSFORM								"‚§®"
	NEGATION								"¬¨"
	CONJUNCTION								"‚àß"
	DISJUNCTION								"‚à®"
	GRASS									"‚´¥"
	POINTER_IS								"‚Æé"
	BUILD_SIZE								"üÑΩ"
	STRINGIZE								"¬ß"
	PRERESTRICT								"‚ÄΩ"
	C_ASSIGN								"="
	C_LOGICAL_OR							"||"
	C_LOGICAL_AND							"&&"
	<string>	C_COMPOUND_ASSIGN			_("C compound assignment operator")
	<string>	C_EQUALITY_OP				_("C equality operator")
	<string>  	C_RELATION_OP				_("C relation operator")
	<string>	C_ADD_SUB_OP				_("C add/subtract")
	<string>  	C_PREFIX_OP					_("C prefix operator")
	<string>	C_PRE_OR_INFIX_OP			_("C prefix/infix operator")
	<string>    C_PRE_OR_POSTFIX_OP 		_("C prefix/postfix operator")
	<wstring> 	STRING_LITERAL 				_("string")
	<string> 	INTEGRAL_LITERAL			_("integer literal")
	<bool>		BOOL_LITERAL				_("boolean literal")
	<string>  	ASCII_NAME 					_("ASCII name")
	<string>  	ASCII_FORMAT 				_("ASCII format string")
	<wstring> 	UNICODE_NAME 				_("Unicode name")

%left DISJUNCTION
%left CONJUNCTION 
%right C_ASSIGN
%left  '+' '-'
%left  '*' '/'
%right ENGINE STUFF DELTA DELTA_ARROW TRANSFORM NEGATION GRASS POINTER_IS BUILD_SIZE STRINGIZE C_PREFIX_OP
%left C_PRE_OR_POSTFIX_OP
%precedence OPEN_CHEVRON CLOSE_CHEVRON OPEN_VN CLOSE_VN
%precedence BUILT_IN BOOL_LITERAL STRING_LITERAL INTEGRAL_LITERAL SPECIFIC_ID

%type <TreePtr<Node>> 				pattern pat_unit pat_post pat_pre pat_rel pat_dis pat_con 
%type <TreePtr<Node>> 				pat_ass pat_eq pat_add pat_lor pat_land statements statement
%type <wstring> 					vn_name
%type <string>						format
%type <list<string>> 				scoped_name
%type <VN::Command::List>			commands sep_commands
%type <shared_ptr<VN::Command>>		bare_command
%type <VN::Limit>					limit
%type <VN::Itemisation>				itemisation items_bare items_sep
%type <VN::Item>					item

%%

vnscript 		: commands 						{ vn->OnVNScript($1); }
     
// This is to make the ‚®ü optional on last command
commands        : sep_commands							{ $$ = $1; }
				| sep_commands VN_SEMI					{ $$ = $1; }
				
// The ‚®ü turns patterns into commands. This rule must 
// be left-associative so calls to OnParse() happen
// in the correct order. STOP BREAKING THIS!!!
sep_commands 	: sep_commands VN_SEMI bare_command		{ $$ = $1; if( $3->OnParse(vn) ) $$.push_back($3); }	
				| bare_command							{ if( $1->OnParse(vn) ) $$.push_back($1); }
			
// Add more commands here
bare_command	: vn_name DESIGNATE pattern				{ $$ = make_shared<VN::Designation>($1, $3, @2); }
				| ENGINE pattern   		 			 	{ $$ = make_shared<VN::EngineCommand>($2, @1); }
				| pattern 			  					{ $$ = make_shared<VN::PatternCommand>($1, @$); }

// This one dips into ASCII/C because VN doesn't otherwise need equality/inequality operators
limit		: C_ASSIGN INTEGRAL_LITERAL					{ $$ = VN::Limit{ "=", @1, $2, @2 }; }

itemisation : '(' items_bare ')'    					{ $$ = $2; $$.loc = @$; }
			| '(' items_sep ')'	    					{ $$ = $2; $$.loc = @$; $$.items.push_back({{}, @3}); }
			| '(' ')'									{ $$.loc = @$; $$.items.push_back({{}, @2}); }
  
items_bare 	: items_sep item							{ $$ = $1; $$.items.push_back($2); }
			| item										{ $$.items.push_back($1); }

items_sep 	: items_bare VN_SEP		   					{ $$ = $1; } 
			| items_sep VN_SEP		 					{ $$ = $1; $$.items.push_back({{}, @2}); }
			| VN_SEP	 								{ $$.items.push_front({{}, @1}); }

item		: item ',' pattern    						{ $$ = $1; $$.nodes.push_back($3); $$.loc = @$; }
			| pattern									{ $$.nodes.push_back($1); $$.loc = @$; }


statements	: statement

statement	: pattern
                      
pattern	: pat_dis
                      
pat_dis	: pat_con
		| pat_dis DISJUNCTION pat_con						{ $$ = vn->OnDisjunction($1, $3); }

pat_con : pat_ass
		| pat_con CONJUNCTION pat_ass						{ $$ = vn->OnConjunction($1, $3); }

pat_ass : pat_lor 
		| 						   pat_lor C_ASSIGN pat_ass	{ $$ = vn->OnInfixOperator("=", $1, $3); }
		|                 pat_lor C_COMPOUND_ASSIGN pat_ass	{ $$ = vn->OnInfixOperator($2, $1, $3); }

pat_lor : pat_land
		| pat_lor C_LOGICAL_OR pat_land						{ $$ = vn->OnInfixOperator("||", $1, $3); }
		
pat_land: pat_eq
		| pat_land C_LOGICAL_AND pat_eq						{ $$ = vn->OnInfixOperator("&&", $1, $3); }

pat_eq  : pat_rel
		| pat_eq C_EQUALITY_OP pat_rel						{ $$ = vn->OnInfixOperator($2, $1, $3); }

pat_rel : pat_add
		| pat_rel C_RELATION_OP pat_add						{ $$ = vn->OnInfixOperator($2, $1, $3); }
		
pat_add : pat_pre
		| pat_add C_ADD_SUB_OP pat_pre						{ $$ = vn->OnInfixOperator($2, $1, $3); }
		
pat_pre : pat_post
		|  									  STUFF pat_pre	{ $$ = vn->OnStuff($2, nullptr, VN::Limit()); }
		| 			 STUFF OPEN_VN pattern CLOSE_VN pat_pre	{ $$ = vn->OnStuff($5, $3, VN::Limit()); }
		| 			 STUFF OPEN_VN limit   CLOSE_VN pat_pre	{ $$ = vn->OnStuff($5, nullptr, $3); }
		| 				  DELTA pattern DELTA_ARROW pat_pre	{ $$ = vn->OnDelta($2, $4); }
		| 					    C_PREFIX_OP 		pat_pre	{ $$ = vn->OnPrefixOperator($1, $2); }
		| 					    C_ADD_SUB_OP	    pat_pre	{ $$ = vn->OnPrefixOperator($1, $2); }
		| 					    C_PRE_OR_INFIX_OP   pat_pre	{ $$ = vn->OnPrefixOperator($1, $2); }
		| 					    C_PRE_OR_POSTFIX_OP pat_pre	{ $$ = vn->OnPrefixOperator($1, $2); }
		|  PRERESTRICT OPEN_VN scoped_name CLOSE_VN pat_pre	{ $$ = vn->OnRestrict($3, @3, $5, @5); }
		| 	  TRANSFORM OPEN_VN ASCII_NAME CLOSE_VN pat_pre	{ $$ = vn->OnTransform($3, @3, $5, @5); }
		| 								   NEGATION pat_pre	{ $$ = vn->OnNegation($2); }
		| 									  GRASS pat_pre	{ $$ = vn->OnGrass($2); }
		| 								 POINTER_IS pat_pre	{ $$ = vn->OnPointerIs($2); }
		| 								 BUILD_SIZE pat_pre	{ $$ = vn->OnBuildSize($2); }
		| 								  STRINGIZE pat_pre	{ $$ = vn->OnStringize($2); }

pat_post: pat_unit     
		| pat_post C_PRE_OR_POSTFIX_OP 					 	{ $$ = vn->OnPostfixOperator($2, $1); }
  
pat_unit: STAR												{ $$ = vn->OnStar(nullptr); }
		| STAR OPEN_VN pattern CLOSE_VN						{ $$ = vn->OnStar($3); }
		| BUILT_IN scoped_name itemisation					{ $$ = vn->OnBuiltIn($2, @2, $3); }
		| BUILT_IN scoped_name								{ $$ = vn->OnBuiltIn($2, @2, VN::Itemisation{{}, @2}); }
		| INTEGRAL_LITERAL					      			{ $$ = vn->OnIntegralLiteral($1, @1); }
		| STRING_LITERAL					      			{ $$ = vn->OnStringLiteral($1); }
		| BOOL_LITERAL										{ $$ = vn->OnBoolLiteral($1); }
		| ANY												{ $$ = nullptr; }
		| '(' commands ')'                          		{ $$ = vn->OnEmbeddedCommands($2); }
		| '{' statements '}'                          		{ $$ = $2; }
		| vn_name       						  			{ $$ = vn->OnName($1, @1); }
		| SPECIFIC_ID OPEN_VN scoped_name VN_SEP ASCII_NAME CLOSE_VN		{ $$ = vn->OnSpecificId($3, @3, $5, @5); }
		| SPECIFIC_ID OPEN_VN scoped_name VN_SEP CLOSE_VN					{ $$ = vn->OnSpecificId($3, @3, "", @5); }
		| ID_BY_NAME OPEN_VN scoped_name VN_SEP ASCII_NAME CLOSE_VN			{ $$ = vn->OnIdByName($3, @3, $5, @5); } // ASCII_NAME could be format
		| BUILD_ID OPEN_VN scoped_name VN_SEP format VN_SEP CLOSE_VN 		{ $$ = vn->OnBuildId($3, @3, $5, @5, VN::Item{}); }
		| BUILD_ID OPEN_VN scoped_name VN_SEP format VN_SEP item CLOSE_VN 	{ $$ = vn->OnBuildId($3, @3, $5, @5, $7); }
		| BUILD_ID OPEN_VN scoped_name VN_SEP VN_SEP item CLOSE_VN 			{ $$ = vn->OnBuildId($3, @3, "", @5, $6); }


format		: ASCII_FORMAT  							{ $$ = $1; }
			| ASCII_NAME		  						{ $$ = $1; }

vn_name			: UNICODE_NAME    						{ $$ = $1; }
				| ASCII_NAME							{ $$ = ToUnicode($1); }     
     
scoped_name		: ASCII_NAME SCOPE_RES scoped_name		{ $$ = $3; $$.push_front($1); }
				| ASCII_NAME							{ $$.push_front($1); }

%%
