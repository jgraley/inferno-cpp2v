%require "3.2"

%language "c++"
%define api.namespace {YY}
%define api.parser.class {VNLangParser}
%define api.value.type variant
%define api.token.constructor
%define parse.error detailed
// Inadequacy Elimination LR
%define lr.type ielr
// Lookahead Correction
%define parse.lac full
%define parse.trace

%defines

%locations
%define api.location.file "vn_lang.location.hpp"

%code requires {
  // Appears high-ish in the generated .hpp file
  #include "vn_actions.hpp" 
  #include "declarators.hpp" 
  #include "node/tree_ptr.hpp"
  #include "tree/node_names.hpp"
  #include <string>
  namespace YY {
    class VNLangScanner;  
  	struct TokenMetadata
	{
		TreePtr<Node> as_designated;
		string as_ascii;
		wstring as_unicode;
		const AvailableNodeData::Block *as_andata_block;
	};     	
  };
  // Things we point to from semantic values
  namespace VN { 
    class Command;
    class Gnomon;
    class ResolverGnomon;
  }
}

%code { 
  // Appears high-ish in the generated .cpp file
  #include "vn_lang.lpp.hpp"  /* Generated by reflex. */
  #include <iostream>
  #include <fstream>
  #include "vn_commands.hpp"
  #undef yylex
  #define yylex lexer.lex  /* Within bison's parse() we should invoke lexer.lex(), not the global yylex() */
  
  // Strings that could be translated have _() around them. 
  // See https://www.gnu.org/software/gettext/manual/gettext.html
  #define _(String) (String)
  #define N_(String) String 
}

%parse-param { YY::VNLangScanner& lexer }
%parse-param { VN::VNLangActions *vn }
%parse-param { VN::VNLangRecogniser *recogniser }

%define api.token.prefix {TOK_}

%token
	DESIGNATE 								"‚™Æ"
	VN_SEMI 								"‚®ü"
	VN_COLON 								"‚¶Ç"
	VN_SEP 									"‚ö¨"
	VN_SUB_SEP								"üûÑ"
	'('	
	';'
	RESOLUTION_OP 							"::"
	RANGE_OP 								".."
	ENGINE	 								"Í©ú"
	STUFF		 							"‚©®"
	DELTA 									"‚ñ≤"
	DELTA_ARROW 							"‚Øà"
	BUILT_IN 								"‚ØÅ"
	OPEN_VN 								"‚¶Ö"
	CLOSE_VN 								"‚¶Ü"
	ANY 									"‚òÜ"
	STAR 									"‚òÖ"
	ID_BY_NAME								"‚äõ"
	SPECIFIC_ID								"üûä"
	BUILDER_ID								"‚ßá"
	OPEN_CHEVRON							"„Ää"
	CLOSE_CHEVRON							"„Äã"
	TRANSFORM								"‚§®"
	NEGATION								"¬¨"
	CONJUNCTION								"‚àß"
	DISJUNCTION								"‚à®"
	GRASS									"‚´¥"
	POINTER_IS								"‚Æé"
	BUILD_SIZE								"üÑΩ"
	STRINGIZE								"¬ß"
	PRERESTRICT								"‚ÄΩ"
	OPEN_TYPE								"‚∏®"
	CLOSE_TYPE								"‚∏©"
	OPEN_MAP_CALL							"„Äî"
	CLOSE_MAP_CALL							"„Äï"
	ATTRIBUTE								"‚Ä°"
	CONSTRUCTOR								"‚®§"
	<string>	COMMA						_("comma")
	<string>	C_ASSIGN					"="
	<string>	C_COMPOUND_ASSIGN			_("C compound_primary assignment operator")
	<string>	C_LOGICAL_OR_OP				"||"			
	<string>	C_LOGICAL_AND_OP			"&&"			
	<string>	C_BITWISE_OR_OP				"|"
	<string>	C_BITWISE_XOR_OP			"^"
	<string>	C_AMPERSAND					"&"
	<string>	C_EQUALITY_OP				_("C equality operator")
	<string>  	C_RELATIONAL_OP				_("C relation operator")
	<string>	C_SHIFT_OP					_("C shift operator")
	<string>	C_ADD_SUB_OP				_("C add/subtract")
	<string>    C_DIV_MOD_OP				_("C divide/modulo")
	<string> 	C_STAR						"*"
	<string>  	C_PREFIX_OP					_("C prefix operator")
	<string>	C_PRE_OR_INFIX_OP			_("C prefix/infix operator")
	<string>    C_PRE_OR_POSTFIX_OP 		_("C prefix/postfix operator")
	<wstring> 	STRING_LITERAL 				_("string")
	<string> 	INTEGRAL_LITERAL			_("integer literal")
	<bool>		BOOL_LITERAL				_("boolean literal")
	<string>	ASCII_FORMAT 				_("ASCII format string")
	<string>	TYPENAME					_("type name")
	<string>	TYPE_SPECIFIER			_("simple type specifier")
	<YY::TokenMetadata> TRANSFORM_NAME_UNIFIED	_("unified transformation name")
	<YY::TokenMetadata> TRANSFORM_NAME_NORMAL	_("normal transformation name")
	<YY::TokenMetadata> ASCII_NAME 				_("ASCII name")
	<YY::TokenMetadata> UNICODE_NAME 			_("Unicode name")
	<YY::TokenMetadata>	DESIGNATED_NORMAL		_("designated name")
	<YY::TokenMetadata>	DESIGNATED_TYPE			_("designated type name")
	<YY::TokenMetadata>	RESOLVED_NORMAL			_("resolved node name")
	<YY::TokenMetadata>	RESOLVED_TYPE			_("resolved type node name")
	<YY::TokenMetadata>	NODE_NAMESPACE			_("scope resolving name")
	<YY::TokenMetadata>	DECLARATION_OF			_("DeclarationOf")
	<YY::TokenMetadata>	TYPE_OF					_("TypeOf")
	<YY::TokenMetadata> NORM_TERM_KEYWORD		_("terminal keyword")
	<YY::TokenMetadata> PRIMITIVE_STMT_KEYWORD  _("statement keyword") // eg break;
	<YY::TokenMetadata> SPACE_SEP_STMT_KEYWORD 	_("space-separated statement keyword") // eg return 12;
	<YY::TokenMetadata> ARGS_BODY_STMT_KEYWORD 	_("args-and-body statement keyword") // eg switch(args) body
	<YY::TokenMetadata> ARGS_BODY_CHAIN_STMT_KEYWORD 	_("args-body-chain statement keyword") // eg if(args) body else chain_body	
	<YY::TokenMetadata> PRIMITIVE_CHAIN_KEYWORD _("chain keyword") // eg else
	<YY::TokenMetadata> DO_KEYWORD				_("do")
	<YY::TokenMetadata> WHILE_KEYWORD			_("while")
	<YY::TokenMetadata> CASE_KEYWORD			_("case")
	<YY::TokenMetadata> DEFAULT_KEYWORD			_("default")
	<YY::TokenMetadata> FUNC_ON_TYPE			_("function acting on a type")
	stmt_low 
	stmt_high
	
%type <TreePtr<Node>> 				normal expr_primary expr_postfix expr_prefix expr_relational norm_disjunction norm_conjunction  
%type <TreePtr<Node>> 				expr_assignment expr_equality expr_add_etc expr_logical_or expr_logical_and 
%type <TreePtr<Node>> 				expr_mul_etc expr_shift expr_bitwise_and expr_bitwise_or expr_bitwise_xor  
%type <TreePtr<Node>> 				expr_comma_op expr_no_comma_op expr_expression norm_primary expr_id_value vn_wildcard
%type <TreePtr<Node>> 				type_specified type_primary type_postfix type_prefix type_disjunction type_conjunction type_vn_prim type_with_ab
%type <TreePtr<Node>> 				unified unified_prefix
%type <TreePtr<Node>> 				bare_statement statement_nc statement stmt_disjunction stmt_conjunction stmt_primary norm_expr_or_stmt 
%type <TreePtr<Node>>				declaration_nc bare_declaration cons_or_des_type 
%type <TreePtr<Node>> 				compound_primary compound_prefix parameter type_id 
%type <TreePtr<Node>> 				declarator declarator_prefix declarator_postfix declarator_primary
%type <TreePtr<Node>> 				ab_declarator ab_declarator_prefix ab_declarator_postfix
%type <wstring> 					vn_name
%type <string>						transform_norm_part transform_unif_part
%type <YY::TokenMetadata> 			resolved_name resolved_type_name node_namespace
%type <list<shared_ptr<VN::Command>>>			commands sep_commands
%type <shared_ptr<VN::Command>>		script_command 
%type <VN::Limit>					stuff_depth_limit
%type <VN::Itemisation>				itemisation items_bare items_sep
%type <VN::Item>					item
%type <shared_ptr<VN::Gnomon>>		part_resolve designation_command 
%type <shared_ptr<VN::Gnomon>>		start_transform_name_scope
%type <shared_ptr<VN::Gnomon>>		start_builtin_scope start_prerestrict_scope start_id_by_name_scope start_build_id_scope
%type <list<TreePtr<Node>>>			statements 
%type <list<TreePtr<Node>>>			comma_sep_expr_decl semicolon_args parameters parameterisation
%type <const AvailableNodeData::Block *> builtin_name_part prerestrict_name_part id_by_name_part build_id_part
%type <const AvailableNodeData::Block *> type_builtin_name_part type_prerestrict_name_part type_id_by_name_part type_build_id_part
%type <multiset<string>>			type_specifier_seq

// Solve the dangling-else amiguity by giving the "else" token a higher priority than the "if" token
// In the rule, we must set the no-else rule to the "if" priority using %prec. Then, the TOKEN
// for "else" will be compared with the RULE for no-else case and highest precidence will win.
// It's all rather brittle.
%precedence ARGS_BODY_CHAIN_STMT_KEYWORD
%precedence PRIMITIVE_CHAIN_KEYWORD

%%

//////////////////////////////////// COMMANDS ///////////////////////////////////////////

vnscript 		: commands 								{ vn->OnVNScript($1); }
     
// This is to make the ‚®ü optional on last command
commands        : sep_commands							{ $$ = $1; }
				| sep_commands VN_SEMI					{ $$ = $1; }
				
// The ‚®ü turns patterns into commands. This rule must 
// be left-associative so calls to OnParse() happen
// in the correct order. STOP BREAKING THIS!!!
sep_commands 	: sep_commands VN_SEMI script_command		{ $$ = $1; $$.push_back($3); }	
				| script_command							{ $$.push_back($1); }
				| sep_commands VN_SEMI designation_command	{ $$ = $1; recogniser->AddGnomon($3); }	
				| designation_command						{ recogniser->AddGnomon($1); }
			
// Add more commands here
script_command	: ENGINE normal   		 		 	{ $$ = make_shared<VN::EngineCommand>($2, @1); }
				| normal 			  				{ $$ = make_shared<VN::PatternCommand>($1, @$); } // in trivial cases, this decays back to the node
				| ATTRIBUTE		  					{ $$ = make_shared<VN::AttributeCommand>(@$); }

// or here
designation_command	: vn_name DESIGNATE normal		{ $$ = make_shared<VN::NonTypeDesignationGnomon>($1, $3); }
					| vn_name DESIGNATE type_id		{ $$ = make_shared<VN::TypeDesignationGnomon>($1, $3); }

//////////////////////////////////// ITEMISATION ///////////////////////////////////////////
// For explicit/built-in nodes mostly

itemisation	: OPEN_VN items_bare CLOSE_VN  			{ $$ = $2; $$.loc = @$; }
			| OPEN_VN items_sep CLOSE_VN			{ $$ = $2; $$.loc = @$; $$.items.push_back({{}, @3}); }
			| OPEN_VN CLOSE_VN						{ $$.loc = @$; }
					
items_bare 	: items_sep item						{ $$ = $1; $$.items.push_back($2); }
			| item									{ $$.items.push_back($1); }

items_sep 	: items_bare VN_SEP		   				{ $$ = $1; } 
			| items_sep VN_SEP		 				{ $$ = $1; $$.items.push_back({{}, @2}); }
			| VN_SEP	 							{ $$.items.push_front({{}, @1}); }

item		: item VN_SUB_SEP unified				{ $$ = $1; $$.nodes.push_back($3); $$.loc = @$; }
			| unified								{ $$.nodes.push_back($1); $$.loc = @$; }

unified		: normal
			| type_id

//////////////////////////////// NORMALS ////////////////////////////////////         
// Normal is basically anything other than a type

normal				: norm_disjunction

norm_disjunction	: norm_conjunction
					| norm_disjunction DISJUNCTION norm_conjunction				{ $$ = vn->OnDisjunction($1, $3); }

norm_conjunction 	: norm_expr_or_stmt
					| norm_conjunction CONJUNCTION norm_expr_or_stmt				{ $$ = vn->OnConjunction($1, $3); }
		
norm_expr_or_stmt	: expr_expression
					| statement_nc // statements not including Compound, which is expressional from this POV
					| compound_prefix // Branch off here for compound_primary to avoid conflicts with prefix = (used for inits)
					| declaration_nc			

//////////////////////////////// STATEMENTS ////////////////////////////////////         

// Because there's no separator in {{code} expr} the prefix ops would conflict with infix that use same symbol,
// so we'll need to complete a branch of the syntax for compounds with a copy of the unary VN operators (none are postfix).
compound_prefix : compound_primary 
				| 			       DELTA normal DELTA_ARROW compound_prefix	{ $$ = vn->OnDelta($2, $4); }
				| 								   NEGATION compound_prefix	{ $$ = vn->OnNegation($2); }
				|       				transform_norm_part compound_prefix	{ $$ = vn->OnTransform($1, @1, $2, @2); }
				| 								 BUILD_SIZE compound_prefix	{ $$ = vn->OnBuildSize($2); }
				| 								  STRINGIZE compound_prefix	{ $$ = vn->OnStringize($2); }
				|  									  STUFF compound_prefix	{ $$ = vn->OnStuff($2, nullptr, VN::Limit()); }
				|  STUFF OPEN_VN           unified CLOSE_VN compound_prefix	{ $$ = vn->OnStuff($5, $3, VN::Limit()); }
				|  STUFF OPEN_VN stuff_depth_limit CLOSE_VN compound_prefix	{ $$ = vn->OnStuff($5, nullptr, $3); }
				|                     prerestrict_name_part compound_prefix	{ $$ = vn->OnRestrict($1, @1, $2, @2); }

compound_primary	: '{' VN_SEP '}'                   						{ $$ = vn->OnCompound({}, @2, {}, @3); } 
					| '{' statements VN_SEP '}'           					{ $$ = vn->OnCompound($2, @2, {}, @4); }
					| '{' VN_SEP statements '}'           					{ $$ = vn->OnCompound({}, @2, $3, @3); }
					| '{' statements VN_SEP statements '}'  				{ $$ = vn->OnCompound($2, @2, $4, @4); }

statements	: statement														{ $$.push_back($1); }
			| statements statement											{ $$ = $1; $$.push_back($2); }
         
statement	: stmt_disjunction

stmt_disjunction	: stmt_conjunction
					| stmt_disjunction DISJUNCTION stmt_conjunction			{ $$ = vn->OnDisjunction($1, $3); }

stmt_conjunction 	: stmt_primary
					| stmt_conjunction CONJUNCTION stmt_primary				{ $$ = vn->OnConjunction($1, $3); }

stmt_primary: compound_primary 
			| statement_nc %prec ';'
			| ';'															{ $$ = vn->OnNop(@1); }      
					
// _nc here means "not a compound"						
statement_nc: bare_statement ';'												{ $$ = $1; }      
			| ARGS_BODY_STMT_KEYWORD '(' semicolon_args ')' stmt_primary		{ $$ = vn->OnArgsBodyStmt($1.as_ascii, @1, $3, @3, $5, @5); }
			| WHILE_KEYWORD '(' expr_expression ')' stmt_primary 				{ $$ = vn->OnWhile($3, @3, $5, @5); }
			| ARGS_BODY_CHAIN_STMT_KEYWORD '(' semicolon_args ')' stmt_primary	
			  %prec ARGS_BODY_CHAIN_STMT_KEYWORD								{ $$ = vn->OnArgsBodyChainStmt($1.as_ascii, @1, $3, @3, $5, @5, "", @1, nullptr, @1); }
			| ARGS_BODY_CHAIN_STMT_KEYWORD '(' semicolon_args ')' stmt_primary
			  PRIMITIVE_CHAIN_KEYWORD stmt_primary								{ $$ = vn->OnArgsBodyChainStmt($1.as_ascii, @1, $3, @3, $5, @5, $6.as_ascii, @6, $7, @7); }

bare_statement	: expr_expression
				| PRIMITIVE_STMT_KEYWORD										{ $$ = vn->OnPrimitiveStmt($1.as_ascii, @1); }
				| SPACE_SEP_STMT_KEYWORD expr_expression						{ $$ = vn->OnSpaceSepStmt($1.as_ascii, @1, $2, @2); }
				| DO_KEYWORD statement WHILE_KEYWORD '(' expr_expression ')' 	{ $$ = vn->OnDo($2, @2, $5, @5); }
				| expr_expression ':'											{ $$ = vn->OnLabel($1, @1); } 
				| CASE_KEYWORD expr_expression ':'								{ $$ = vn->OnCase($2, @2); } 
				| CASE_KEYWORD expr_expression RANGE_OP expr_expression ':'		{ $$ = vn->OnRangeCase($2, @2, $4, @4); } 
				| DEFAULT_KEYWORD ':'											{ $$ = vn->OnDefault(@$); } 

semicolon_args	: expr_expression											{ $$.push_back($1); }
				| semicolon_args ';' expr_expression						{ $$ = $1; $$.push_back($3); }

//////////////////////////////// DECLARATIONS /////////////////////////////////////         
        
// _nc here means "not a compound"						
declaration_nc		: bare_declaration ';'
                  
bare_declaration	: type_specified declarator							{ $$ = vn->OnTypeAndDeclarator($1, $2, @2); }	
		
declarator			: declarator_prefix									 

declarator_prefix	: declarator_postfix
//					|                     C_AMPERSAND declarator_prefix { $$ = make_shared<Declarators::Reference>($2); } 
//					|                          C_STAR declarator_prefix { $$ = make_shared<Declarators::Pointer>($2); } 

declarator_postfix	: declarator_primary
					| declarator_postfix parameterisation				{ $$ = make_shared<Declarators::Function>($1, $2); }               
					| declarator_postfix '[' normal ']'					{ $$ = make_shared<Declarators::Array>($1, $3); } 
                
declarator_primary	: norm_primary										{ $$ = make_shared<Declarators::Concrete>($1); }  
                         
parameterisation	: '(' parameters ')'							{ $$ = $2; }
					| '(' ')'										{ $$.clear(); }							

parameters	: parameter												{ $$.push_back($1); }
			| parameters COMMA parameter							{ $$ = $1; $$.push_back($3); }			
				
parameter   : type_specified declarator 							{ $$ = vn->OnParameter($1, $2, @2); }	
			| type_primary ab_declarator							{ $$ = vn->OnAbstractParameter($1, $2, @1); }	
            | expr_prefix
            
//////////////////////////////// EXPRESSIONS ////////////////////////////////////         

expr_expression		: expr_comma_op
                                   
expr_comma_op       : expr_no_comma_op
                    | expr_comma_op COMMA expr_no_comma_op						{ $$ = vn->OnInfixOperator($2, $1, $3); }
   
comma_sep_expr_decl	: expr_no_comma_op											{ $$.push_back($1); }
					| comma_sep_expr_decl COMMA expr_no_comma_op				{ $$ = $1; $$.push_back($3); }			

expr_no_comma_op 	: expr_id_value

expr_id_value		: expr_assignment
					| expr_id_value VN_COLON expr_assignment					{ $$ = vn->OnIdValuePair($1, @1, $3); }
					
expr_assignment 	: expr_logical_or 
					| 				   expr_logical_or C_ASSIGN expr_assignment	{ $$ = vn->OnInfixOperator($2, $1, $3); }
					|         expr_logical_or C_COMPOUND_ASSIGN expr_assignment	{ $$ = vn->OnInfixOperator($2, $1, $3); }
					|   expr_logical_or '?' expr_expression ':' expr_assignment	{ $$ = vn->OnConditionalOperator($1, $3, $5); }

expr_logical_or 	: expr_logical_and
					| expr_logical_or C_LOGICAL_OR_OP expr_logical_and			{ $$ = vn->OnInfixOperator($2, $1, $3); }
		
expr_logical_and	: expr_bitwise_or
					| expr_logical_and C_LOGICAL_AND_OP expr_bitwise_or			{ $$ = vn->OnInfixOperator($2, $1, $3); }

expr_bitwise_or 	: expr_bitwise_xor
					| expr_bitwise_or C_BITWISE_OR_OP expr_bitwise_xor			{ $$ = vn->OnInfixOperator($2, $1, $3); }
		
expr_bitwise_xor	: expr_bitwise_and
					| expr_bitwise_xor C_BITWISE_XOR_OP expr_bitwise_and		{ $$ = vn->OnInfixOperator($2, $1, $3); }
		
expr_bitwise_and	: expr_equality
					| expr_bitwise_and C_AMPERSAND expr_equality				{ $$ = vn->OnInfixOperator($2, $1, $3); }

expr_equality 		: expr_relational
					| expr_equality C_EQUALITY_OP expr_relational				{ $$ = vn->OnInfixOperator($2, $1, $3); }

expr_relational 	: expr_shift
					| expr_relational C_RELATIONAL_OP expr_shift				{ $$ = vn->OnInfixOperator($2, $1, $3); }

expr_shift			: expr_add_etc
					| expr_shift C_SHIFT_OP expr_add_etc						{ $$ = vn->OnInfixOperator($2, $1, $3); }
		
expr_add_etc 		: expr_mul_etc
					| expr_add_etc C_ADD_SUB_OP expr_mul_etc					{ $$ = vn->OnInfixOperator($2, $1, $3); }
		
expr_mul_etc 		: expr_prefix
					| expr_mul_etc C_DIV_MOD_OP expr_prefix						{ $$ = vn->OnInfixOperator($2, $1, $3); }
					| expr_mul_etc '*' expr_prefix								{ $$ = vn->OnInfixOperator("*", $1, $3); }
		
expr_prefix : expr_postfix
			| 					    C_PREFIX_OP 		expr_prefix	 { $$ = vn->OnPrefixOperator($1, $2); }
			| 					    C_AMPERSAND 		expr_prefix	 { $$ = vn->OnPrefixOperator($1, $2); }
			| 					    C_STAR		 		expr_prefix	 { $$ = vn->OnPrefixOperator($1, $2); }
			| 					    C_ADD_SUB_OP	    expr_prefix	 { $$ = vn->OnPrefixOperator($1, $2); }
			| 					    C_PRE_OR_INFIX_OP   expr_prefix	 { $$ = vn->OnPrefixOperator($1, $2); }
			| 					    C_PRE_OR_POSTFIX_OP expr_prefix	 { $$ = vn->OnPrefixOperator($1, $2); }
			| 									  GRASS expr_prefix	 { $$ = vn->OnGrass($2); }
			| 								 POINTER_IS expr_prefix	 { $$ = vn->OnPointerIs($2); }
			| 			       DELTA normal DELTA_ARROW expr_prefix	 { $$ = vn->OnDelta($2, $4); }
			| 								   NEGATION expr_prefix	 { $$ = vn->OnNegation($2); }
			|       				transform_norm_part type_prefix	 { $$ = vn->OnTransform($1, @1, $2, @2); }
			| 								 BUILD_SIZE unified_prefix	{ $$ = vn->OnBuildSize($2); }
			| 								  STRINGIZE unified_prefix	{ $$ = vn->OnStringize($2); }
			|  									  STUFF unified_prefix	{ $$ = vn->OnStuff($2, nullptr, VN::Limit()); }
			|  STUFF OPEN_VN           unified CLOSE_VN unified_prefix	{ $$ = vn->OnStuff($5, $3, VN::Limit()); }
			|  STUFF OPEN_VN stuff_depth_limit CLOSE_VN unified_prefix	{ $$ = vn->OnStuff($5, nullptr, $3); }
			|                     prerestrict_name_part unified_prefix	{ $$ = vn->OnRestrict($1, @1, $2, @2); }

transform_norm_part : start_transform_name_scope TRANSFORM_NAME_NORMAL { $$ = $2.as_ascii; (void)$1; }

// This one dips into ASCII/C because VN doesn't otherwise need equality/inequality operators
stuff_depth_limit		: C_ASSIGN INTEGRAL_LITERAL					{ $$ = VN::Limit{ $1, @1, $2, @2 }; }

// Use a prerestriction to disambiguate ‚§®‚¶ÖDeclarationOf‚¶Ü...
unified_prefix	: expr_prefix
				| type_prefix
				| transform_unif_part expr_prefix	 			{ $$ = vn->OnTransform($1, @1, $2, @2); }
  
transform_unif_part : start_transform_name_scope TRANSFORM_NAME_UNIFIED { $$ = $2.as_ascii; (void)$1; }
  
expr_postfix: expr_primary     
			| expr_postfix C_PRE_OR_POSTFIX_OP 				 		{ $$ = vn->OnPostfixOperator($2, $1); }
			| expr_postfix '[' normal ']'	 				 		{ $$ = vn->OnSubscript($1, $3); }
			| expr_postfix OPEN_MAP_CALL comma_sep_expr_decl CLOSE_MAP_CALL	{ $$ = vn->OnMapArgsCall($1, $3); }
			| expr_postfix OPEN_MAP_CALL CLOSE_MAP_CALL				{ $$ = vn->OnMapArgsCall($1, list<TreePtr<Node>>()); }
			| expr_postfix '(' comma_sep_expr_decl ')'				{ $$ = vn->OnSeqArgsCall($1, $3); }
			| expr_postfix '(' ')'	 								{ $$ = vn->OnSeqArgsCall($1, list<TreePtr<Node>>()); }
			| expr_postfix '.' expr_primary							{ $$ = vn->OnLookup($1, $3, @3); }
		
expr_primary: norm_primary
			| '(' commands ')'                          		{ $$ = vn->OnEmbeddedCommands($2); }
			| INTEGRAL_LITERAL					      			{ $$ = vn->OnIntegralLiteral($1, @1); }
			| STRING_LITERAL					      			{ $$ = vn->OnStringLiteral($1); }
			| BOOL_LITERAL										{ $$ = vn->OnBoolLiteral($1); }
			| NORM_TERM_KEYWORD									{ $$ = vn->OnNormalTerminalKeyword($1.as_ascii, @1); }
			| C_ASSIGN '{' '}'             				  		{ $$ = vn->OnArrayLiteral({}); } // ={...} dismbiguates against compound_primary
			| C_ASSIGN '{' comma_sep_expr_decl '}'      		{ $$ = vn->OnArrayLiteral($3); }               

norm_primary: vn_wildcard
			| builtin_name_part itemisation								{ $$ = vn->OnBuiltIn($1, @1, $2); }
			| DESIGNATED_NORMAL       				  					{ $$ = $1.as_designated; }
			| id_by_name_part OPEN_VN STRING_LITERAL CLOSE_VN			{ $$ = vn->OnIdByName($1, @1, $3, @3); } // ASCII_NAME could be format
			| build_id_part OPEN_VN STRING_LITERAL VN_SEP CLOSE_VN 		{ $$ = vn->OnBuildId($1, @1, $3, @3, VN::Item{}); }
			| build_id_part OPEN_VN STRING_LITERAL VN_SEP item CLOSE_VN	{ $$ = vn->OnBuildId($1, @1, $3, @3, $5); }
			| build_id_part OPEN_VN VN_SEP item CLOSE_VN 				{ $$ = vn->OnBuildId($1, @1, wstring(), @3, $4); }
			| FUNC_ON_TYPE '(' type_id ')'            					{ $$ = vn->OnFuncOnType($1.as_ascii, @1, $3, @3); }			
			
vn_wildcard : STAR												{ $$ = vn->OnStar(nullptr); }
			| STAR OPEN_VN normal CLOSE_VN						{ $$ = vn->OnStar($3); }
			| ANY												{ $$ = nullptr; }

builtin_name_part 	: start_builtin_scope resolved_name			{ $$ = $2.as_andata_block; (void)$1; }
prerestrict_name_part : start_prerestrict_scope resolved_name	{ $$ = $2.as_andata_block; (void)$1; }
id_by_name_part 	: start_id_by_name_scope resolved_name		{ $$ = $2.as_andata_block; (void)$1; }
build_id_part 		: start_build_id_scope resolved_name		{ $$ = $2.as_andata_block; (void)$1; }

//////////////////////////////// TYPES ////////////////////////////////////         
       
type_id 			: type_disjunction

type_disjunction	: type_conjunction
					| type_disjunction DISJUNCTION type_conjunction			{ $$ = vn->OnDisjunction($1, $3); }

type_conjunction 	: type_with_ab
					| type_conjunction CONJUNCTION type_prefix				{ $$ = vn->OnConjunction($1, $3); }
                    
type_with_ab		: type_specified
					| type_primary ab_declarator							{ $$ = vn->OnTypeAndAbstractDeclarator($1, $2, @2); }  
					
ab_declarator		: ab_declarator_prefix										    

ab_declarator_prefix	: ab_declarator_postfix
						|                      						C_AMPERSAND { $$ = make_shared<Declarators::Reference>(nullptr); }  
						|                           					 C_STAR { $$ = make_shared<Declarators::Pointer>(nullptr); } 
						|                      C_AMPERSAND ab_declarator_prefix { $$ = make_shared<Declarators::Reference>($2); } 
						|                           C_STAR ab_declarator_prefix { $$ = make_shared<Declarators::Pointer>($2); } 

ab_declarator_postfix	: parameterisation										{ $$ = make_shared<Declarators::Function>(nullptr, $1); }       
						| '[' normal ']'										{ $$ = make_shared<Declarators::Array>(nullptr, $2); } 
                		| ab_declarator_postfix parameterisation				{ $$ = make_shared<Declarators::Function>($1, $2); }       
						| ab_declarator_postfix '[' normal ']'					{ $$ = make_shared<Declarators::Array>($1, $3); } 
                					                
// Not including types that require declarators (except via built-in, designation etc)          
type_specified		: type_prefix          
          
type_prefix : type_postfix
			| 			 		  DELTA type_id DELTA_ARROW type_prefix	{ $$ = vn->OnDelta($2, $4); }
			| 									      GRASS type_prefix	{ $$ = vn->OnGrass($2); }
			| 								     POINTER_IS type_prefix	{ $$ = vn->OnPointerIs($2); }
			| 								       NEGATION type_prefix	{ $$ = vn->OnNegation($2); }
			|                 type_prerestrict_name_part unified_prefix	{ $$ = vn->OnRestrict($1, @1, $2, @2); }
			   
type_postfix: type_primary		   
			                                       
type_primary: type_vn_prim
			| '(' type_id ')'													{ $$ = $2; } // For disambiguation and introducing types using anonymous declarators
			| type_specifier_seq 												{ $$ = vn->OnTypeSpecifierSeq($1, @1); }
			| cons_or_des_type			
				
cons_or_des_type : CONSTRUCTOR parameterisation 		 						{ $$ = vn->OnConstructor($2); } 				
									
type_vn_prim: type_builtin_name_part itemisation								{ $$ = vn->OnBuiltIn($1, @1, $2); }
			| DESIGNATED_TYPE     									  			{ $$ = $1.as_designated; }		
			| type_id_by_name_part OPEN_VN STRING_LITERAL CLOSE_VN				{ $$ = vn->OnIdByName($1, @1, $3, @3); } // ASCII_NAME could be format
			| type_build_id_part OPEN_VN STRING_LITERAL VN_SEP CLOSE_VN 		{ $$ = vn->OnBuildId($1, @1, $3, @3, VN::Item{}); }
			| type_build_id_part OPEN_VN STRING_LITERAL VN_SEP item CLOSE_VN	{ $$ = vn->OnBuildId($1, @1, $3, @3, $5); }
			| type_build_id_part OPEN_VN VN_SEP item CLOSE_VN 					{ $$ = vn->OnBuildId($1, @1, wstring(), @3, $4); }

type_builtin_name_part : start_builtin_scope resolved_type_name				{ $$ = $2.as_andata_block; (void)$1; }
type_prerestrict_name_part : start_prerestrict_scope resolved_type_name		{ $$ = $2.as_andata_block; (void)$1; }
type_id_by_name_part 	: start_id_by_name_scope resolved_type_name			{ $$ = $2.as_andata_block; (void)$1; }
type_build_id_part 		: start_build_id_scope resolved_type_name			{ $$ = $2.as_andata_block; (void)$1; }


// eg "long unsigned int". VN represents this as a single node. We don't want nodes for its constituent parts.
// So, this is the level at which we mix in the VN syntax.
type_specifier_seq	: TYPE_SPECIFIER												{ $$.insert($1); }
					| TYPE_SPECIFIER type_specifier_seq								{ $$ = $2; $$.insert($1); }

//////////////////////////////////////// RESOLVER GLUE /////////////////////////////////////////////
// 2 things going on here:
// - Recogniser can only supply one token, but we can "or" them together using rules.
// - We create Gnomons and give them to the recogniser - their lifetime indicates scopes.


vn_name		: UNICODE_NAME    							{ $$ = $1.as_unicode; }
			| ASCII_NAME								{ $$ = $1.as_unicode; }     
          
// RESOLVED_X is strong i.e. there was definitely a ::. resolved_x is weak and
// doesn't require this. See comment by part_resolve for why we don't need a value from 
// part_resolve. The Gnomon is still around because we *could* use $1 here, so it must be valid.
resolved_name	: part_resolve RESOLVED_NORMAL			{ $$ = $2; }
				| RESOLVED_NORMAL						{ $$ = $1; }

resolved_type_name	: part_resolve RESOLVED_TYPE		{ $$ = $2; }
					| RESOLVED_TYPE						{ $$ = $1; }

// On sight of ::, we inform the recognition layer, which returns a shared_ptr which will 
// expire when the production is complete or an error forces unwind. The naming layer
// keeps weak_ptrs to these and will send us RESOLVED_NORMAL if one exists.
part_resolve	: node_namespace RESOLUTION_OP			{ $$ = make_shared<VN::ResolverGnomon>($1.as_andata_block);
                                                          recogniser->AddGnomon($$); }
    
node_namespace 	: part_resolve NODE_NAMESPACE			{ $$ = $2; }
				| NODE_NAMESPACE						{ $$ = $1; }				      


start_builtin_scope		: BUILT_IN 			{ $$ = make_shared<VN::NodeNameScopeGnomon>(); 
										      recogniser->AddGnomon($$); }
										      
start_prerestrict_scope	: PRERESTRICT		{ $$ = make_shared<VN::NodeNameScopeGnomon>(); 
										      recogniser->AddGnomon($$); }

start_id_by_name_scope	: ID_BY_NAME 		{ $$ = make_shared<VN::NodeNameScopeGnomon>(); 
											  recogniser->AddGnomon($$); }

start_build_id_scope	: BUILDER_ID 		{ $$ = make_shared<VN::NodeNameScopeGnomon>(); 
											  recogniser->AddGnomon($$); }

start_transform_name_scope	: TRANSFORM		{ $$ = make_shared<VN::TransformNameScopeGnomon>(); 
											  recogniser->AddGnomon($$); }

%%
