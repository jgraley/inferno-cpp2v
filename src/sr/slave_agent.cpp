#include "slave_agent.hpp"
#include "helpers/simple_compare.hpp"
#include "search_replace.hpp" 

using namespace SR;

SlaveAgent::SlaveAgent( TreePtr<Node> sp, TreePtr<Node> rp, bool is_search_ ) :
    is_search( is_search_ ),
#ifdef MAKE_SUB_ENGINES
    my_engine( nullptr ),
#else
    my_engine( make_shared<SCREngine>(is_search_) ),
#endif
    search_pattern( sp ),
    replace_pattern( rp )
{
}


PatternQuery SlaveAgent::GetPatternQuery() const
{
    PatternQuery query;
	query.RegisterNormalLink( AsAgent(GetThrough()) );
    return query;
}


void SlaveAgent::RunDecidedQuery( DecidedQueryAgentInterface &query,
                               const TreePtrInterface *px ) const
{
    INDENT("l");
    query.Reset();

    // Check pre-restriction
    CheckLocalMatch(px->get());
    
    // When a slave node seen duriung search, just forward through the "through" path
    query.RegisterNormalLink( AsAgent(GetThrough()), px );
}


void SlaveAgent::TrackingKey( Agent *from )
{
    INDENT("l");
    // Make slaves "invisible" to Overlay key propagation
    DoKey( from->GetCoupled() );
    AsAgent(GetThrough())->TrackingKey(from);   
}


void SlaveAgent::GetGraphInfo( vector<string> *labels, 
                               vector< TreePtr<Node> > *blocks ) const
{
    labels->push_back("through");
    blocks->push_back(GetThrough());
    my_engine->GetGraphInfo( labels, blocks );
}


#ifdef MAKE_SUB_ENGINES
void SlaveAgent::AgentConfigure( const SCREngine *master_engine, SCREngine *my_engine_ )
{
    AgentCommon::AgentConfigure(master_engine);
    my_engine = my_engine_;
}
#else
void SlaveAgent::Configure( const Set<Agent *> &agents_already_configured, const SCREngine *master )
{
    ASSERT(master); // must not be overall master (i.e. NULL)
    const CompareReplace *overall_master = master->GetOverallMaster();
    my_engine->Configure(overall_master, search_pattern, replace_pattern, agents_already_configured, master);
}    
#endif

void SlaveAgent::SetMasterCouplingKeys( const CouplingMap &keys )
{
	master_keys = keys;
}


TreePtr<Node> SlaveAgent::BuildReplaceImpl( TreePtr<Node> keynode )
{
    INDENT("l");
    ASSERT( GetThrough() );   
    
    // Continue current replace operation by following the "through" pointer
    TreePtr<Node> dest = AsAgent(GetThrough())->BuildReplace();
    
    // Tell master engine to fill in any couplings generated by replace-only 
    // nodes resulting from following the "through" pointer
    engine->GatherCouplings( &master_keys );
    
    // Run the slave engine
    (void)my_engine->RepeatingCompareReplace( &dest, &master_keys );   
    
    ASSERT( dest );
    return dest;
}


void SlaveAgent::GetGraphAppearance( bool *bold, string *text, string *shape ) const
{
    ASSERTFAIL(); // Slaves are identified as Engines and plotted seperately. See GetGraphInfo().
    // Note from graph plotter: SearchReplace, CompareReplace, SlaveSearchReplace or 
    // SlaveCompareReplace appear in sharp-cornered rectangles, with the name at the top and the
    // member TreePtr names below. These may be some combination of search, compare, replace and through
    // and their blocks are approximately to the right.
}


shared_ptr<ContainerInterface> SlaveAgent::GetVisibleChildren() const
{
	// it's a slave, so set up a container containing only "through", not "compare" or "replace"
	shared_ptr< Sequence<Node> > seq( new Sequence<Node> );
	seq->push_back( GetThrough() );
	return seq;
}
