#include "slave_agent.hpp"
#include "../search_replace.hpp" 
#include "../scr_engine.hpp"
#include "link.hpp"

using namespace SR;

SlaveAgent::SlaveAgent( TreePtr<Node> sp, TreePtr<Node> rp, bool is_search_ ) :
    is_search( is_search_ ),
    my_scr_engine( nullptr ),
    search_pattern( sp ),
    replace_pattern( rp )
{
}


shared_ptr<PatternQuery> SlaveAgent::GetPatternQuery() const
{
    auto pq = make_shared<PatternQuery>(this);
	pq->RegisterNormalLink( PatternLink(this, GetThrough()) );
    return pq;
}


void SlaveAgent::KeyForOverlay( Agent *from )
{
    INDENT("l");
    // Make slaves "invisible" to Overlay key propagation
    SetKey( from->GetKey() );
    AsAgent((TreePtr<Node>)*GetThrough())->KeyForOverlay(from);   
}


Graphable::Block SlaveAgent::GetGraphBlockInfo( const LinkNamingFunction &lnf,
                                     const NonTrivialPreRestrictionFunction &ntprf ) const
{
	ASSERT( master_scr_engine )("Agent must before configured before graphing");

    Block block = my_scr_engine->GetGraphBlockInfo(lnf, ntprf);
    block.title = "Slave";
    block.sub_blocks.push_front( { "through", 
                                   "",
                                   true,
                                   { { dynamic_cast<Graphable *>(GetThrough()->get()), 
                                       phase == IN_REPLACE_ONLY ? DASHED : SOLID, 
                                       {},
                                       {PatternLink(this, GetThrough()).GetShortName()},
                                       SpecialBase::IsNonTrivialPreRestriction(GetThrough()) } } } );
    return block;
}


void SlaveAgent::ConfigureMyEngine( SCREngine *my_scr_engine_ )
{
    my_scr_engine = my_scr_engine_;
}


void SlaveAgent::SetMasterCouplingKeys( const CouplingKeysMap &keys )
{
	master_keys = keys;
}


TreePtr<Node> SlaveAgent::BuildReplaceImpl()
{
    INDENT("l");
    ASSERT( *GetThrough() );   
    
    // Continue current replace operation by following the "through" pointer
    TreePtr<Node> dest = AsAgent((TreePtr<Node>)*GetThrough())->BuildReplace();
    
    // Tell master engine to fill in any couplings generated by replace-only 
    // nodes resulting from following the "through" pointer
    master_scr_engine->GatherCouplings( &master_keys );
    
    // Run the slave engine
    (void)my_scr_engine->RepeatingCompareReplace( &dest, &master_keys );   
    ASSERT( dest );
    
    master_keys.clear(); // save memory
    
    return dest;
}


list<PatternLink> SlaveAgent::GetVisibleChildren( Path v ) const
{
	// it's a slave, so set up a container containing only "through", not "compare" or "replace"
	list<PatternLink> plinks;
	plinks.push_back( PatternLink(this, GetThrough()) );
	return plinks;
}
