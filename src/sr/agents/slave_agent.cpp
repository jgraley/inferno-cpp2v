#include "slave_agent.hpp"
#include "../search_replace.hpp" 
#include "../scr_engine.hpp"
#include "link.hpp"

using namespace SR;

SlaveAgent::SlaveAgent( TreePtr<Node> sp, TreePtr<Node> rp, bool is_search_ ) :
    is_search( is_search_ ),
    my_scr_engine( nullptr ),
    search_pattern( sp ),
    replace_pattern( rp )
{
}


shared_ptr<PatternQuery> SlaveAgent::GetPatternQuery() const
{
    auto pq = make_shared<PatternQuery>(this);
	pq->RegisterNormalLink( PatternLink(this, GetThrough()) );
    return pq;
}


void SlaveAgent::RunDecidedQueryImpl( DecidedQueryAgentInterface &query,
                                      XLink x ) const
{
    INDENT("l");
    query.Reset();

    // Check pre-restriction
    CheckLocalMatch(x.GetChildX().get());
    
    // When a slave node seen duriung search, just forward through the "through" path
    query.RegisterNormalLink( PatternLink(this, GetThrough()), x ); // Link into X
}


void SlaveAgent::KeyForOverlay( Agent *from )
{
    INDENT("l");
    // Make slaves "invisible" to Overlay key propagation
    SetKey( from->GetKey() );
    AsAgent((TreePtr<Node>)*GetThrough())->KeyForOverlay(from);   
}


Graphable::Block SlaveAgent::GetGraphBlockInfo() const
{
    Block block = my_scr_engine->GetGraphBlockInfo();
    block.title = "Slave";
    block.sub_blocks.push_front( { "through", 
                                   "",
                                   true,
                                   { { (TreePtr<Node>)*GetThrough(),
                                       GetThrough(), 
                                       THROUGH, 
                                       {},
                                       {PatternLink(this, GetThrough()).GetShortName()} } } } );
    return block;
}


void SlaveAgent::AgentConfigure( Phase phase, const SCREngine *master_scr_engine, SCREngine *my_scr_engine_ )
{
    AgentCommon::AgentConfigure( phase, master_scr_engine );
    my_scr_engine = my_scr_engine_;
}


void SlaveAgent::SetMasterCouplingKeys( const CouplingKeysMap &keys )
{
	master_keys = keys;
}


TreePtr<Node> SlaveAgent::BuildReplaceImpl()
{
    INDENT("l");
    ASSERT( *GetThrough() );   
    
    // Continue current replace operation by following the "through" pointer
    TreePtr<Node> dest = AsAgent((TreePtr<Node>)*GetThrough())->BuildReplace();
    
    // Tell master engine to fill in any couplings generated by replace-only 
    // nodes resulting from following the "through" pointer
    master_scr_engine->GatherCouplings( &master_keys );
    
    // Run the slave engine
    (void)my_scr_engine->RepeatingCompareReplace( &dest, &master_keys );   
    ASSERT( dest );
    
    master_keys.clear(); // save memory
    
    return dest;
}


shared_ptr<ContainerInterface> SlaveAgent::GetVisibleChildren( Path v ) const
{
	// it's a slave, so set up a container containing only "through", not "compare" or "replace"
	shared_ptr< Sequence<Node> > seq( new Sequence<Node> );
	seq->push_back( *GetThrough() );
	return seq;
}
