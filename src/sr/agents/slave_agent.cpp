#include "slave_agent.hpp"
#include "../search_replace.hpp" 
#include "../scr_engine.hpp"
#include "link.hpp"

using namespace SR;

SlaveAgent::SlaveAgent( TreePtr<Node> sp, TreePtr<Node> rp, bool is_search_ ) :
    is_search( is_search_ ),
    my_scr_engine( nullptr ),
    search_pattern( sp ),
    replace_pattern( rp )
{
}


shared_ptr<PatternQuery> SlaveAgent::GetPatternQuery() const
{
    auto pq = make_shared<PatternQuery>(this);
	pq->RegisterNormalLink( PatternLink(this, GetThrough()) );
    return pq;
}


void SlaveAgent::RunDecidedQueryImpl( DecidedQueryAgentInterface &query,
                                      XLink x ) const
{
    INDENT("l");
    query.Reset();

    // Check pre-restriction
    CheckLocalMatch(x.GetChildX().get());
    
    // When a slave node seen duriung search, just forward through the "through" path
    query.RegisterNormalLink( PatternLink(this, GetThrough()), x ); // Link into X
}


void SlaveAgent::TrackingKey( Agent *from )
{
    INDENT("l");
    // Make slaves "invisible" to Overlay key propagation
    SetKey( from->GetKey() );
    AsAgent((TreePtr<Node>)*GetThrough())->TrackingKey(from);   
}


list<Graphable::SubBlock> SlaveAgent::GetGraphBlockInfo() const
{
    list<SubBlock> sub_blocks = my_scr_engine->GetGraphBlockInfo();
    sub_blocks.push_front( {"through", (TreePtr<Node>)*GetThrough(), "" } );
    return sub_blocks;
}


void SlaveAgent::AgentConfigure( Phase phase, const SCREngine *master_scr_engine, SCREngine *my_scr_engine_ )
{
    AgentCommon::AgentConfigure( phase, master_scr_engine );
    my_scr_engine = my_scr_engine_;
}


void SlaveAgent::SetMasterCouplingKeys( const CouplingKeysMap &keys )
{
	master_keys = keys;
}


TreePtr<Node> SlaveAgent::BuildReplaceImpl( CouplingKey keylink )
{
    INDENT("l");
    ASSERT( *GetThrough() );   
    
    // Continue current replace operation by following the "through" pointer
    TreePtr<Node> dest = AsAgent((TreePtr<Node>)*GetThrough())->BuildReplace();
    
    // Tell master engine to fill in any couplings generated by replace-only 
    // nodes resulting from following the "through" pointer
    master_scr_engine->GatherCouplings( &master_keys );
    
    // Run the slave engine
    (void)my_scr_engine->RepeatingCompareReplace( &dest, &master_keys );   
    
    ASSERT( dest );
    return dest;
}


void SlaveAgent::GetGraphNodeAppearance( bool *bold, string *text, string *shape ) const
{
    ASSERTFAIL(); // Slaves are identified as Engines and plotted seperately. See GetGraphBlockInfo().
    // Note from graph plotter: SearchReplace, CompareReplace, SlaveSearchReplace or 
    // SlaveCompareReplace appear in sharp-cornered rectangles, with the name at the top and the
    // member TreePtr names below. These may be some combination of search, compare, replace and through
    // and their blocks are approximately to the right.
}


shared_ptr<ContainerInterface> SlaveAgent::GetVisibleChildren( Path v ) const
{
	// it's a slave, so set up a container containing only "through", not "compare" or "replace"
	shared_ptr< Sequence<Node> > seq( new Sequence<Node> );
	seq->push_back( *GetThrough() );
	return seq;
}
