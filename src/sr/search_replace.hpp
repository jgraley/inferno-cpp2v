#ifndef SEARCH_REPLACE_HPP
#define SEARCH_REPLACE_HPP

#include "common/common.hpp"
#include "common/read_args.hpp"
#include "helpers/walk.hpp"
#include "helpers/transformation.hpp"
#include "agent.hpp"
#include "normal_agent.hpp"
#include "search_container_agent.hpp"
#include "green_grass_agent.hpp"
#include "overlay_agent.hpp"
#include "soft_agent.hpp"
#include "star_agent.hpp"
#include "slave_agent.hpp"
#include <set>

/// SR namespace contains the search and replace implementation
namespace SR 
{
class Agent;
class Conjecture;
class SpecialBase;

/// Main implementation of a compare and replace function, that matches at the root of the program tree
class CompareReplace : virtual public InPlaceTransformation, 
                       public Filter 
{  
public:
    // Constructor and destructor. Search and replace patterns and couplings are
    // specified here, so that we have a fully confiugured functor.
    CompareReplace( TreePtr<Node> cp = TreePtr<Node>(),
                    TreePtr<Node> rp = TreePtr<Node>() );
                    
    // Call this to set the patterns after construction. This should not be virtual since
    // the constructor calls it.
    virtual void Configure( TreePtr<Node> cp,
                            TreePtr<Node> rp = TreePtr<Node>(),
                            const Set<Agent *> &agents_already_configured=Set<Agent *>() );
    
    // Stuff for soft nodes; support this base class in addition to whatever tree intermediate
    // is required. Call GetProgram() if program root needed; call DecidedCompare() to recurse
    // back into the general search algorithm.
    TreePtr<Node> GetContext() const { ASSERT(pcontext&&*pcontext); return *pcontext; }

    TreePtr<Node> pattern;
    const CompareReplace *master_ptr;
    TreePtr<Node> *pcontext;
    mutable Set< TreePtr<Node> > dirty_grass;
    Set<Agent *> my_agents;
    
    // Sets of nodes for debugging purposes. Checks should be positive, because identifiers are copied
    // shallowly and will appear in more than one set. Since they are const, preservation rules do not
    // apply to identifiers. Only use these when ReadArgs::assert_pedigree is true.
    Set< TreePtr<Node> > pattern_pedigree;            // Nodes from the replace pattern 
    mutable Set< TreePtr<Node> > duplicated_pedigree; // Nodes generated by duplication in replace 
    mutable Set< TreePtr<Node> > keyed_pedigree;      // Nodes found in coupling keys, essentially the input
    
    virtual void GetGraphInfo( vector<string> *labels, 
                               vector< TreePtr<Node> > *links ) const;

    static void SetMaxReps( int n, bool e ) { repetitions=n; rep_error=e; }
    const CompareReplace * GetOverallMaster() const
    {
        const CompareReplace *m = this;
        while( m->master_ptr )
            m = m->master_ptr;
        return m;
    }

private:
    static int repetitions;
    static bool rep_error;
private:

    friend class Conjecture;
public:

    bool Compare( const TreePtrInterface &x,
                  TreePtr<Node> pattern ) const;
    virtual bool IsMatch( TreePtr<Node> context,       
                          TreePtr<Node> root );
public:
    TreePtr<Node> BuildReplace( TreePtr<Node> pattern ) const;
private:
    void KeyReplaceNodes( TreePtr<Node> pattern ) const;
    TreePtr<Node> ReplacePhase( TreePtr<Node> x ) const;

    bool SingleCompareReplace( TreePtr<Node> *proot );
    int RepeatingCompareReplace( TreePtr<Node> *proot );
public:
    // Functor style interface for RepeatingSearchReplace; implements Pass interface.
    using Transformation::operator();
    void operator()( TreePtr<Node> context, 
                     TreePtr<Node> *proot );

	friend class NormalAgent;
};


/// Main implementation of a search and replace function, that matches anywhere in program tree
class SearchReplace : public CompareReplace
{
public:
    SearchReplace( TreePtr<Node> sp = TreePtr<Node>(),
                   TreePtr<Node> rp = TreePtr<Node>() );
                   
    virtual void Configure( TreePtr<Node> sp,
                            TreePtr<Node> rp = TreePtr<Node>(),
                            const Set<Agent *> &agents_already_configured=Set<Agent *>() );
                    
    virtual void GetGraphInfo( vector<string> *labels, 
                               vector< TreePtr<Node> > *links ) const;
};

};

#endif

