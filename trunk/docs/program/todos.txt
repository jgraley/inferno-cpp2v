TODO list (to get the sequential phase looking good)

NestedSubscript on rvalue (m slave) spins on the generated lmap subscript, generates infinity
    - NestedSubscript should not hit these because the relationship is though the index, investigate more...
    - Could add a "depth" integer to the NestedArray/NEstedSubscript nodes. These would then need to be full softnodes.
    - Could just enforce the type, since this changes.

In recursive test case, we are hitting the stack array. 
    - Need to do better than just "typeof integer" - we should try to match the whole lmap array
    - Ideally including the "const" but "const" is broken atm anyway

Add the Lookup skipping node to the pattern, so we can put label-vars into struct members. 
    - Put it immediately under NestedSubscript

Do a new test case with complicated mixtures of array and struct containing the label var, make sure it works!




Sweep for TODOs in code, but quite high theshold
Get web page to reference all the docs 
   - including this one

figure out how to keep using the non-SC tests

more reduction of reliance on Module - SC detection should be changed to not only work in Modules.

sc_signal support
   - maybe just replace all fundy types
   - not sure where to put, earlier means new vars generated after step, later reduces usefulness of trace
   - allowed everywhere though
   - sc_signal for enums to be only just wide enough - make sure this works with state variables

sc_trace for all sc_signals so they appear in VCD files (VCD trace otherwise done)
   - due to statically declared modules strategy, output name must be trace.vcd, so move in test.sh etc

fix steps with too-strong "and-not" clauses 
   - like UseTempForReturnValue, for example 

assertions for redundant intermediates? - no, builtin_return_address() will not match link label if there's caller-side epilog code

tidy-up step to move module member temps back down into a function temp where possible (sensiblising)

deal with returning from a thread module correctly (for elegance mostly)
   - SC terminates when no pending events
   - need to be able to exit the superloop in a SC_THREAD
   - and fail to next_trigger() in SC_MEHTOD
   - I think we already generate explicit return statements, so act on these during ThreadToMethod
   
get rid of Callable, CallableParams, Procedure etc. It's all guff. Just have Function

add ability to lower wait(X) into yielding wait loop 
   - not really critical at this stage, but makes the intention clearer for SC users
   - moved out of 0.2, not actually sure if belongs in sequential phase

new Transformation interface, allows returning a bool for "hit or missed" result (ie xformations used for emasurement)
   - Make a "keep going until miss" meta-transformation, maybe use in S&R, definitely for cleanups

make node-specific graphing be based on virtual functions in nodes, so that graph plotter does not need so many deps
   - problem with hacky code in graph plotter that needs to decide when to recurse

step to get the parameters of a function together into a single struct
   - use this just before the step that passes params via temp, that way no need for additional temp

function merging would be lighter touch if the callee was inserted near the first call point, not at the end
   - obviously, the return label should lie below the inserted function
   - manifestly no iteration for a call when only one call point 
   - would tend to leave a top level superloop in place

do not lower a manifest superloop if it is compatible with conversion directly to Method
   - need to choose cannonical form, probably do...while(cond);
   
the handling of "const" is completely wrong, fix it 
   - it should be a property of types, not of instances
   - so that in pointer decls, const canb e applied correctly to the pointer and/or pointed-to object
   - present impl is wrong - a Const decl of a pointer renders to making the pointed-to item const
   - by the way, is const the same as single-static-assignment?
   
now that we have SimpleCompare factored out of S&R, why not also factor out a SimpleDuplicate for program tree->program tree duplication?
   - but don't use for Stuff node substitution, because that terminates back into pattern subst!

introduce intermediate called Departure, a base for Goto, Return, Break, Continue, Cease, Exit etc
   - and maybe Arrival for labels?
