Glossary
--------

Context - the working data required for a computer to execute code. This includes program counter, stack and possibly other data. Where multiple contexts are present it is possible to switch between them explicitly. Contexts resemble threads without pre-emption and may be implemented easily using threads. Coroutines and cooperative multitasking are other terms for contexts.

Event - a primitive concept of a link in the cause-and-effect chain within a system. Usually, it is one part of the system waking some other part and the process is nominally instantaneous. Events do not include data.

Forwarding - a forwarding function f simply invokes another function g with the same parameter values and returns g's return value. They add nothing to the program in that form, but may become something useful when subjected to later transformation steps.

Functrino - a function call generated in intermediate styles which corresponds to a single phase within a transaction. Since that transaction itself probably represents a function call in the original program, we choose to use a different word. Functions map to functrinos on a 1:N basis where N is 2 or 4 at different steps.

Heap - an area of memory used for dynamic allocation via malloc() and new().

Invariant - a property of a style or representation of a program that may be introduced by a transformation step and may be required by other steps.

Local - a data item whose lifetime is tied to a scope block. Usually allocated from stack memory. 

Lower - a term from compiler design which refers to removing a construct and re-implementing the same functionality using lower level constructs.

Memberise - to convert soemthing into a class member.

Phase, N-phase - an N-phase transaction completes after N specific events have occurred, possibly with time delays between them.

POD - Plain Old Data - data consisting of fundamental types, pointers and arrays of fundamental types but not instances of objects.

Queue, N-queue - classification of event propogation mechanisms via analogy to FIFO queues. A 0-queue event resembles a FIFO of length 0 because it cannot store the event and so blocks both waker and wakee forcing a rendez-vous. A 1-queue event permits waker to return immediately if empty and wakee to return immediately if full.

Scope - a funciton or section of a function delimited by braces {} in C/C++ or various mechanisms including begin/end in Verilog. Scopes must end in the opposite order they began which permits local variables to be allocated on a stack as well as supporting structured programming.  

Sequential - in reference to an algorithm, sequential implies that the algorithm may be broken up into a sequence of operations performed one after the other over time. Outputs from earlier operations are stored and then provided as inputs to later operations.

Server - a group of one or more member functions and POD data members from within a single object. Every member funciton and POD member datum must belong to a server. Therefore servers form a hierarchical layer between objects and functions/data. The server level is the boundary between sequential and structural mapping approaches.

Staticise, static - data and objects whose existence is inferred before execution and which exist throughout execution. Their method of allocation is basically invisible to the program itself.

Structural - in reference to a system, structure descibes the hierarchical breakdown into concurrently-existing subsystems, the topology of their interconnections and protocols for communication.

Style - a choice of programming constructions to use when representing a program; the course-grained aspect of program representation. Intermediate styles are ones passed through during transformation but that do not appear in the input C++ or output Verilog.

Thunk - a forwarding function

Transaction - a well-defined interaction between two servers in which events and data may be exchanged. A function call becomes a transaction when caller and callee are regarded as seperate, concurrent servers.

Transformation step - a part of the mid-level design of the code translation algorithm which performs a specified, relatively simple, transformation on the code such that the code may be sucessfully executed for test purposes before and after.
