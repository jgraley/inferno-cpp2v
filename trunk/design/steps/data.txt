(C) Copyright 2006 John Graley
Available under the terms of the BSD license. 

Data Phase - Steps for data staticisation including dealing with pointers

C++ and most software languages provide a dazzling array of different ways in
which data may be allocated and accessed: statics, locals, members, dynamic
allocation. Pointers and references may be added as additional ways of accessing
data that has been allocated by some other means.

Verilog provides two methods: registers, which are a hardware primitive, and
intermediate values in procedural blocks, which are removed during combing-out.

We must reconcile this discrepancy. Registers resemble statics and we rely on
that correspondence throughout the process. Procedural block intermediates
resemble locals, but are less expressive since they do not persist across as
many different kinds of operations as locals do (locals within main() have
nearly whole-program lifetime) therefore we choose not to maintain that
correspondence.

The solution is to convert all of the aforementioned C++ data formats into
static allocation and direct (static-style) access.

In early versions of the design, the lowering of C++ data was close to the
lowering of corresponding code and there would not have been an identifiable
data phase. However, maintining support for such constructs varied from
confusing to impossible during structural and other data steps (pointers in
particular). So they gravitated up to a position just below the C++-specific
phase. See extensive notes in design forum and against tasks.

Losing familiar data mechanisms may be inconvenient in later steps, and in a
couple of cases there is a little smear, but this is the lesser evil.

We therefore propose a phase in which dynamic data, locals, pointer and
references are all lowered into static data and direct accesses. Member data
does not need attention because by induction if top-level objects are all static
then members are effectively static and members of members etc.

This phase uses purely software implementations (test executables are just C++)
like the C++ phase before it. However, we are now moving away from a style that
con reasonably be called a natural software style, due to the hoops we must now
jump through to deal with the absence of C++ data formats.

Dynamic allocation is dealt with by building dynamic allocation pools. At this
point, we still have pointers so the pools only need to release a pointer to the
allocated object. We prefer to allocate by object to be consistent with the
general thesis of keeping objects self-sufficient, physically containing their
own data and functions.

Locals are handled by the introduction of explicit stacks. Originally, stack
creation was seen as part of the sequential phase, but analysis revealed that
the need to eliminate locals was much more urgent then the need to state-out. We
do so simply by creating a data structure containing all required locals and
then implementing an explicit stack which is then declared as a member. This
should be sufficient to support all forms of recursion that may be present in
the program at the cost of a little multiplexing.

Set/get functions are created for all data members and have the same public/
privateness. These are used for setting/getting data in all cases.

The most complex part of this phase is the pointer solution - this will be the
most work - and so keeping it in a pure SW implementation is a welcome
simplification. We lower pointers at a local level by simply enumerating
variables. This enum corresponds to an address that is valid only at a local
level. When pointers are passed between objects, the recipient treats the
pointer like a black box and passes the pointer beck to the object that supplied
it (we call that object the referee) for dereferencing. This is called
referring-back. When applied recursively, this ensures that all dereferences can
be carried out locally. The resulting increase in the number of inter-object
calls is believed essential to turn a pointer-rich C++ program into a
distributed system as required by the project's philosophy.

Further, when a dereference precedes a member call on the dereferenced object
(eg p->foo()) we choose to refer-back a package of work including the deref and
the call itself. Conceptually this amounts to bringing the action to the object
(as opposed to bringing the object to the action). We prefer to pass the
parameters of the call than to try and move or copy the dereferenced object to
the dereferencing code. In fact, it is now not necessary to move objects around
at all, which fits in with the idea of generating physical hardware for each
object.

We don't really have an answer to casting as yet; most likely, it will be
supported at some cost in efficiency (though cast-to-base-type should be
efficient).

The steps in this phase follow...


----------------------------------------------------------------------------
Staticise heap

Explicitly implement new/delete to allocate objects from pools implemented as 
static arrays. A separate pool will be needed for each data type that may be 
newed. Array new (new[x]) should also be supported and since the size is a 
runtime variable, fragmentation may occur. Fundamental types should be 
supported with one pool for each sizeof() value.

Each pool will be implemented as a C++ class containing the new and delete 
functions and the array of allocatable objects. This class will have one static 
global instance.

Invariant: No dynamic allocation. All const-member pointers are now globally
constant.

Note: No need to worry about constructors/destructors since they should have
been dealt with in the cplusplus phase. We only need to implement the actual
allocation.

todo: Maybe place inside an existing class if use cases are all within that class 
and its members, to increase locality.

Note: Q: do we not want to use a template over allocated type for this? 
A: No we don't because we can generate code and repeated patterns such as 
this are easy. Code generation is like templates but a bazillion
times more powerful and a gazillion times more readable. Templates would 
be useful if we were trying to use inversion, but we aren't.

Note: The required size of the pool depends on run-time considerations. 
If known, it may be hinted by the programmer. Otherwise it must be determined
by testing (possibly with an "engineering margin"). Finally, a caching approach
based on casting to an array of some fundamental type may be considered, but it
will be very inefficient.

todo: tactics for new on specified size types/bitfields

Example output for call to new and delete:

void f()
{
    A *a_ptr = type_A_allocator.New(); // was new A;
    
    ...blah...
    
    type_A_allocator.Delete( a_ptr ); 
}

Example implementation (details omitted):

static class
{
public:
    A *New() { ...find one with allocated==false; set allocated=true... }
    void Delete(A *) { ...set allocated=false... }
    
private:
    struct { A object, bool allocated } pool[A_SIZE];

} type_A_allocator;


----------------------------------------------------------------------------
Eliminate this->

Remove dereferences through the "this" pointer or any const pointer known 
equal to "this".

Invariant: All known accesses to something in the same module do not use
pointers.

Note: Strictly an optimisation, but the invariant helps to clarify.

----------------------------------------------------------------------------
Create global object

Enclose everything at global scope and all statics (base level and in classes)
with a single class that has a single instance. Rename statics based on 
compilation unit name or class name to avoid name conflicts.

Invariant: everything is in a class/object.

Example output:

class
{
public:
    int temp_input; // int temp from source file input.c
    int temp_output; // int temp from source file output.c
    ...
} global;

----------------------------------------------------------------------------
Use get()/set()

Generate a set and a get function for each public member of a class. Make 
the set/get functions public and make the data member private. Use these 
functions for all direct (non-pointer) accesses between objects. Internal
usage may be left alone.

Invariant: every inter-object interaction is a function call; all data members
private.

Note: trivial get/set functions are considered bad style since they're no better
than just making the member public. We only do this for the invariant which
helps later on.

Note: just classes, not structs.

Note: do all non-private data members, regardless of whether they actually get
used.

Note: no point in using these for internal accesses as we get no new invariant
from doing that - either way local member functions are accessing local member
data.

Note: this step is best done before the pointers lowering so that the pointer
steps can rely on the invariant given here. This slightly simplifies the search
for incoming/outgoing pointers.

Example output:

class A
{
public:
    A Get_a() { return a; }      // new accessor
    void Set_a(A _a) { a = _a; } // new modifier
private:      
    A a; // used to be public
};

----------------------------------------------------------------------------
Lower NULL pointers

Replace every pointer with a non-null pointer and a bool. If the bool
is false, the pointer is considered NULL. Otherwise the pointer is not NULL and
it may be dereferenced.

Invariant: all pointers are non-NULL

Example declaration and usage:

void f()
{
   struct { A *non_null_ptr, bool is_null } a_ptr; // used to be A *a;

   if( ...stuff... ) // determine whether object x exists
   {
       a_ptr.is_null = false;   // a_ptr = &x;
       a_ptr.non_null_ptr = &x; // ...
   }
   else
   {
       a_ptr.is_null = true; // a_ptr = NULL;
   }
   
   if( !a_ptr.is_null ) // was if( a != NULL )
   {
      a_ptr.non_null_ptr->g(); // was a_ptr->g();
   }
}

----------------------------------------------------------------------------
Lower pointer arithmetic

Associate every pointer with an int, which begins at zero, and is then
the subject of all pointer arithmetic. Then use array style for derefs. 

Invariant: No pointer arithmetic; pointers only created and overwritten

Note: try to merge with the above struct if easy, otherwise just add 
a new surrounding struct.

Note: this assumes that you can't go off the end of an array legally, which
is true iff the relative locations of separate data items (including arrays) 
are undefined. We rely on the assumption that the SW is written to not assume
otherwise. 

Example declaration and usage:

void f()
{
   struct { A *non_null_ptr, bool is_null, int index } a_ptr;

   a_ptr.index++; // was a_ptr++; 
   y = a_ptr.non_null_ptr[x]; // was y = a_ptr[x]; 
   return a_ptr.non_null_ptr[a_ptr.index]; // was return *a_ptr; 
}


----------------------------------------------------------------------------
Lower references

Implement references using pointers

Invariant: no references

Note: do this after lowering NULL and pointer arithmetic because the pointers
that we will generate for refs don't need to support either of these things. 
This is why this step is not part of the cplusplus phase.

@todo maybe we can turn pointers into refs instead of refs into pointers.

Example output:

void f( A *r ) // used to be f( A &r )
{
    r->Thang(); // used to be r.Thang();
}

----------------------------------------------------------------------------
Memberise locals

Add a stack pointer for each member function in each class. It should be an 
integer member variable big enough to represent the max recursion depth. Add
code to increment the stack pointer on entry and decrement on leaving the 
corresponding function. Add code to initialise the stack pointers to the 
constructor function.

For each local variable, move the variable to be a private class member 
(uniquified for the function it came from), and make it an array. Update 
every access in the function to index the array using the function's stack 
pointer.

Invariant: all variables are static or members

Note: we have to do this before any SystemC stuff, because it needs all objects
to be static (or members). But we will add more locals later on and so this step
will be repeated. Hopefully re-use implementation!

Note: furthermore, "add dereferencing layer" lowering needs *all* locals to be
memberised first, so moved up again and now applies to all locals

Note: arrays of raw variables are a supported primative right through into the
verilog phase, so we're allowed to leave them lying around at the end of this 
phase.

todo: detect "leaf scopes" where there are no outgoing function calls during
the scope of a local. Do not stack these but just make them class members.

Example output:

class A
{
     int x_f_stack[A_f_STACKSIZE]; 
     B b_f_stack[A_f_STACKSIZE]; 
	  int f_stack_pointer;
	  
	  void f()
	  {
	      // was int x; 
		   // was B b; 
		   f_stack_pointer++; // on entry
	      
	      g( x_f_stack[f_stack_pointer] ); // was g( x );
	      b_f_stack[f_stack_pointer].h(); // was b.h();
	      
	      ...maybe recurse f here...
	      
	      f_stack_pointer--; // on exit
	  }
	  
	  A()
	  {
	      // init stack pointers
	      f_stack_pointer=-1; // it gets incremented on the first call 
		                       // (though the actual init value doesn't really matter)
	  }
};


----------------------------------------------------------------------------
Add class-level dereferencing layer

Add functions to each class C, for each public member function in each class 
dereferenced in C, which forward function calls to the object that was the 
subject of the dereference. So if objects a and b of class D have a function 
footle( int x ) and we take the address of either a or b in any member function
of the current class, then we create deref_D_footle( D *p, int x ) which invokes 
the correct footle() based on the value of p.

For raw data types add eg deref_int_get( int *p ) and deref_int_set( int * p, 
int val ). These should call through to the corresponding get and set functions
introduced in an earlier step.
 
Replace all pointer dereferences and through-pointer invocations with the 
corresponding local deref function. 

Deref functions should be implemented to use switch() on the pointer value using
case values that are explicitly taken addresses. Cast to int if necessary to
compile this.

Invariant: class explicitly handles all derefs of data whose address is 
taken by the class.

Note: p->f() and equivalently (*p).f() should *not* be broken down into the *p
and the .f() but should be treated as a unit (becomes deref_type_f(p)). Because 
of this, there's no need to copy the data because we always bring the action to 
the data, not the other way around

todo: member function pointers

todo: pointers to array elements

Example output:

int x;

class A
{
    int y;
        
    void f()
    {
        int *p = &x;
   
        ... maybe modify p, but in accordance with this step...
     
        WriteIntThroughPtr( p, 99 ); // was *p = 99;
    }
    
    // completely new function
    void WriteIntThroughPtr( int *p, int newval )
    {
        switch( p )
        {
        case &x:
            x = newval;
            break;
        case &y:
            y = newval;
            break;
        }
    }    
};

----------------------------------------------------------------------------
Refer-back pointers

With each pointer, associate an enum representing (a) whether the pointer was
taken locally and if not, (b) which object it came from. Or just add values to 
the enum created in a previous step. 

A pointer can come from another object if it is a parameter in an incoming
function call, or the return value of an outgoing call. Either way, the object 
that supplied the pointer is the referee object. 

Multiple objects of the same class must have different values in the enum. This
can be achieved with a primitive for now (perhaps using the actual address or
a static counter) and will have to be implemented in Verilog using eg module
paraemters.

Create referral functions that decode the pointer and then forward the call 
to either (a) the deref function or (b) the corresponding referral function
in the referee object. Referral functions should be created when a pointer
that came from another object must be dereferenced or passed to a third 
external object.

We can receive a pointer from an external object when either (a) we expose
a public member function that accepts a pointer as a parameter (or member
of a parameter if parameter is a struct) or (b) there is an outgoing call
somewhere in our member functions to a member function of another object
that is declared to return a pointer (or a struct containing a pointer).

The converse applies to determine when we can pass pointers to other objects.

Note: this new call may pass some other pointer, in which case the referee
object may gain a new enum value for which the original object is referee.
Therefore this step must iterate until no more new referral calls are
required. Only two referral functions are needed between each pair of objects for
any given pointed-to type (one in each direction) so the iterations will
terminate.

Note: This step is the only pointers step that affects class interfaces. In 
all cases, a class interface is extended based on that classes' declaration
and implementation, and the declarations of any classes it can call into.
Apart from the need to seed different objects with different pointer values,
every object of a class can be identical.

Invariant: all inter-object calls are now implemented via direct calls 

Note: new call also needs a backchannel

todo: object pointers need to be distinct for objects in the same virtual 
hierarchy so that they can be used interchangably.

todo consider splitting out the part that establishes the referral relationships
from the part that creates the enums. The first part would be recursive and
would build structs containing the pointer from the deref step as well as object 
pointers for referring back. Then the second step would replace with enums.

Example output:

enum { A } Referee; // give an ID to the object A so it can be a referee for
pointer dereferences.

class A
{
    C x; // unchanged
    void f() 
    {
        a.TakeAPointer( A, &x ); // was a.TakeAPointer( &x ); now need to pass
our id.
    }
    
    void ReferFoo( C *ptr, int param )  // new code; handles derefs on the
pointer we supplied to B (when calling foo, in this example)
    {
        ptr->foo( param ); // Only dereferencing locally.
    }
    
} a;

class B
{
    struct ExtCPtr { C *external_ptr, Referee referee_id } ptr;
    void TakeAPointer( Referee id, C *p )
    {
        ptr.external_ptr = p;
	  ptr.referee_id = id; // remember both!
    }
    
    void f()
    {
        // now time to try and use the pointer
	  CallFooThroughExternalCPtr( ptr, 9 ); // used to be ptr->foo(9);
    }
    
    void CallFooThroughExternalCPtr( ExtCPtr p, int param ) // new code
    {
        switch( p.referee_id )
	  {
	  case A: // identify the referee object...
	      a.ReferFoo( p.external_ptr, param ); // ...then get it to do the deref
and the call to foo().
	      break;	     
 	  } 
    }
} b;

----------------------------------------------------------------------------
Enumerate addresses

For each class, create an enum with a different value for each object whose
address gets taken within the class' member functions. Substitute the enum 
value for the address. This includes taking the address of objects ouside 
the current object.

Example output:

int x;

class A
{
    int y;
    
    enum{ ADDRESSOF_GLOBAL_X, ADDRESSOF_Y } Local_Int_Ptr; // anything whose
                                                           // address we take using &
    
    void f()
    {
        Local_Int_Ptr p = ADDRESSOF_GLOBAL_X; // was int *p = &x;
   
        ... maybe modify p, but in accordance with this step...
     
        WriteIntThroughPtr( p, 99 ); // was *p = 99;
    }
    
    // deref function
    void WriteIntThroughPtr( Local_Int_Ptr p, int newval )
    {
        switch( p )
        {
        case ADDRESSOF_GLOBAL_X:
            x = newval;
            break;
        case ADDRESSOF_Y:
            y = newval;
            break;
        }
    }    
};
