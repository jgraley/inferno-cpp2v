(C) Copyright 2006 John Graley
Available under the terms of the BSD license. 

Data Phase - Steps for data staticisation including dealing with pointers

C++ and most software languages provide a dazzling array of different ways in
which data may be allocated and accessed: statics, locals, members, dynamic
allocation. Pointers and references may be added as additional ways of accessing
data that has been allocated by some other means.

Verilog provides two methods: registers, which are a hardware primitive, and
intermediate values in procedural blocks, which are removed during combing-out.

We must reconcile this discrepancy. Registers resemble statics and we rely on
that correspondence throughout the process. Procedural block intermediates
resemble locals, but are less expressive since they do not persist across as
many different kinds of operations as locals do (locals within main() have
nearly whole-program lifetime) therefore we choose not to maintain that
correspondence.

The solution is to convert all of the aforementioned C++ data formats into
static allocation and direct (static-style) access.

In early versions of the design, the lowering of C++ data was close to the
lowering of corresponding code and there would not have been an identifiable
data phase. However, maintining support for such constructs varied from
confusing to impossible during structural and other data steps (pointers in
particular). So they gravitated up to a position just below the C++-specific
phase. See extensive notes in design forum and against tasks.

Losing familiar data mechanisms may be inconvenient in later steps, and in a
couple of cases there is a little smear, but this is the lesser evil.

We therefore propose a phase in which dynamic data, locals, pointer and
references are all lowered into static data and direct accesses. Member data
does not need attention because by induction if top-level objects are all static
then members are effectively static and members of members etc.

This phase uses purely software implementations (test executables are just C++)
like the C++ phase before it. However, we are now moving away from a style that
con reasonably be called a natural software style, due to the hoops we must now
jump through to deal with the absence of C++ data formats.

Dynamic allocation is dealt with by building dynamic allocation pools. At this
point, we still have pointers so the pools only need to release a pointer to the
allocated object. We prefer to allocate by object to be consistent with the
general thesis of keeping objects self-sufficient, physically containing their
own data and functions.

Locals are handled by the introduction of explicit stacks. Originally, stack
creation was seen as part of the sequential phase, but analysis revealed that
the need to eliminate locals was much more urgent then the need to state-out. We
do so simply by creating a data structure containing all required locals and
then implementing an explicit stack which is then declared as a member. This
should be sufficient to support all forms of recursion that may be present in
the program at the cost of a little multiplexing.

The most complex part of this phase is the pointer solution - this will be the
most work - and so keeping it in a pure SW implementation is a welcome
simplification. We lower pointers at a local level by simply enumerating
variables. This enum corresponds to an address that is valid only at a local
level. When pointers are passed between objects, the recipient treats the
pointer like a block box and passes the pointer beck to the object that supplied
it (we call that object the referee) for dereferencing. This is called
referring-back. When applied recursively, this ensures that all dereferences can
be carried out locally. The resulting increase in the number of inter-object
calls is believed essential to turn a pointer-rich C++ program into a
distributed system as required by the project's philosophy.

Further, when a dereference precedes a member call on the dereferenced object
(eg p->foo()) we choose to refer-back a package of work including the deref and
the call itself. Conceptually this amounts to bringing the action to the object
(as opposed to bringing the object to the action). We prefer to pass the
parameters of the call than to try and move or copy the dereferenced object to
the dereferencing code. In fact, it is now not necessary to move objects around
at all, which fits in with the idea of generating physical hardware for each
object.

We don't really have an answer to casting as yet; most likely, it will be
supported at some cost in efficiency (though cast-to-base-type should be
efficient).

One pending issue at the time of writing is the role servers play in the data
phase. I think I want to make objects, not servers, be the designator of data
scope. Thus the relevance of servers is only that we have to decide which server
to put new functions into. This is all TBD.

@todo maybe something for global statics and static members involving making new
classes for them that feature a single instance.

The steps in this phase follow...

----------------------------------------------------------------------------
Staticise heap

Explicitly implement new/delete to allocate objects from static arrays. A 
separate pool will be needed for each data type that may be newed. Array new
(new[x]) should also be supported and since the size is a runtime variable, 
fragmentation may occur. Fundamental types should be supported with one pool for
each sizeof() value.

Invariant: No dynamic allocation. All const-member pointers are now globally
constant.

Note: No need to worry about constructors/destructors since they should have
been dealt with in the cplusplus phase. We only need to implement the actual
allocation.

Note: Maybe place in a class if use cases are all below that class (ie 
coming from member functions or member objects). 

Note: New and delete for a given type, as well as the array itself, go in a
single server.

Note: Q: do we not want to use a template over allocated type for this? 
A: No we don't because we can generate code and repeated patterns such as 
this are easy. Code generation is like templates but a bazillion
times more powerful and a gazillion times more readable. Templates would 
be useful if we were trying to use inversion, but we aren't.

Note: The required size of the pool depends on run-time considerations. 
If known, it may be hinted by the programmer. Otherwise it must be determined
by testing (possibly with an "engineering margin"). Finally, a caching approach
based on casting to an array of some fundamental type may be considered, but it
will be very inefficient.

Example output for call to new and delete:

void f()
{
    A *a_ptr = type_A_allocator.New(); // was new A;
    
    ...blah...
    
    type_A_allocator.Delete( a_ptr ); 
}

Example implementation (details omitted):

static class
{
public:
    A *New() { ...find one with allocated==false; set allocated=true... }
    void Delete() { ...set allocated=false... }
    
private:
    struct { A object, bool allocated } pool[A_SIZE];

} type_A_allocator;


----------------------------------------------------------------------------
Eliminate this->

Remove dereferences through the "this" pointer or any const pointer known 
equal to "this".

Invariant: All known accesses to something in the same module do not use
pointers.

Note: Strictly an optimisation, but the invariant helps to clarify.

----------------------------------------------------------------------------
Use get()/set()

For POD types that are exposed publically, make all inter-object reads
and writes be function calls. New functions go in same server as the public 
member. 

Invariant: every inter-object interaction is a function call

Note: the pointer *could* equal "this", but only if it's non-constant in which
case we must support the possibility that it is not "this".

Note: non-trivial objects get dealt with in other ways, so don't worry about 
them.

Note: trivial get/set functions are considered bat style since they're no better
than just making the member public. We only do this for the invariant which
helps later on.

Example output:

class A
{
public:
    A Get_a() { return a; }      // new accessor
    void Set_a(A _a) { a = _a; } // new modifier
private:      
    A a; // used to be public
};

----------------------------------------------------------------------------
Lower NULL pointers

Replace every pointer with a non-null pointer and a bool. If the bool
is false, the pointer is considered NULL. Otherwise the pointer is not NULL and
it may be dereferenced.

Invariant: all pointers are non-NULL

Example declaration and usage:

void f()
{
   struct { A *non_null_ptr, bool is_null } a_ptr; // used to be A *a;

   if( ...stuff... ) // determine whether object x exists
   {
       a_ptr.is_null = false;   // a_ptr = &x;
       a_ptr.non_null_ptr = &x; // ...
   }
   else
   {
       a_ptr.is_null = true; // a_ptr = NULL;
   }
   
   if( !a_ptr.is_null ) // was if( a != NULL )
   {
      a_ptr.non_null_ptr->g(); // was a_ptr->g();
   }
}

----------------------------------------------------------------------------
Lower pointer arithmetic

Associate every pointer with an int, which begins at zero, and is then
the subject of all pointer arithmetic. Then use array style for derefs. 

Invariant: No pointer arithmetic; pointers only created and overwritten

Note: try to merge with the above struct if easy, otherwise just add 
a new surrounding struct.

Note: this assumes that you can't go off the end of an array legally, which
is true iff the relative locations of separate data items (including arrays) 
are undefined. We rely on the assumption that the SW is written to not assume
otherwise. 

Example declaration and usage:

void f()
{
   struct { A *non_null_ptr, bool is_null, int index } a_ptr;

   a_ptr.index++; // was a_ptr++; 
   y = a_ptr.non_null_ptr[x]; // was y = a_ptr[x]; 
   return a_ptr.non_null_ptr[a_ptr.index]; // was return *a_ptr; 
}


----------------------------------------------------------------------------
Lower references

Implement references using pointers

Invariant: no references

Note: do this after lowering NULL and pointer arithmetic because the pointers
that we will generate for refs don't need to support either of these things. 
This is why this step is not part of the cplusplus phase.

@todo maybe we can turn pointers into refs instead of refs into pointers.

Example output:

void f( A *r ) // used to be f( A &r )
{
    r->Thang(); // used to be r.Thang();
}

----------------------------------------------------------------------------
Memberise locals

Generate a data structure to represent the local variables in each function.
Use unions for variables whose scope does not overlap. Add an array of these 
structures, up to the max nesting depth, as a server member. Create a member 
stack pointer which should be initialised to zero. Increment it at the start 
of the function and decrement just before returning. Change all code to use the 
array indexed by the stack pointer.

Invariant: all variables are static or members

Note: we have to do this before any SystemC stuff, because it needs all objects
to be static (or members). But we will add more locals later on and so this step
will be repeated. Hopefully re-use implementation!

Note: furthermore, "add dereferencing layer" lowering needs *all* locals to be
memberised first, so moved up again and now applies to all locals

@todo initialise stack pointer to 0 - this needs to be a global init

Example output:

class A
{
     struct { int x, B b } f_stack[A_f_STACKSIZE]; 
	  // struct includes all locals from f()
	  int f_stack_pointer;
	  
	  void f()
	  {
	      f_stack_pointer++; // on entry
	      
	      g( f_stack[f_stack_pointer].x ); // was g( x );
	      f_stack[f_stack_pointer].b.h(); // was b.h();
	      
	      ...maybe recurse f here...
	      
	      f_stack_pointer--; // on exit
	  }
};

----------------------------------------------------------------------------
Add class-level dereferencing layer

For each class, create an enum with a value for each usage of & on a distinct object or POD data item. Substitute the enum value for the address. This includes objects ouside the current object.

Add functions to each class, for each enum value, that forward function calls 
to the corresponding object/POD item. So if member objects a and b of type C 
both have a function footle( int x ) then we create deref_footle( C *p, int x ) 
which invokes the correct footle() based on p. For POD types add eg
deref_get( type *p ) and deref_set( type *p, type val ). Replace pointer derefs
with the corresponding function. 

Invariant: class handles all derefs of data whose address is taken by the class.

Note: p->f() and equivalently (*p).f() should *not* be broken down into the *p
and the .f() but should be treated as a unit (becomes deref_f(p))

Note: there's now no need to copy the data because we always bring the
action to the data, not the other way around

Example output:

int x;

class A
{
    int y;
    
    enum{ ADDRESSOF_GLOBAL_X, ADDRESSOF_Y } Local_Int_Ptr; // anything whose
address we take using &
    
    void f()
    {
        Local_Int_Ptr p = ADDRESSOF_GLOBAL_X; // was int *p = &x;
   
        ... maybe modify p, but in accordance with this step...
     
        WriteIntThroughPtr( p, 99 ); // was *p = 99;
    }
    
    // completely new function
    void WriteIntThroughPtr( Local_Int_Ptr p, int newval )
    {
        switch( p )
        {
        case ADDRESSOF_GLOBAL_X:
            x = newval;
            break;
        case ADDRESSOF_Y:
            y = newval;
            break;
        }
    }    
};

----------------------------------------------------------------------------
Refer-back pointers

With each pointer, associate an enum representing (a) whether the pointer was
taken locally and if not, (b) which object it came from. Or just add values to 
the existing enum. This other object is the referee object. 

In case (b) add a deref function that decodes the pointer then forwards the call
to the referee object's dereferencer function. 

Note: this new call may pass some other pointer, in which case the referee
object may gain a new enum value for which the original object is referee.
Therefore this step must iterate until no more new deref calls are
required. Only two deref calls are needed between each pair of objects for
any given pointed-to type (one in each direction) so the iterations will
terminate.

Invariant: all inter-object calls are now implemented via direct calls 

Note: new call also needs a backchannel

@todo maybe the example shouldn't use * and & notation since we got rid of those
in the previous step! In fact, the example is a little ropey - needs looking at 
more.

@todo wondering about using the word "handle" for pointers not defined locally.
In the example, A would see a pointer whereas B would see a handle. The handle
is opaque to B.

Example output:

enum { A } Referee; // give an ID to the object A so it can be a referee for
pointer dereferences.

class A
{
    C x; // unchanged
    void f() 
    {
        a.TakeAPointer( A, &x ); // was a.TakeAPointer( &x ); now need to pass
our id.
    }
    
    void ReferFoo( C *ptr, int param )  // new code; handles derefs on the
pointer we supplied to B (when calling foo, in this example)
    {
        ptr->foo( param ); // Only dereferencing locally.
    }
    
} a;

class B
{
    struct ExtCPtr { C *external_ptr, Referee referee_id } ptr;
    void TakeAPointer( Referee id, C *p )
    {
        ptr.external_ptr = p;
	  ptr.referee_id = id; // remember both!
    }
    
    void f()
    {
        // now time to try and use the pointer
	  CallFooThroughExternalCPtr( ptr, 9 ); // used to be ptr->foo(9);
    }
    
    void CallFooThroughExternalCPtr( ExtCPtr p, int param ) // new code
    {
        switch( p.referee_id )
	  {
	  case A: // identify the referee object...
	      a.ReferFoo( p.external_ptr, param ); // ...then get it to do the deref
and the call to foo().
	      break;	     
 	  } 
    }
} b;



