
(C) Copyright 2006 John Graley
Available under the terms of the BSD license. 


This file lists the steps in the mapping process. Currently rather brief and ambigous I'm afraid, and more detail will go in over time. 

Since this is likely to change repeatedly, it will be kept under version control. Steps are not numbered to avoid the need to renumber after insert or delete; instead they are seperated by long lines of -.

Invariants will usually be the absence of types of constructs or guarantees about behaviour/properties of parts of the system. Occasionally they may be expression of redundancy (duplication of information in the program though guaranteed equivilances) though this is discouraged.


@todo early steps for RTTI, Exceptions

----------------------------------------------------------------------------
Make constructors/destructors explicit

All constructors, copy constructors and destructors get turned into regular member functions and we add explicit calls to them in the code. Need to treat each kind of scope correctly: static, member, heap, local. If an object is passed by value and has a copy constructor, we must turn that into pass by reference and then insert the copy construct call at the top of the function.

Invariant: pass-by-value only for memcpy()able objects; actual object lifecycle may now differ from that in the original program

Note: We choose not to generate any copy constructor if not already there - these objects will be treated like fundamental types

----------------------------------------------------------------------------
Staticise heap

Explicitly implement new/delete to allocate objects from static arrays. Provide dynamic constructors for these objects, and un-const any const pointers in them. 

Invariant: No dynamic allocation. All const-member pointers are now globally constant.

Note: An optimisation would be to detect when certain constructors can still be static and certain members can still be const. 

----------------------------------------------------------------------------
Eliminate this->

Remove dereferences through the "this" pointer or any const pointer equal to "this".

Invariant: All known accesses to something in the same module do not use pointers.

Note: Strictly an optimisation, but the invariant helps to clarify.

----------------------------------------------------------------------------
Use Get()/Set()

For fundamental types that are exposed publically, make all inter-object reads and writes be function calls.

Invariant: every inter-object interaction is a function call

Note: the pointer *could* equal "this", but only if it's non-constant in which case we must support the possibility that it is not "this".

Note: maybe need to do something here for non-trivial objects/structs that lack copy constructors?

----------------------------------------------------------------------------
Call through pointers

Get rid of all direct calls between objects eg x.y() and replace with calls though a constant pointer initialised at construct time.

Invariant: All inter-object calls go through a pointer

----------------------------------------------------------------------------
Outgoing interfaces

Add interfaces to each object to represent the calls it makes to other objects. 

Note: Still not completely sure if we need this.

----------------------------------------------------------------------------
Forward at class boundaries

Any call from a member object to an external object or vice-versa should be forwarded through new thunk functions within the object. These will develop into arbiters. Inter-object calls should now be 1:1 correspondence.

Invariant: Each interface has only one caller

----------------------------------------------------------------------------
Add backchannels

Add a marker of some sort at each interface that refers to its (now unique) caller. This is useful to later steps. A partial check could look at __builtin_return_address().

Invariant: Any static (const pointer) interaction may be reversed

----------------------------------------------------------------------------
Lower NULL pointers

Replace every variable pointer with a non-null pointer and a bool. If the bool is false, the pointer is considered NULL. Otherwise the pointer is not NULL and it may be dereferenced.

Invariant: all pointers are non-NULL

Note: No need to do this to const pointers

----------------------------------------------------------------------------
Lower pointer arithmetic

Associate every variable pointer with an int, which begins at zero, and is then the subject of all pointer arithmetic. Then use array style for derefs. Eg 

p++; return *p; 

becomes 

p.index++; return p[p.index];

Invariant: No pointer arithmetic; pointers only created and overwritten

Note: what about const pointers?

----------------------------------------------------------------------------
Remove references

Implement references using pointers

Invariant: no references

Note: do this after lowering NULL and pointer arithmetic because the pointers that we will generate for refs don't need to support either of these things. 

----------------------------------------------------------------------------
Add dereferencer functions

Add functions to each class, for each type required, that do pointer derefs eg T dereference( T *p, int index ) { return p[index]; }

Invariant: no pointer dereferences outside special dereferencer functions

Note: may need to inline this or return a reference to avoid copying a T.

Note: only do this to variable pointers!

----------------------------------------------------------------------------
Refer variable pointers back to provider

With each pointer, associate an enum representing (a) whether the pointer was taken locally and if not, (b) which interface (hence which other object) it came from. Dereference function should decode this then forward the call to that object's dereferencer function. The new interface is called a deref interface and is made via the (const) backchannel pointer.

Note: this new call may pass a pointer as a param, in which case that object may gain a new enum value and dereferencer object. Therefore this step must iterate until no more new deref interfaces are required. Only two deref interfaces are needed between each pair of objects for each type (one either way) so the iterations will terminate.

Invariant: all inter-object calls are now via const pointers; interpretation of variable pointers is now local

Note: only do this to variable pointers!

Note: new call also needs a backchannel

----------------------------------------------------------------------------
Enumerate local variable pointers

Create an enum for all member objects whose address gets taken. Substitute an enum ie PTR_X for each &x and get the deref function to decode the enum and return x as required.

Note: this includes non-trivial class objects; otherwise taking their address would require a new channel between parent and child that isn't required otherwise and wasn't processed in the "Outgoing interfaces" or "Forward at class boundaries" steps.

Invariant: no variable pointers

Note: not const pointers!!

----------------------------------------------------------------------------
Merge member functions

Merge all the member functions in a class into a single one that uses a big switch statement to select the implementation based on a new enum param. Other parameters should be grouped into a struct for each of the original member functions then unioned together for the big function.

Invariant: all calls are simple recursions

Note: this single function is now the run function. All other calls (apart from SystemC ones which don't count) have now become simple recursions of this function.

Note: moved up to be before memberising local objects

----------------------------------------------------------------------------
Memberise local objects

Generate a data structure to represent the local object variables. Use unions for objects whose scope does not overlap. Add an array of these structures, up to the max nesting depth, as a class member. Create a member stack pointer which should be initialised to zero. Increment it at the start of the function and decrement just before returning. Change all code to use the array indexed by the stack pointer.

Invariant: all objects are static or members

Note: we have to do this before any SystemC stuff, because it needs all objects to be static (or members). But we will add more locals later and so this step will be repeated later. Hopefully re-use implmentation!

----------------------------------------------------------------------------
Change const pointers to ports

Replace Obj *p; with SystemC ports eg sc_port<Obj>.

Invariant: no pointers

Note: this gives us SystemC's "direct TLM" style. 

----------------------------------------------------------------------------
Add local context

Derive all classes from SC_THREAD. Incoming calls should wake the local context and wait for it to complete before returning.

Invariant: no cumulative nesting in calls between objects

Note: this gives us SystemC's "blocking TLM" style. 

Note: Possible major problem here supporting inter-object recursion between this step and the "make transactions non-blocking" step. Since each object's local context "camps" in the other object's function while awaiting completion of the call it is not straightforward for it to resume chacking for incoming calls while waiting. Solution is to employ a pool of contexts for each object and use a "wake one waiter" event mechanism to ensure we select one waiting context for each incoming call. Hopefully SystemC supports this.

----------------------------------------------------------------------------
Move to 2-phase transactions

Turn incoming calls into "fake" nonblocking by adding a return call (via backchannel) after the waits, just before the original called function returns. Outgoing calls should wait after making the initial call and then kick themselves in the return function.

Invariant: no return values on inter-object calls

Note: Since the return call and the kick will come *before* the outgoing call returns and the wait begins (which is why we call it fake) the semaphore should be 1-in-1-out.

----------------------------------------------------------------------------
Make transactions non-blocking

The incoming call should return immediately after kicking the local context. The local context should still kick the caller's thread on completion - only difference is that the caller is now waiting in its own code.

Invariant: all inter-object calls are notionally instantaneous

Note: this gives us SystemC's "non-blocking TLM" style. 

Note: Now reduce to one local context. Wait for outgoing calls to return by recursing back into the context's executive function. This supports recursive calls.

----------------------------------------------------------------------------
Passivate

Create a pure "channel" object for each pair of objects that interact (call each other). Provide it with purely passive 2-phase interfaces for caller and callee such that all calls between objects go into the channel and the channel kicks (wakes up) the objects when something interesting happens.

Invariant: objects do not receive incoming calls

----------------------------------------------------------------------------
Insert clock and reset

Move all classes to SC_CTHREAD. Replace all wait(event) with while(!event) wait(clk).

Invariant: clock edge is the only event

Note: not sure about clock distribution or how to handle reset.

Note: might be able to do this step later if waits are implemented as "send event to self" type loops - iterations of that loop can then become clock periods after all the stating-out.

----------------------------------------------------------------------------
Lower constructs

Lower constructs that are not supported in combable (synthesisable) verilog into conditional branches ie if(cond) goto label; Also after each wait(); add a goto WAIT_STATE; WAIT_STATE:; 

Invariant: all constructs synthesisable or trivially stated-out

Note: there's some flexibility here in how much stuff we lower. It corresponds to design tradeoffs in the final HW. Any construct surrounding a label must itself be lowered. 

Note: retain local scope structure for now

----------------------------------------------------------------------------
Add state variable

Add an enum with a value for each label, add a local variable of that type called state and maintain it correctly by assigning to it immediately before each goto. Initialise to eg INIT_STATE at start of function.

Note: assert this at each label as a double check since we have a little redundancy at this point.

Note: the point of this is to establish the state as local, i.e. needs to be stacked when we recurse.

----------------------------------------------------------------------------
Memberise locals

Generate a data structure to represent the local variables. Use unions for variables whose scope does not overlap. Add an array of these structures, up to the max nesting depth, as a class member. Create a member stack pointer which should be initialised to zero. Increment it at the start of the function and decrement just before returning. Change all code to use the array indexed by the stack pointer.

Invariant: all data is static or member

Note: includes state

Note: the same step was done on object type locals earlier on - try to build new locals into same structure.

----------------------------------------------------------------------------
Remove scopes

Scoped blocks (surrounded by {}) should now be completely redundant. Get rid of them.

Note: was part of memberise locals, but now that step has to be run twice and the first time doesn't want to do this.

Invariant: No scopes (apart from overall function scope)

----------------------------------------------------------------------------
Lower recursion

Turn each recursion call point into a goto to the start of the function and at the very end of the function insert a goto to the label implied by the state variable.
 
Invariant: no recursion; no non-trivial function calls 

Note: the "goto a variable" construct would have to become eg a switch statement for the purposes of testing this step. It vanishes in the "State-out" step.

----------------------------------------------------------------------------
State-out

Surround the entire function with a switch statement on the state variable. Generate a case for each label. Unconditional gotos should terminate states (any code between them and the next label is unreachable). Conditional gotos should place any following code in their "else" clause. The actual gotos may then be removed, leaving only the assignments to the state variable. 

Invariant: context is released between each combable block

Note: Place an infinite loop around the switch statement if SC_CTHREAD doesn't do so for you.

----------------------------------------------------------------------------
Extract waits

Replace all wait() calls with a single one at the bottom of the function (inside the overall loop if one was added).

Invariant: no non-trivial context across a wait()

----------------------------------------------------------------------------
Remove local context

Move to SC_METHOD. If an overall loop was needed, remove it. Also remove the wait() call.

Invariant: no persistent implicit context

----------------------------------------------------------------------------
Initialise data

All initialised statics to be initialised in a "initial" block.

Invariant: no inline initialisation

Note: how do initial blocks in SC?

----------------------------------------------------------------------------
Lower types

Convert types like char, int into bit vectors. Support bit fields properly. Bool becomes a 1-bit type. 

Invariant: no types unknown to Verilog

Note: we will hopefully be able to tolerate arbitrary bit vectors in SC form eg sc_bitvec<5> all the way through the process.


@todo late steps for dealing with wire vs latch vs flip-flop
