
(C) Copyright 2006 John Graley
Available under the terms of the BSD license. 


This file lists the steps in the mapping process. Currently rather brief and 
ambiguous I'm afraid, and more detail will go in over time. 

Since this is likely to change repeatedly, it will be kept under version
control. 
Steps are not numbered to avoid the need to renumber after insert or delete; 
instead they are separated by long lines of -.

Invariants will usually be the absence of types of constructs or guarantees
about behaviour/properties of parts of the system. Occasionally they may be
expression of redundancy (duplication of information in the program though
guaranteed equivalences) though this is discouraged.


----------------------------------------------------------------------------
Expand templates

Expand all template instantiations. 

Invariant: no templates

Note: this will make the program bigger, but that's what templates do to
programs anyway.

----------------------------------------------------------------------------
Remove stack unwind

Whenever a function can throw an exception, arrange for the function to catch 
all exceptions and return the exception object. If a return value exists already
then combine in a struct. Returned object should be a null object if there was 
no exception. 

Calls to such functions should be in try blocks and if an exception is returned
then they should be rethrown.

Invariant: return is the only path out of a function

----------------------------------------------------------------------------
Lower try/throw/catch

Remove try and catch keywords leaving pairs of plain scopes. Insert a goto 
to skip what used to be the catch block. Convert throw into a goto to the
beginning of the catch block. Use a local to hold the exception object. 

Invariant: no exceptions

Note: this step could be moved down to state-out if required: the above
"Remove stack unwind" is the part that has to be done early.

Note: the additional destructor calls implied here get added in the "Make
constructors/destructors explicit" step further down. This is triggered by the
gotos.

----------------------------------------------------------------------------
Implement run-time type information

Implement typeof and dynamic_cast as virtual member functions within 
class hierarchies and modify calls to be member function calls.

Invariant: no RTTI

----------------------------------------------------------------------------
Expand inheritance

Where class B inherits from class A, copy non-overridden functions from A
to B. Also copy any functions that are overridden but get called explicitly
via eg A::f()

Invariant: no inheritance

Note: Need a strategy for multiple inheritance

Note: Duplicating the functions seems wasteful but it isn't: all the 
functions get duplicated per-object anyway.

----------------------------------------------------------------------------
Specify servers

Determine (by whatever means) how the member functions and trivial 
(non-object) member variables will be divided up into servers. Insert servers
as a hierarchical level between class level and individual functions and POD
data members.

Invariant: Sequential/structural divide now explicit 

Note: Test code generation should strip out the server layer.

Note: We do this early because other steps add functions to classes and in 
some cases they need to specify server structure in order to develop the 
correct invariants. 

Note: servers do not nest and exist below objects in the hierarchy. Hence a
server may not contain another server or an object. An object may contain both.
Within an object, servers and member objects exist at the same level.

----------------------------------------------------------------------------
Make constructors/destructors explicit

All constructors, copy constructors and destructors get turned into regular
member functions and we add explicit calls to them in the code. Need to treat
each kind of scope correctly: static, member, heap, local. If an object is
passed by value and has a copy constructor, we must turn that into
pass-by-reference and then insert the copy construct call at the top of the
function. New functions go in same server as original con/de-structors.

Invariant: pass-by-value only for memcpy()able objects; underlying object
lifecycle may now differ from that in the original program.

Note: We choose not to generate any copy constructor if not already there -
these objects will be treated like POD types. @todo or will they?

Note: this means that const members will need to be un-consted except in the
case of static objects with sufficiently simple initialisation algorithms.
Optimisations could include converting member pointers initialised by new()
into member objects and detecting when a constructor parameter is always
supplied from a const.

Note: destructors must get called at early returns and gotos out of scopes.

----------------------------------------------------------------------------
Staticise heap

Explicitly implement new/delete to allocate objects from static arrays. 

Invariant: No dynamic allocation. All const-member pointers are now globally
constant.

Note: No need to worry about constructors/destructors since they should have
been dealt with in the previous step.

Note: Maybe place in a class if use cases are all below that class (ie 
coming from member functions or member objects). New and delete for a given 
type go in the same server.

----------------------------------------------------------------------------
Eliminate this->

Remove dereferences through the "this" pointer or any const pointer known 
equal to "this".

Invariant: All known accesses to something in the same module do not use
pointers.

Note: Strictly an optimisation, but the invariant helps to clarify.

----------------------------------------------------------------------------
Use get()/set()

For POD types that are exposed publically, make all inter-object reads
and writes be function calls. New functions go in same server as the public 
member.

Invariant: every inter-object interaction is a function call

Note: the pointer *could* equal "this", but only if it's non-constant in which
case we must support the possibility that it is not "this".

----------------------------------------------------------------------------
Add addressof functions

Add member functions to each object that returns the address of (a) the object 
itself (addressof()) and (b) the addresses of any public POD data member x
(x_addressof()). Replace &y with y.addressof() as appropriate.

A new server should be created for case (a), and in case (b) the functions
should exist in the same server as the corresponding data.

Invariant: A function call takes place whenever inter-object addresses are 
taken. Also, & now only used for POD in the same server (except for case (a))

Note: Do not generate for member objects - their address should 
be got by calling them directly. This is important for routing etc.

Note: case (a) doesn't actually need to return any meaningful data. The sole
purpose of the call is to establish routing so that derefs can be routed back 
to the object.

----------------------------------------------------------------------------
Object boundary forwarding

Introduce thunk functions such that any call from a member object to an external
object or vice-versa is forwarded through a new thunk function within the
object.
The new thunk function should exist in a new server.

Invariant: calls into or out of an object are forwarded hence visible at 
the object's class definition.

----------------------------------------------------------------------------
1:1 caller-callee relationship

Whenever a function fd is called by more than one external server, add 
new functions f1, f2, ... within fd's server, one for each calling server. 
The servers should now call the f1, f2 etc and these should forward to fd.

Invariant: Inter-server calls should now be 1:1 correspondence.

Note: This will result in router/arbiter functionality in each server affected.
Servers generated during the object boundary forwarding step will become 
dedicated arbiters. Nice.

----------------------------------------------------------------------------
Lower NULL pointers

Replace every variable pointer with a non-null pointer and a bool. If the bool
is false, the pointer is considered NULL. Otherwise the pointer is not NULL and
it may be dereferenced.

Invariant: all pointers are non-NULL

Note: No need to do this to const pointers

----------------------------------------------------------------------------
Lower pointer arithmetic

Associate every variable pointer with an int, which begins at zero, and is then
the subject of all pointer arithmetic. Then use array style for derefs. Eg 

p++; return *p; 

becomes 

p.index++; return p[p.index];

Invariant: No pointer arithmetic; pointers only created and overwritten

Note: what about const pointers?

----------------------------------------------------------------------------
Lower references

Implement references using pointers

Invariant: no references

Note: do this after lowering NULL and pointer arithmetic because the pointers
that we will generate for refs don't need to support either of these things. 

----------------------------------------------------------------------------
Memberise locals

Generate a data structure to represent the local variables in each server. Use 
unions for variables whose scope does not overlap. Add an array of these 
structures, up to the max nesting depth, as a server member. Create a member 
stack pointer which should be initialised to zero. Increment it at the start 
of the function and decrement just before returning. Change all code to use the 
array indexed by the stack pointer.

Invariant: all variables are static or members

Note: we have to do this before any SystemC stuff, because it needs all objects
to be static (or members). But we will add more locals later on and so this step
will be repeated. Hopefully re-use implementation!

Note: furthermore, "add dereferencing layer" lowering needs *all* locals to be
memberised first, so moved up again and now applies to all locals

----------------------------------------------------------------------------
Add server-level dereferencing layer

For each server, create an enum with a value for POD data item whose address is
taken. Substitute the enum value for the address.

Add functions to each server, for each enum value, that forward function calls 
to the corresponding object/POD item. So if member objects a and b of type C 
both have a function footle( int x ) then we create deref_footle( C *p, int x ) 
which invokes the correct footle() based on p. For POD types add eg
deref_get( type *p ) and deref_set( type *p, type val ). Replace pointer derefs
with the corresponding function. @todo but we're only doing this for POD types!

Invariant: server handles all derefs of internal data

Note: p->f() and equivalently (*p).f() should *not* be broken down into the *p
and the .f() but should be treated as a unit (becomes deref_f(p))

Note: there's now no need to copy the data because we always bring the
action to the data, not the other way around

Note: only do this to variable pointers!

Note: since >1 server in an object may have deref functions for the same
data type, we need to unique-ise the names, at least for testing.

----------------------------------------------------------------------------
Refer-back variable pointers

With each pointer, associate an enum representing (a) whether the pointer was
taken locally and if not, (b) which server it came from. Or just add values to 
the existing enum. This other server is the referee server. 

In case (b) add a deref function that decodes the pointer then forwards the call
to the referee server's dereferencer function. 

Note: this new call may pass some other pointer, in which case the referee
server may gain a new enum value for which the original server is referee.
Therefore this step must iterate until no more new deref calls are
required. Only two deref calls are needed between each pair of objects for
any given pointed-to type (one in each direction) so the iterations will
terminate.

Invariant: all inter-server calls are now via const pointers; interpretation of
variable pointers is now local

Note: only do this to variable pointers!

Note: new call also needs a backchannel

----------------------------------------------------------------------------
Change const pointers to ports

Replace Obj *p with SystemC ports eg sc_port<Obj>.

Invariant: no pointers

Note: ports require 1:1 caller-callee relationships

----------------------------------------------------------------------------
Add server context

Add an SC_THREAD for each server. Incoming calls should wake the server context
and wait for it to complete executing the function before returning. Completion
should be signalled by an event.

Invariant: no cumulative nesting in calls between servers

Note: at this stage, all events are internal to servers, and do not go between
servers.

Note: Possible major problem here supporting inter-server recursion between this
step and the "make transactions non-blocking" step. Since each server's local
context "camps" in the other server's function while awaiting completion of the
call it is not straightforward for it to resume checking for incoming calls
while waiting. Solution is to employ a pool of contexts for each object and use
a "wake one waiter" event mechanism to ensure we select one waiting context for
each incoming call. Hopefully SystemC supports this @todo check!

Note: only change callee (upper executive)

----------------------------------------------------------------------------
Move to 2-phase transactions

Turn function calls into "fake" nonblocking by adding a new call back to the
original caller after processing is complete, just before the original called
function returns. The original call is now called a call-functrino, and the new
call is called a return-functrino.

Outgoing call sites should wait after invoking the call-functrino and then kick
themselves in the return-functrino.

Invariant: no return values on inter-server calls

Note: initial call is a functrino to the caller but isn't implemented
as one. Hence "fake" 2-phase.

Note: Since the return-functrino and the kick will come *before* the
call-functrino returns and the wait begins the semaphore must be a 1-queue
event.

Note: affects caller and callee (upper and lower executives)

----------------------------------------------------------------------------
Make transactions non-blocking

The call-functrino should return immediately after kicking the server context.
The return-functrino should now come from the callee's server context if not
already. 

Invariant: all inter-server calls are functrinos

Note: only change callee (upper executive)

Note: Now reduce to one context per server. Wait for outgoing calls to return by
recursing back into the context's upper executive code. This supports recursive
calls.

Note: at this stage, each functrino corresponds to a sub-transaction.

----------------------------------------------------------------------------
Add channels

Create a new "channel" (in the SystemC TLM sense) for each sub-transaction. The
channel should forward the functrino calls. 

Invariant: we have a presence, in the form of a channel, between communicating 
pairs of servers.

Note: the channel implementation we create will not be stated out but instead
will be converted to wires (=signals) by the protocol step(s) so it is not a
server. It will mostly be boiler-plate code.

Note: changes caller and callee but trivially (outgoing functrinos go to
channel). 

----------------------------------------------------------------------------
Passivate

Modify the channels. Provide each with passive (call-in) 2-phase interfaces for
both caller and callee. All functrinos go into the channel and the channel kicks
(wakes up) the callee which then collects the parameters. 

Invariant: servers do not receive incoming functrinos

Note: after this step, a functrino is still used to initiate a sub-transaction,
but the recipient gets an event and does a "get data" type call on the channel
to get the data. 

Note: the call into the channel to get the params is not a functrino since 
it goes to a communications primitive (the channel) and not a server.

Note: only change functrino recipients

----------------------------------------------------------------------------
Make sub-transactions 0-queue

For each channel, add an "ack" channel which goes the in the other direction
and has no data (same passive model). The recipient should ack immediately after
receiving the event and the originator should wait for the ack.

Invariant: now all transactions rendez-vous meaning the data doesn't have to 
be stored externally between origination and receipt.

Note: Now there are 4 events: call, call ack, return, return ack. Call ack 
and return events could be merged but we will regard that as an optional future
optimisation.

Note: transactions now 4-phase; sub-transactions now 2-phase

----------------------------------------------------------------------------
Split out data and event channels

The outgoing channels should be split into 2 channels: an event-only channel
to signal the event and a data-only channel for the data.

Invariant: can now treat the two kinds of channels separately

Note: the ack channel is already an event-only channel

----------------------------------------------------------------------------
Introduce minor delay

Introduce a primitive called delay() which generates an event to the current
thread then waits for it. This is called a minor delay.

Invariant: can now express minor delays

Note: when we add protocols, we need to be able to avoid combinational loops
so we use this primitive to break them. 

----------------------------------------------------------------------------
Move to signals

The event-only channels become sc_signal<bool> backed by a member variable. 
An event is generated by toggling the value: 1 goes to 0; 0 goes to 1. Reset 
value is 0. The data-only channels become sc_signal<x> where x is the data 
type used. Multiple data items (eg multiple parameters) should result in 
multiple signals (no need to put them in a struct or anything). Add a single 
delay() to the originator algorithm just after the transaction. 

Invariant: All communication is via sc_signal

Note: No need for backing members on data channels because the algorithm will
block during the transaction so the supplied data can't change. 

Note: since we are now dealing with wires (which is what signals really are),
we need to avoid combinational loops (which are viewed as part of the behaviour
of wires). We do this by adding a delay() in such a way that no two transactions
can occur simultaneously (though the ack can be simultaneous)

----------------------------------------------------------------------------
Add poll loops

Replace all occurrences of wait(x) with while(!x) delay().

Invariant: our reliance on SystemC eventing is hidden and the need for poll
loops
made explicit.

Note: this is really associated with "add clock/reset" but we do it up here 
so we can state-out the loop.

Note: we may not need this if using asynchronous technology. State-out should be
able to still work if we skip this step leaving wait(x) in place of delay()
loops.

----------------------------------------------------------------------------
Merge member functions

Merge all the member functions in a server into a single one that uses a big
switch statement to select the implementation based on a new enum parameter.
Parameters of the original functions should be grouped into a struct for each of
the original member functions then unioned together for the big function.

Invariant: all calls are simple recursions on the big function

Note: this single function is now the server's run function. All other calls 
(apart from SystemC primatives) have now become simple recursions of this
function.

Note: originally was before memberise locals, but that proved impossible due to
pointer lowering steps. This must be done after structural steps to ensure we
keep separate call interfaces for separate call sites (1:1 wiring).

----------------------------------------------------------------------------
Lower constructs

Lower constructs that are not supported in combable (synthesisable) Verilog into
conditional branches ie if(cond) goto label; Also after each delay(); add a goto
WAIT_STATE; WAIT_STATE:; 

Invariant: all constructs combable or can be trivially stated-out

Note: there's some flexibility here in how much stuff we lower. It corresponds
to design tradeoffs in the final hardware. Any construct surrounding a label
must
itself be lowered. 

Note: retain local scope structure for now

----------------------------------------------------------------------------
Add state variable

Add an enum with a value for each label, add a local variable of that type
called state and maintain it correctly by assigning to it immediately before
each goto. Initialise to eg INIT_STATE at start of function.

Note: assert this at each label as a double check since we have a little
redundancy at this point.

Note: the point of this is to establish the state as local, i.e. needs to be
stacked when we recurse.

----------------------------------------------------------------------------
Memberise locals

Generate a data structure to represent the local variables. Use unions for
variables whose scope does not overlap. Add an array of these structures, up to
the max nesting depth, as a class member. Create a member stack pointer which
should be initialised to zero. Increment it at the start of the function and
decrement just before returning. Change all code to use the array indexed by the
stack pointer.

Invariant: all data is static or member

Note: includes state

Note: the same step was done on object type locals earlier on - try to build new
locals into same structure.

----------------------------------------------------------------------------
Remove scopes

Scoped blocks (surrounded by {}) should now be completely redundant. Get rid of
them.

Note: was part of memberise locals, but now that step has to be run twice and
the first time doesn't want to do this.

Invariant: No scopes (apart from overall function scope)

----------------------------------------------------------------------------
Lower recursion

Turn each recursion call point into a goto to the start of the function and at
the very end of the function insert a goto to the label implied by the state
variable. Add a new primitive for this.
 
Invariant: no recursion; no non-trivial function calls 

Note: the "goto a variable" primitive would have to become eg a switch statement
for the purposes of testing this step. It vanishes in the "State-out" step.

----------------------------------------------------------------------------
Else clauses for skipped code

Place code after a conditional goto (a goto in an if) up to the next label into
an else clause if it isn't already in one. If there is code between an
unconditional goto and the next label, it is an error (the code is unreachable)

Invariant: sections of code between labels are now combable

----------------------------------------------------------------------------
State-out

Surround the entire function with a switch statement on the state variable.
Generate a case for each label ending just before the next label. Insert a break
at the end of each case. Remove the gotos, leaving only the assignments to the
state variable. 

Invariant: context is released between each combable block

Note: we are taking advantage of the fact that SC_THREAD loops infinitely

----------------------------------------------------------------------------
Extract waits

Replace all delay() calls with a single one at the bottom of the function.

Invariant: no non-trivial context across a delay()

Note: this is possible because all the delay() calls are at the ends of state
cases and there's nothing after them until you get to the bottom of the
function.

----------------------------------------------------------------------------
Insert clock and reset

Move all servers to SC_CTHREAD. Replace the delay() at the bottom with 
wait(clk).

Invariant: no more delay() primitive - all events explicitly controlled 
by clock

Note: not sure about clock distribution or how to handle reset. Maybe reset 
should zero all stored data as a first step in startup. @todo

----------------------------------------------------------------------------
Remove server context

Move to SC_METHOD. Remove the wait(clk) primitive.

Invariant: no persistent implicit context

Note: this is really a pattern reduction: SC_CTHREAD{ ...; wait(); } becomes
SC_METHOD{ ...; }. If any functions don't match the pattern we have an error.

----------------------------------------------------------------------------
Lower types

Convert types like char, int into bit vectors. Support bit fields properly. Bool
becomes a 1-bit type. 

Invariant: no types unknown to Verilog

Note: we will hopefully be able to tolerate arbitrary bit vectors in SC form eg
sc_bitvec<5> all the way through the process. @todo check

----------------------------------------------------------------------------
Implement variables as registers and wires

Create some combination of registers and wires in place of variables. Try to
avoid duplicating the combing-out that Verilog synthesis can do for us.

Invariant: storage elements represented in a Verilog-compatible style.

----------------------------------------------------------------------------
Go to Verilog

Insert Verilog constructs as follows: objects->modules; servers->
"always" blocks and everything else maps as usual. Use synthesisible Verilog 
2001. Always blocks should be the clocked kind.

Invariant: program is now Verilog

