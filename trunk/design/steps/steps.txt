
(C) Copyright 2006 John Graley
Available under the terms of the BSD license. 


This file lists the steps in the mapping process. Currently rather brief and 
ambiguous I'm afraid, and more detail will go in over time. 

Since this is likely to change repeatedly, it will be kept under version
control. 
Steps are not numbered to avoid the need to renumber after insert or delete; 
instead they are separated by long lines of -.

Invariants will usually be the absence of types of constructs or guarantees
about behaviour/properties of parts of the system. Occasionally they may be
expression of redundancy (duplication of information in the program though
guaranteed equivalences) though this is discouraged.


@todo early steps for templates, RTTI, Exceptions

----------------------------------------------------------------------------
Make constructors/destructors explicit

All constructors, copy constructors and destructors get turned into regular
member functions and we add explicit calls to them in the code. Need to treat
each kind of scope correctly: static, member, heap, local. If an object is
passed by value and has a copy constructor, we must turn that into pass by
reference and then insert the copy construct call at the top of the function.

Invariant: pass-by-value only for memcpy()able objects; actual object lifecycle
may now differ from that in the original program

Note: We choose not to generate any copy constructor if not already there -
these objects will be treated like fundamental types

Note: this means that const members will need to be un-consted except in the
case of static objects with sufficiently simple initialisation algorithms.
Optimisations could include converting member pointers initialised by new()
into member objects and detecting when a constructor parameter is always
supplied from a const.

----------------------------------------------------------------------------
Staticise heap

Explicitly implement new/delete to allocate objects from static arrays. 

Invariant: No dynamic allocation. All const-member pointers are now globally
constant.

Note: No need to worry about constructors/destructors since that should have
been dealt with in the previous step.

----------------------------------------------------------------------------
Eliminate this->

Remove dereferences through the "this" pointer or any const pointer equal to
"this".

Invariant: All known accesses to something in the same module do not use
pointers.

Note: Strictly an optimisation, but the invariant helps to clarify.

----------------------------------------------------------------------------
Use Get()/Set()

For fundamental types that are exposed publically, make all inter-object reads
and writes be function calls.

Invariant: every inter-object interaction is a function call

Note: the pointer *could* equal "this", but only if it's non-constant in which
case we must support the possibility that it is not "this".

----------------------------------------------------------------------------
Call through pointers

Get rid of all direct calls between objects eg x.y() and replace with calls
though a constant pointer initialised at construct time.

Invariant: All inter-object calls go through a pointer

----------------------------------------------------------------------------
Outgoing interfaces

Add interfaces to each object to represent the calls it makes to other objects. 

Note: Still not completely sure if we need this.

----------------------------------------------------------------------------
Forward at class boundaries

Any call from a member object to an external object or vice-versa should be
forwarded through new thunk functions within the object. These will develop into
arbiters. Inter-object calls should now be 1:1 correspondence.

Invariant: Each interface has only one caller

----------------------------------------------------------------------------
Add backchannels

Add a marker of some sort at each interface that refers to its (now unique)
caller. This is useful to later steps. A partial check could look at
__builtin_return_address().

Invariant: Any static (const pointer) interaction may be reversed

----------------------------------------------------------------------------
Lower NULL pointers

Replace every variable pointer with a non-null pointer and a bool. If the bool
is false, the pointer is considered NULL. Otherwise the pointer is not NULL and
it may be dereferenced.

Invariant: all pointers are non-NULL

Note: No need to do this to const pointers

----------------------------------------------------------------------------
Lower pointer arithmetic

Associate every variable pointer with an int, which begins at zero, and is then
the subject of all pointer arithmetic. Then use array style for derefs. Eg 

p++; return *p; 

becomes 

p.index++; return p[p.index];

Invariant: No pointer arithmetic; pointers only created and overwritten

Note: what about const pointers?

----------------------------------------------------------------------------
Remove references

Implement references using pointers

Invariant: no references

Note: do this after lowering NULL and pointer arithmetic because the pointers
that we will generate for refs don't need to support either of these things. 

----------------------------------------------------------------------------
Memberise locals

Generate a data structure to represent the local variables. Use unions for
variables whose scope does not overlap. Add an array of these structures, up to
the max nesting depth, as a class member. Create a member stack pointer which
should be initialised to zero. Increment it at the start of the function and
decrement just before returning. Change all code to use the array indexed by the
stack pointer.

Invariant: all variables are static or members

Note: we have to do this before any SystemC stuff, because it needs all objects
to be static (or members). But we will add more locals later and so this step
will be repeated later. Hopefully re-use implementation!

Note: furthermore, "add dereferencing layer" lowering needs *all* locals to be
memberised first, so moved up again and now applies to all locals

----------------------------------------------------------------------------
Add dereferencing layer

Add functions to each class, for each type required, that forward function calls
to member objects based on a pointer. So if member objects a and b of type C
both have a function footle( int x ) then we create deref_footle( C *p, int x )
which invokes the correct footle() based on p. For fundamental types add eg
deref_get( type *p ) and deref_set( type *p, type val ). Replace pointer derefs
with the corresponding function. 

Invariant: no pointer dereferences outside special dereferencer functions

Note: p->f() and equivalently (*p).f() should *not* be broken down into the *p
and the .f() but should be treated as a unit (becomes deref_f(p))

Note: there's now no need to copy the object because we always bring the
action to the object, not the other way around

Note: only do this to variable pointers!

----------------------------------------------------------------------------
Refer-back variable pointers

With each pointer, associate an enum representing (a) whether the pointer was
taken locally and if not, (b) which interface (hence which other object) it came
from. This other object is the referee object. 

In case (b) the deref function should decode the pointer then forward the call
to the referee object's dereferencer function via a new interface on the referee
object. The new interface is called a deref interface and is made via the
(const) backchannel pointer.

Note: this new call may pass some other pointer, in which case the referee
object may gain a new enum value for which the original object is referee.
Therefore this step must iterate until no more new deref interfaces are
required. Only two deref interfaces are needed between each pair of objects for
any given pointed-to type (one in each direction) so the iterations will
terminate.

Invariant: all inter-object calls are now via const pointers; interpretation of
variable pointers is now local

Note: only do this to variable pointers!

Note: new call also needs a backchannel

----------------------------------------------------------------------------
Enumerate local variable pointers

Create an enum for all member objects whose address gets taken. Substitute an
enum ie PTR_X for each &x and get the deref function to decode the enum and
return x as required.

Note: this includes non-trivial class objects; otherwise taking their address
would require a new channel between parent and child that isn't required
otherwise and wasn't processed in the "Outgoing interfaces" or "Forward at class
boundaries" steps.

Invariant: no variable pointers

Note: not const pointers!!

----------------------------------------------------------------------------
Merge member functions

Merge all the member functions in a class into a single one that uses a big
switch statement to select the implementation based on a new enum param. Other
parameters should be grouped into a struct for each of the original member
functions then unioned together for the big function.

Invariant: all calls are simple recursions

Note: this single function is now the run function. All other calls (apart from
SystemC ones which don't count) have now become simple recursions of this
function.

Note: originally was before memberise locals, but that proved impossible due to
pointer lowering steps. Now this is above structural steps to make them easier,
but if that proves wrong (or structural steps invalidate this step's invariant)
then this step may be moved back to below structural.

----------------------------------------------------------------------------
Change const pointers to ports

Replace Obj *p; with SystemC ports eg sc_port<Obj>.

Invariant: no pointers

Note: ports require 1:1 relationships

Note: this gives us SystemC's "direct TLM" style. 

----------------------------------------------------------------------------
Add local context

Derive all classes from SC_THREAD. Incoming calls should wake the local context
and wait for it to complete before returning.

Invariant: no cumulative nesting in calls between objects

Note: this gives us SystemC's "blocking TLM" style. 

Note: Possible major problem here supporting inter-object recursion between this
step and the "make transactions non-blocking" step. Since each object's local
context "camps" in the other object's function while awaiting completion of the
call it is not straightforward for it to resume checking for incoming calls
while waiting. Solution is to employ a pool of contexts for each object and use
a "wake one waiter" event mechanism to ensure we select one waiting context for
each incoming call. Hopefully SystemC supports this.

Note: only change callee (upper executive)

----------------------------------------------------------------------------
Move to 2-phase transactions

Turn function calls into "fake" nonblocking by adding a new call back to the
original caller after processing is complete, just before the original called
function returns. This is called a return functrino.
Outgoing calls should wait after making the initial call and then kick
themselves in the return functrino.

Invariant: no return values on inter-object calls

Note: incoming call looks like a functrino to the caller but isn't implemented
as one. Hence "fake" 2-phase.

Note: Since the return functrino and the kick will come *before* the outgoing
call
returns and the wait begins the semaphore should be 1-in-1-out.

----------------------------------------------------------------------------
Make transactions non-blocking

The incoming call should return immediately after kicking the local context. The
return functrino should now come from the callee's local context if not already. 

Invariant: all inter-object calls are functrinos

Note: this gives us SystemC's "non-blocking TLM" style. 

Note: only change callee (upper executive)

Note: Now reduce to one local context. Wait for outgoing calls to return by
recursing back into the context's executive function. This supports recursive
calls.

Note: both calls are functrinos.

----------------------------------------------------------------------------
Add channels

Create a new "channel" (in the SystemC TLM sense) for each caller-callee pair of
objects. Forward the functrinos. 

Note: the channel implementation we create will not be stated out but instead
will be converted to wires (=signals) by the protocol step(s) (which have not
been added yet at the time of writing). They will mostly be boiler-plate code.

Note: changes caller and callee but trivially (outgoing functrinos go to
channel)

----------------------------------------------------------------------------
Passivate

Modify the channel. Provide it with passive (call-in) 2-phase interfaces for
both caller and callee. All functrinos go into the channel and the channel kicks
(wakes up) the callee which then collects the parameters. 

Invariant: objects do not receive incoming functrinos

Note: after this step, a functrino is still used to pass a message to the
channel, but to get the message out at the other end we have an event followed
by a "get params" type call on the channel. Maybe the latter is an
anti-functrino?

Note: only change functrino recipients

----------------------------------------------------------------------------
Make transactions 0-queue

For each channel, add an "ack" channel which goes the in the other direction
and has no data. The recipient should ack immediately after receiving the event
and the originator should wait for the ack.

Invariant: now all transactions rendez-vous meaning the data doesn't have to 
be stored externally between origination and receipt.

Note: Now there are 4 events: call, call ack, return, return ack. Call ack 
and return events could be merged but we will regard that as an optional future
optimisation.

----------------------------------------------------------------------------
Split out data and event channels

The outgoing channels should be split into 2 channels: an event-only channel
to signal the event and a data-only channel for the data.

Invariant: can now treat the two kinds of channels separately

Note: the ack channel is already an event-only channel

----------------------------------------------------------------------------
Introduce minor delay

Introduce a primitive called delay() which generates an event to the current
thread then waits for it. This is called a minor delay.

Invariant: can now express minor delays

Note: when we add protocols, we need to be able to avoid combinational loops
so we use this primitive to break them. 

----------------------------------------------------------------------------
Move to signals

The event-only channels become sc_signal<bool> backed by a member variable. 
An event is generated by toggling the value: 1 goes to 0; 0 goes to 1. Reset 
value is 0. The data-only channels become sc_signals<x> where x is the data 
type used. Multiple data items (eg multiple parameters) should result in 
multiple signals (no need to put them in a struct or anything). Add a single 
delay() to the originator algorithm just after the transaction. 

Invariant: All communication is via sc_signal

Note: No need for backing members on data channels because the algorithm will
block during the transaction so the supplied data can't change. 

Note: since we are now dealing with wires, we need to take account of the 
need to avoid combinational loops (which are viewed as part of the behaviour 
of wires). We do this by adding a delay() in such a way that no two transactions 
can occur simultaneously (though the ack can be simultaneous)

----------------------------------------------------------------------------
Add poll loops

Replace all occurrences of wait(x) with while(!x) delay().

Invariant: our reliance on SystemC eventing is hidden and the need for poll loops
made explicit.

Note: this is really associated with "add clock/reset" but we do it up here 
so we can state-out the loop.

Note: we may not need this if using asynchronous technology. State-out should be
able to still work if we skip this step leaving wait(x) in place of delay() loops.

----------------------------------------------------------------------------
Lower constructs

Lower constructs that are not supported in combable (synthesisable) verilog into
conditional branches ie if(cond) goto label; Also after each delay(); add a goto
WAIT_STATE; WAIT_STATE:; 

Invariant: all constructs synthesisable or can be trivially stated-out

Note: there's some flexibility here in how much stuff we lower. It corresponds
to design tradeoffs in the final HW. Any construct surrounding a label must
itself be lowered. 

Note: retain local scope structure for now

----------------------------------------------------------------------------
Add state variable

Add an enum with a value for each label, add a local variable of that type
called state and maintain it correctly by assigning to it immediately before
each goto. Initialise to eg INIT_STATE at start of function.

Note: assert this at each label as a double check since we have a little
redundancy at this point.

Note: the point of this is to establish the state as local, i.e. needs to be
stacked when we recurse.

----------------------------------------------------------------------------
Memberise locals

Generate a data structure to represent the local variables. Use unions for
variables whose scope does not overlap. Add an array of these structures, up to
the max nesting depth, as a class member. Create a member stack pointer which
should be initialised to zero. Increment it at the start of the function and
decrement just before returning. Change all code to use the array indexed by the
stack pointer.

Invariant: all data is static or member

Note: includes state

Note: the same step was done on object type locals earlier on - try to build new
locals into same structure.

----------------------------------------------------------------------------
Remove scopes

Scoped blocks (surrounded by {}) should now be completely redundant. Get rid of
them.

Note: was part of memberise locals, but now that step has to be run twice and
the first time doesn't want to do this.

Invariant: No scopes (apart from overall function scope)

----------------------------------------------------------------------------
Lower recursion

Turn each recursion call point into a goto to the start of the function and at
the very end of the function insert a goto to the label implied by the state
variable.
 
Invariant: no recursion; no non-trivial function calls 

Note: the "goto a variable" construct would have to become eg a switch statement
for the purposes of testing this step. It vanishes in the "State-out" step.

----------------------------------------------------------------------------
Else clauses for skipped code

Place code after a conditional goto (a goto in an if) up to the next label into
an else clause if it isn't already in one. If there is code between an
unconditional goto and the next label, it is an error (the code is unreachable)

Invariant: sections of code between labels is now combable

----------------------------------------------------------------------------
State-out

Surround the entire function with a switch statement on the state variable.
Generate a case for each label ending just before the next label. Insert a break
at the end of each case. Remove the gotos, leaving only the assignments to the
state variable. 

Invariant: context is released between each combable block

Note: we are taking advantage of the fact that SC_THREAD loops infinitely

----------------------------------------------------------------------------
Extract waits

Replace all delay() calls with a single one at the bottom of the function.

Invariant: no non-trivial context across a delay()

Note: this is possible because all the delay() calls are at the ends of state
cases and there's nothing after them until you get to the bottom of the
function.

----------------------------------------------------------------------------
Insert clock and reset

Move all classes to SC_CTHREAD. Replace the delay() at the bottom with 
wait(clk).

Invariant: no more arbitrary delay() calls - all events explicitly controlled 
by clock

Note: not sure about clock distribution or how to handle reset.

----------------------------------------------------------------------------
Remove local context

Move to SC_METHOD. Remove the wait() call.

Invariant: no persistent implicit context

Note: this is really a pattern reduction: SC_CTHREAD{ ...; wait(); } becomes
SC_METHOD{ ...; }. If any functions don't match the pattern we have an error.

----------------------------------------------------------------------------
Initialise data

All initialised statics to be initialised in a "initial" block.

Invariant: no inline initialisation

Note: how do initial blocks in SC?

----------------------------------------------------------------------------
Lower types

Convert types like char, int into bit vectors. Support bit fields properly. Bool
becomes a 1-bit type. 

Invariant: no types unknown to Verilog

Note: we will hopefully be able to tolerate arbitrary bit vectors in SC form eg
sc_bitvec<5> all the way through the process.


@todo late steps for dealing with wire vs latch vs flip-flop
@todo replace events with some kind of protocol - maybe just after insert
clock/reset

