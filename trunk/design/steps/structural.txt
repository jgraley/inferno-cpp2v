(C) Copyright 2006 John Graley
Available under the terms of the BSD license. 

Structural phase - steps relating to program structure (inter-object level)

In this phase, we deliver on the promise made in the philosophy document: that
we would avoid simply re-creating a single computer (by doing state-out and
similar on the whole input program at once) and instead regard the program as a
network of semi-autonomous interacting agents.

These agents will each be stated-out separately. Each one is capable
of implementing whatever code we partition into it as well as any code we choose
to add. Any code we add must confirm to the subset of C++ established in earlier
phases. We partition at object level. 

We choose to replace function calls between objects with pairs of
function-call-like things called functrinos. A functrino has a call event and
parameters but no return or return value. There's a functrino for a function
call and another for its return. Functrinos could probably be used to model
other things like messages, and some "void" functions with the right properties
could be modelled with only a call-functrino, but that's for the future. The
real advantage is that we've get rid of some inconvenient aspects of functions.

We will choose to pass functrinos through a number of "thunks" or forwarding
functrinos that simply call through to another functrino. This is done to
establish the paths that will be taken by what will eventually become wires. We
need to be able to tell Verilog where they go, and we need to marshall them and
avoid blatant duplication. These steps actually give rise to arbiters (and
possibly routers) as structures that emerge from thunks as the later structural
and sequential steps execute. This is a nice result.

Each object, after state-out, will possess its own context of execution in the
form of a physically manifest state variable. In this phase, we choose to model
them using SystemC's SC_THREAD primitive, which is really just a wrapper for an
OS thread. It helps us run tests on intermediates and is also a conceptual aid
since we can "re-use" understanding of multi-threaded programming, admittedly in
SystemC's esoteric style (but remember SystemC is designed to be mappable to
hardware). We ensure that functrino interactions between threads are
non-blocking, so that each functrino may be considered as an instantaneous
event (at least for now). 

Functrinos going between objects are still unacceptable for state-out.
TODO why? We
therefore need to go quite low-level in this phase in terms of describing a
protocol that makes the program structure look like the ends of some
well-defined wires from the perspective of an object. 

We begin by introducing the Transaction Level Modelling concept of a channel for
each functrino. Over a few steps, the channels are modified to avoid making
calls into objects (instead they use SystemC's channel->module wakeup scheme)
and split up into finer, more role-specific channels.

We add an acknowledgement for each functrino. This is to be understood as a
low-level ack that serves protocol functions: flow control and data validity
marshaling. The reader may object that we have divided function calls twice
now: first into call-functrino/return-functrino, then into 
call-request/call-ack/return-request/return-ack. But this is no different to
ARM's AXI bus spec, that has avalid/aready/rvalid/rready for a read transaction.

Finally, we actually insert SystemC's version of wires, the sc_signal<x>
pre-defined channel. In the interests of proper correctness, we also choose now
to add a notional time delay, called a "minor delay" in order to prevent objects
from trying to do impossible things like toggling a wire twice simultaneously.

@todo need a step to insert SC_MODULE around all classes?

The steps within this phase follow:

----------------------------------------------------------------------------
Move to 2-phase transactions

Turn function calls between objects into "fake" nonblocking by adding a new call
back to the original caller after processing is complete, just before the
original called function returns. The original call is now called a
call-functrino, and the new call is called a return-functrino.

Outgoing call sites should use a special waiting primitive, eg wait_return()
after invoking the call-functrino. It may be implemented as an empty function in
test renders for the next few steps, until otherwise specified.

The idea here is to establish that the return event and return value come via a
second call. Now, each of these calls has no return value and the only important
event is their calls, not their returns. These are the characteristics of
functrinos.

Invariant: only functrinos between objects.

Note: initial call is a functrino as far as the caller is concerned but isn't 
implemented as one by callee. Hence "fake" 2-phase.


Example output:

class A
{
    event g_done_event; // optional in fake 2-phase; needed if real
    int g_retval;

    void f()
    {
        ...
        b.g_call();
        wait_return( g_done_event ); // optional in fake 2-phase; needed if real
        y = g_retval;
        ...
    }

public:    
    void g_return( int retval ) // functrino
    {
        g_retval = retval;
        signal_return( g_done_event ); // optional in fake 2-phase
    }    
} a;

class B
{
public:    
    void g_call() // "fake" functrino
    {
        ... g()'s algorithm ...
        int retval = x; // or whatever
        a.g_return(retval);
    }    
    
    // g used to be 
    // int g() { return x; }
} b;


----------------------------------------------------------------------------
Object boundary forwarding

Introduce thunk functrinos such that any functrino call from a member object to
an external object or vice-versa is forwarded through a new thunk functrino
within the object. The new thunk functrino should be a member of the aforementioned
object.

Verilog modules require that all interaction between "stuff" inside and "stuff"
outside the module is explicitly manifested by wires. This step helps to make
all interactions visible at the required level(s) of the hierarchy.

We could just use a primitive in the internal representation for this, that
doesn't render to anything in test builds, but the functions we generate will
turn into Arbiters as later steps are applied to them, and will give us the
associated streamlining and reduction of wiring complexity.

Note: since all member functions will be merged into a single state machine,
this means that such functrinos will be sequentialised against all other
similar external/member functrinos as well as the implementations of the 
object's own functions. This limitation may be mitagated by choice of 
class hierarchy in the input program.

Invariant: calls into or out of an object are forwarded hence visible at 
the object's class definition.

Example output:

class A
{
public:
    void p( int ); // functrino
};

class B
{
private: // used to be public
    A subobject;
    
public:         
    // Thunk functrino just forwards the call
    void subobject_p( int x )
    {
        subobject->p( x );
    }
};

----------------------------------------------------------------------------
1:1 caller-callee relationship

Whenever a functrino pd is called by more than one external object, add 
new functrinos p1, p2, ... within pd's object, one for each calling object. 
These objects should now call the p1, p2 etc which should forward to pd.

We need a 1:1 caller-callee match in order to be able to bind ports and
introduce channels. This step was originally much higher up because it was
thought a prerequisite for pointers and 2-phase. However, those steps are no
harder without, so we now do this as late as channel construction will allow.

This will result in router/arbiter functionality in each object affected.

Invariant: Inter-object calls should now be 1:1 caller-callee correspondence.

@todo do I need to collect together all the outgoing calls eg in object Y 
in the example output?

Example output:

class X // this class used to just have pd() but has now had the 1:1 step done on it.
{
private:    
    void pd()
    {
        ...blah...
    }
    
    
public:
    void p1() // new functrino
    {
        pd();
    }
    
    void p2() // new functrino
    {
        pd();
    }
}

class Y // use p1 for all outgoing calls from this object
{
    void q()
    {
        p1();
        p1();
    }
    
    void r()
    {
        p1();
    }
}

class Z // use p2 since now in a different object
{
    void i()
    {
        p2();
    }
}

----------------------------------------------------------------------------
Use ports between objects

Add an sc_port for each external object that we call or are called from. We're
doing this to prepare for the addition of channels, but we will immediately make
correct use of the wakeup mechanism supported by ports. @todo seems to be wrong
- we don't have events going between objects yet. Maybe move this down? Check
the TLM examples!

Note: ports require 1:1 caller-callee relationships

@todo better example

Example output:

SC_MODULE(B)
{
   ...
};

SC_MODULE(A)
{
    sc_port<B> b_port; // we call a function in B
    SC_CTOR(A)
    {
        SC_THREAD(f);
        sensitive << b_port; // wakeups from B
    }
};

----------------------------------------------------------------------------
Add local context

Add an SC_THREAD for each object. Each incoming functrino p() should store its
parameters and generate an event that wakes the SC_THREAD (which is
running an upper executive function). The upper executive should invoke an
implementation function eg p_impl(); An enum should be created to differentiate
between multiple functrinos.

The idea is to introduce a context (in the form of a SC_THREAD) for each object
and ensure that it is used to execute all existing functrinos within that
object.
We have to use events to signal the threads, but we keep the external interface
of the servers the same. This step does the same thing to all functrinos
regardless.

Invariant: A given object's code is executed within a context that belongs to
it.

Note: at this stage, all events are internal to objects, and do not go between
servers.

Note: Possible major problem here supporting inter-object recursion between this
step and the "make transactions non-blocking" step. Since each object's local
context "camps" in the other object's function while awaiting completion of the
call it is not straightforward for it to resume checking for incoming calls
while waiting. Solution is to employ a pool of contexts for each object and use
a "wake one waiter" event mechanism to ensure we select one waiting context for
each incoming call. Hopefully SystemC supports this @todo check!

Note: maybe use a clean internal format for remembering what's a SC_THREAD etc
and what its sensitivities are, and only generate the SC_CTOR when rendering for
test.

@todo maybe extract a step that splits p() into a trivial p() and a p_impl() and
add the executive in a separate step above this one, lashed up so that p()
invokes the executive directly. That might simplify the changes that are loaded
onto adding contexts (which seem rather heavy atm).

Example output:

SC_MODULE(A)
{
    enum { P, Q } which;
    sc_event X_wake, p_wake, q_wake;

    void X_executive() // upper executive
    {
        while(1)
        {
            wait( X_wake );
            switch( which )
            {
                case P:
                    p_impl();
                    @todo event p_wake             
                    break;
                    
                case Q:
                    q_impl();
                    @todo event q_wake
                    break;
            }            
        }
    }

    SC_CTOR(A)
    {
        SC_THREAD(X_context)
        sensitive << X_wake;
    }
    
    server X
    {
    public:
        void p()
        { 
            which = P;
            @todo event X_wake;
            wait( p_wake );
        }

        void q()
        {
            which = Q;
            @todo event X_wake;
            wait( q_wake );
        }

    private:
        void p_impl()
        {
            ...code taken from original p()...
        }

        void q_impl()
        {
            ...code taken from original g()...
        }
    }
};


----------------------------------------------------------------------------
Make transactions non-blocking

Functrinos should return immediately after kicking the object context.

By allowing the functrinos to return immediately, we are allowing the
execution paths of caller and callee to proceed independently, at least to an
extent. This will be an important step when parallelism becomes important. It
may also be viewed as a natural consequence of having done both "fake 2-phase"
and "add local context" and then cleaning up the resulting code.

The wait_return() primitive must now be implemented properly, since the
call-functrino returns immediately and can no longer be used to discover when
the function call has completed. wait_return() should be implemented as a
recursion into the object's upper executive function. The signal_return()
function should set a flag that causes the upper executive to return (exactly
once). 

All data used in the now-recursive executive must be explicitly stacked with a 
new stack pointer. All new data must be raw integral member data. This is because 
local variables and the stacks that support them have already been lowered out 
in the data phase.

Invariant: all functrinos return immediately

Note: only change callee (upper executive)

Note: Now reduce to one context per object. Wait for outgoing calls to return by
recursing back into the context's upper executive code. This supports recursive
calls.

Note: at this stage, each functrino corresponds to a sub-transaction.

@todo example confusing because there are 2 distinct pairs of
wait_return()/signal_return() in the 2 modules.

@todo split out the wait_return()/signal_return() implementation via recursing
the upper executive into a separate step above this one. Yes, and the explicit stack creation.

Example output:

SC_MODULE(A)
{
    event q_done_event; 
    int q_retval;

    void p()
    {
        ...
        b.q_call();
        wait_return( q_done_event ); 
        y = q_retval;
        ...
    }

public:    
    void q_return( int retval ) // functrino
    {
        q_retval = retval;
        signal_return( q_done_event ); 
    }    
} a;

SC_MODULE(B)
{
    enum { Q } which;
    sc_event X_wake;
    bool got_return;
    
    void wait_return() { X_executive(); }
    void signal_return() { got_return=true; }

    void X_executive()
    {
        while(!got_return)
        {
            wait( X_wake );
            switch( which )
            {
                case Q:
                    q_impl();
                    a.q_return()      
                    break;
            }            
        }
        got_return=false;
    }

    SC_CTOR(B)
    {
        SC_THREAD(X_context)
        sensitive << X_wake;
    }
    
    void q_call()
    { 
        which = Q;
        @todo event X_wake;
    }

    void q_impl()
    {
       ...code taken from original q()...
    }
};


----------------------------------------------------------------------------
Add channels

Create a new "channel" (in the SystemC TLM sense) for each sub-transaction. The
channel should forward the functrino calls. The idea is that we turn functrinos
into channels and then expand their functionality towards wires while staying
with channels so that wires will be easy to derive when the time comes.

Invariant: we have a presence, in the form of a channel, between communicating 
pairs of objects.

Note: the channel implementation we create will not be stated out but instead
will be converted to wires (=signals) by the protocol step(s) so it is not a
server. It will mostly be boiler-plate code.

Note: changes caller and callee but trivially (outgoing functrinos go to
channel). 

Example test render (channel for functrino k(char c)):

// Note: this is all just for test rendering; it doesn't get fed into later
// stages.
class Channel_k : public sc_interface
{
    void do_functrino( char c )
    {
        dest.k( c );
    }    
};

Code in objects doesn't really change - just calls functrinos through the
channel instead of directly.

----------------------------------------------------------------------------
Passivate

Modify the channels. Provide each with passive (call-in) 2-phase interfaces for
both caller and callee. All functrinos go into the channel and the channel kicks
(wakes up) the callee using an event and it then collects the parameters. 

The passive call model is an essential step since the function call modal
produced in the sequential phase (state-out) will only be able to handle
function calls within objects. In this phase, therefore, we must eliminate calls
between objects completely. This phase removes calls that go into objects,
and calls coming out of objects will be broken down into primatives that
correspond to driving or polling inter-object wires.

Invariant: objects do not receive incoming functrinos

Note: after this step, a functrino is still used to initiate a sub-transaction,
but the recipient gets an event and does a "get data" type call on the channel
to get the data. We therefore rely on SystemC to convey events into objects.

Note: the call into the channel to get the params is not a functrino since 
it goes to a communications primitive (the channel) and not an object.

Note: only change functrino recipients

Example test render (channel for functrino k(char c)):

// Note: this is all just for test rendering; it doesn't get fed into later
// stages.
class Channel_k : public sc_interface
{
    char param_c;
    
    void do_functrino( char c )
    {
        param_c = c;
        @todo event the connected destination port
    }
    
    void get_data( char &c )
    {
        return c;
    }
};

do_functrino() replaces f_data() (for call-functrinos) or f_return() (for
return-functrinos). 

----------------------------------------------------------------------------
Make sub-transactions 0-queue

For each channel, add an "ack" channel which goes the in the other direction
and has no data (same passive model). The recipient should ack immediately after
receiving the event and the originator should wait for the ack.

The ack serves two purposes: (1) marshaling of interactions to ensure that
events are not sent too rapidly for the recipient to handle them and (2) to
ensure that there is a well defined period of time for the recipient to read the
accompanying data.

This model is a rendez-vous model. The rendez-vous takes place for a finite
period of time beginning at receipt of the request and ending when the ack is
sent. A single request-ack cycle is a sub-transaction and the accompanying data
is valid for the recipient during this period.

It is expected that the request-ack period should be much shorter than the
call-return delay in a real system.

Invariant: now all transactions rendez-vous meaning the data doesn't have to 
be stored externally between origination and receipt.

Note: Now there are 4 events: call, call ack, return, return ack. Call ack 
and return events could be merged but we will regard that as an optional future
optimisation.

Note: transactions now 4-phase; sub-transactions now 2-phase

@todo not sure about the naming of this step

@todo maybe we can arrange for the "ack" to clear the stored data, or mark it as
unavailable for testing, to ensure we only consult the data when it is actually
available. Also ensure another request is not sent before the ack from the
previous one.

Example test render (channel for functrino k(char c)):

// Note: this is all just for test rendering; it doesn't get fed into later
// stages.
class Request_k : public sc_interface
{
    char param_c;
    
    void do_request( char c )
    {
        param_c = c;
        @todo event the connected destination port
    }
    
    void get_data( char &c )
    {
        return c;
    }
};

channel Ack_k : public sc_interface
{
    void do_ack()
    {
        event the source port
    }
};

Sender code goes:
    ...
    request_k.do_request('a');
    wait( ack_k );
    ...
    
Recipient event handler code goes:
    case K:
        c = request_k.get_data();
        ack_k.do_ack(); // Ack immediately
        ...do whatever is implied by functrino k...

----------------------------------------------------------------------------
Split out data and event channels

The outgoing request channels should be split into 2 channels: an event-only
channel to signal the event and data-only channels for the data. This step
simply makes the channel structure look more similar to what will be achieved
using wires. In particular we go from having request channels and ack channels
to having event channels and data channels.

Invariant: can now treat the two kinds of channels separately

Note: the ack channel is already an event-only channel

Note: if >1 param, create multiple separate data channels one for each param.

Example test render (channel for functrino k(char c)):

// Note: this is all just for test rendering; it doesn't get fed into later
// stages.
class Data_k : public sc_interface
{
    char param_c;
    
    void set_data( char c )
    {
        param_c = c;
    }
    
    void get_data( char &c )
    {
        return c;
    }
};

class Request_k : public sc_interface
{    
    void do_request()
    {     
        @todo event the connected destination port
    }
};

Sender code goes:
    ...
    data_k.SetData('a');
    request_k.do_request();
    wait( ack_k );
    ...
    
Recipient event handler code goes:
    case K:
        c = data_k.get_data();
        ack_k.do_ack(); // Ack immediately
        ...do whatever is implied by functrino k...

----------------------------------------------------------------------------
Introduce minor delay

Introduce a primitive called delay() which generates an event to the current
thread then waits for it. This is called a minor delay.

At present, we do not actually use these anywhere; the significance of this step
is that we have added our first sequential/timing construct apart from the
natural execution sequence of software. We have to do this in the structural
phase because the wire-based protocol cannot be correctly described without it.

Invariant: can now express minor delays

Note: when we add protocols, we need to be able to avoid combinational loops
so we use this primitive to break them. 

Example test render for delay():

delay()
{
    @todo event current thread
    wait( delay_event );
}

----------------------------------------------------------------------------
Move to signals

The event-only channels become sc_signal<bool> backed by a member variable. 
An event is generated by toggling the value: 1 goes to 0; 0 goes to 1. Reset 
value is 0. The data-only channels become sc_signal<x> where x is the data 
type used. Multiple data items (eg multiple parameters) should result in 
multiple signals (no need to put them in a struct or anything). Add a single 
delay() to the originator algorithm just after the transaction. 

Invariant: All communication is via sc_signal

Note: No need for backing members on data channels because the algorithm will
block during the transaction so the supplied data can't change. 

Note: since we are now dealing with wires (which is what signals really are),
we need to avoid combinational loops (which are viewed as part of the behaviour
of wires). We do this by adding a delay() in such a way that no two transactions
can occur simultaneously (though the ack can be simultaneous)

@todo shouldn't the delay go after request but before ack, since that is when
the data is being held ready? In a single cycle "req#1 and ack#1", is the data
valid? the req says yes, the ack says no! But if it was eg a "ack#1 and req#2"
we would know the data from sub-transaction #1 had gone and the data line
certainly holds data for #2 now.

Examples:

Data_k, Request_k and Ack_k replaced by

sc_signal<char> data_k;
sc_signal<bool> request_k, ack_k;

Sender code goes:
    ...
    data_k = 'a';
    request_k = !request_k;
    wait( ack_k );
    ...
    
Recipient event handler code goes:
    case K:
        c = data_k;
        ack_k = !ack_k; // Ack immediately. @todo How about ack_k=request_k?
        delay(); // next request must happen after a minor delay to avoid a loop
        ...do whatever is implied by functrino k...

