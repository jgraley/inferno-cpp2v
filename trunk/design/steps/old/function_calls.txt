
Funciton calls
==============

Mapping to event based
----------------------

Begin with a function such as follows:

int f( int a )
{
    a = a*a;
    return a;
}

The base-level combinational mapping (combing out) correlates a C function that produces it's result automatically with a combinational process. In a sense, the funciton's execution time is likened with the combinational logic's settling time. Even though the former consumes multiple cycles on the underlying computer, it maps to a sub-one-cycle operation in HDL.

More complex C functions will require time to execute. Suppose, for example, the multiply in f() takes time to execute. We wish to express concurrancy by permitting the caller to resume after initiating f() in a manner more natural for hardware implementations in which caller and called function are seperate physical entities. We express this as follows:

- We insist that all functions (post-mapping) return immediately and are therefore combinational.
- A "long" function f() becomes a class, F, which contains the algorithm in some form and working data as class member data (private).
- The events that initiate and signal completion of the algorithm will be cmbinational function calls between classes.
- We therefore require a callback interface to indicate completion. 

We wish to use events (active) rather than data (passive) to communicate start and completion because at this level we are still hiding the implicit polling (check once per clock) that happens when real hardware waits for an event. We would also like to be able to support asynchronous technology in which no global clock to drive polling will be available.

Unfortunately, C++ does not include as standard the type of 

f() therefore becomes

class F : private <concurrent object base class>
{
public:
    typedef void (ReturnObserver::*OnReturn)( int return_value );
    void Call( int a, ReturnObserver *obj, OnReturn done ); // Returns right away; simple enough for combinational logic
    class Observer
    {
    };

private:    
    <concurrent implementation eg state machine, pipeline, long-settling-time combinational etc>
    <working variables as class members>        
};

An invoking object would derive from ReturnObserver (defined once per program as an empty class). It would supply a member function of the form "void <done_name>( int return_value )". To invoke F on object my_f, it would use:

    my_f->Call( a, this, <done_name> )

The algorithm would replace "return a" with: 

    obj->done( a );

This will invoke the callback function with the return value in a. Note that the use of function pointers here is technically incorrect since we are not allowed to cast funciton pointers to a different class type and then call through them. However in practice it generally works with single inheritance. Our main intention is to convert this C++ code directly into HDL though and at that stage we will make sure it works for us!

The class F will be termed a "server" and the class(es) that invoke F will be "client(s)", due to the apparent similarity to client/server architecture.

We *do* permit the Call() function to call the OnDone() function diretly and the caller should expect that this is possible. This permits a simple combinational function to be embedded in the above scheme without introducing unwanted delays. 


Mapping to synchronous logic
----------------------------

Classes will map into HDL modules on a 1:1 basis. The HDL modules for the client and server classes listed above will expose the input, return and handshake lines for the Call() and OnReturn() methods as input and output ports.

An event maps to a wire-based connection including handshake wires (as determined by protocol) and associated data wires. The data goes in tthe direction of the event and will be valid at the time of the event and possibly some time later [@todo maybe the protocol section should define this?].

It suffices here to be able to convert the function calls to Call() and OnReturn() into logic by integrating them into a clocked framework. The server and all client modules will be clocked by the same master clock [@todo can we put all synch vs asynch specifics into the protocol section?]. The following diagram shows the interconnections between a server and a single client:

           /------- clk -------\
           |                   |
	     v                   v
+-------------+             +------------+
|             |             |            |
|             | chs ------> |            |
|             | a ========> |            |
|   client    |             |   server   |
|             |             |    "F"     |
|             | <------ rhs |            |
|             | <====== ret |            |
|             |             |            |
+-------------+             +------------+

<direction>hs means handshake in one or other direction. The server posesses input ports for "call" handshake (cha) and funciton parameters (a), and output lines for "return" handshake (rhs) and return value (ret). The handshake lines take care of establishing the timing of events; the details of handshake interaction will be dealt with in the topic on protocols. 

Client posesses a set of lines that are identical except that the directions are reversed (inouts, if used, would remain inouts).

Client makes a call by: waiting for the protocol to permit a call (if required by protocol) then driving chs as required and driving the input data on a. Lines must then be kept stable up to a rising clock edge (the usual requirement for clocked logic).

When the server completes processing, it drives the rhs and ret lines and keeps them stable over a clock edge.

The server *is* allowed to return in the same clock period - then it is a "combinational server". In this case, the combinational block uses a as input and ret as output. The protocol dictates what happens to chs and rhs but it is worth noting that tying rhs to "true" is preferable to looping through because (a) easier to optimise the logic and (b) less chance of logic loops. Note also that the client may invoke more than one combinational server in one clock period *but* a given combinational server may only be invoked once per clock due to the requirement that signals be allowed to settle for clocking into flipflops (which must exist somewhere in synchronous logic).

The specific protocol to use for a particular function may be specified using a "pragma". See the section on pragmas for details.

Some types of call require additional information to be supplied by the client in order to select which server to use. Such signals appear in the client's interface but not the servers and are used to control autoaticlaly-generated routing logic. See the secion on "routing".


Parameters
----------

Each parameter falls into one of three classes:

1. By-value with no copy constructor

If the parameter is a fundamental type then a local variable object of the same type is explicitly initialised by passing the actual value through an equally sized call_data port. If the obejct is composed of other objects, then each sub-object is treated seperately: the current strategy is recursed if no copy constructor otherwise the copy-constructor strategy (below) is used.

2. Reference

References differ from by-value parameters in their aliasing behavior. We need to preserve this behaviour, which means turning regular references into by-pointer parameters. The pointer does not require a NULL representation. It may be possible to exploit a "no aliassing" attribute and possibly introduce a scheme where the object is passed by value and then passed back out at destruction time.

3. By-value with copy constructors

Parameters or parts of parameters that have copy constructors exist as local variable objects and are initialised at the start of the function. A copy constructor requires a const-reference parameter and we forward the corresponding pointer port from the copy constructor's call interface to our own call interface.


Return values
-------------

Return values are similar to parameters except the roles of caller and callee are reversed. This mean, in particular, that copy-construction for by-value return values takes place in the caller, not the called function. It suffices for us to drive the ports with pointers to the neccessary objects. 


Void functions
--------------

Note that void functions do not return a value and therefore may not require the return event. However, we leave the return event in anyway because the caller might need to know when the function has completed due to other side effects. To omit the return event would introduce concurrancy in an unexpected manner. When a server is designed for dispatch-and-detach type concurrancy, it can generate the return signal early, perhaps combinationally. A server that always completes combinationally can hard-wire its return_valid line to 1 and ignore the return_ready line: this should allow both lines to optimise out during synthesis.


Local static variables
----------------------

All static data must be stored centrally, and outside of any object hierarchy because we require a single instance of such data aven if the owning class or function is instantiate more than once.


Automatic variables
-------------------

Automatically allocated variables are placed within the function server corresponding to the function that declared them. This implies that it is possible for a function server to contain a server for a class object that may itself contain more functions. A member function C::m() cannor contain a local of type C sincce this would give rise to infinite recursion during assembly.


Recursion
---------

If supported, recursion requires that local variables (and state if stating out) be duplicated in arrays to whatever depth is required. The function should then additionally feature a stack pointer variable which is incremented and decremented as required. All the function's logic accesses local data through multiplexers.
