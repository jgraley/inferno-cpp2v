
Contents
========

function calls       - how to call a function
protocols            - details of supported protocols
variables            - how to implement persistent variables
combing-out          - generating combinational logic from functions
stating-out          - generating state machines from fucntions
piping-out           - generating pipelines from functions
hierarchy            - mapping the class hierarchy to modules incl inheritance
pointers             - pointer representation
routing              - routing function interfaces and adding arbiters
new_delete           - dynamic allocation of memory [@todo read the paper on this]
serialisation        - turning objects into byte streams and back again
templates            - haandling C/C++ templates
comments             - transferring/generating comments in the output HDL
range analysis       - itentifying variables' value-ranges via setting and usage 
parallelism          - how to explit the parallelism of hardware 
analogue             - generating analogue verilog

implementation       - overall design of the mapper
server_ports         - determining server ports from fucnction/class declaration only
himple               - HDL extensions to gimple representation

simulation/testing   - support for test harnesses, PLI etc
CPU interaction      - how the generated HW can interact with code on a CPU
runtime construction - how we can construct objects dynamically on FPGA/CPLD
matrix server model  - applying 2-port (analogue) network theory to sequential protocols
pragmas              - support for new and existing gcc pragmas/attributes

general              - other implementation issues/constraints
glossary
