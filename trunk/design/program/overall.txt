
(C) Copyright 2006 John Graley
Available under the terms of the BSD license. 

Overall program design 

Input parsing
-------------

The input language will be C++ and will include whichever language elements are
present in the 1997 ANSI spec and are supported by GCC4. 

The input program will be preprocessed using GCC4's pre-processor and then
parsed using GCC4's front end. No modifications are expected to be needed to
either of these.

Once GCC has parsed the program into Gimple, some selection of GCC's own
optimisation process will now be run. The extent of this is undecided as yet,
but reasons to do this could include improving size/efficiency as well as
certain types of lowering that we would have to do otherwise.

GCC's existing code for dumping Gimple in text form will be modified to
- be unambiguously parsable and
- avoid needless repetition of information

The resulting file format will be dubbed Standard Raw Gimple (.srg extension)
and will be parsed directly by the inferno tool.

@todo the SRG format should be documented.


Inferno's internal process
--------------------------

The SRG input will be parsed into an equivalent tree-like representation. The
program transformations will proceed in a number of steps which modify the
representation as required. 

These modifications may introduce program elements not found in Gimple,
including
- syntax or structure that would be illegal in C++
- explicit primitives that relate to SystemC language extensions
- explicit primatives for Verilog language elements
- other explicit primatives as required by inferno's intermediate representation

@todo representation extensions should be documented

The transformation steps implement the transformations given in the design/steps
directory. Each must map the program from one valid and testable form into
another valid and testable form whereby
- both programs behave identically modulo size and space and
- the resultant program satisfies some new invariant as well as preserving all
existing invariants

Speed of the tool is not a high priority, and therefore ease of coding is
considered more important. 

The transformation process may optionally be stopped early after any stage.


Output generation
-----------------

The inferno program will provide the option to generate output in SRG form or
source form. The source form generator will generate Verilog and C++ and render
the new explicit primatives in a manner suitable for testing (eg calls to
simulation functions).

The final transformation step and Verilog source output should generate
synthesisable Verilog-2001 that is compatible with a nominated version of Icarus
Verilog (version will be latest stable release at the time the code is
written). 
  

Testing
-------

Testing will be achieved by building a collection of C++ programs that may be
used as input, beginning with simple example programs and ending up with
something similar to a compiler verification suite. 

Each test program will be accompanied by a test input file which the program
will read and then generate some expected output to standard output (and should
not write anything to standard error except when a built-in consistency check
fails).

Each test program will be compiled and executed to determine its behaviour - the
standard output from this run becomes the expected output. For each step in the
transformation, the program is transformed up to that step, saved in source
form, compiled and executed. The standard output is compered with the expected
output.

Depending on which step we are stopping after, the method of compilation may be
GCC4, GCC4 with SystemC libraries and maybe other simulation extensions specific
to inferno, or a Verilog simulation.

Note: using separate input data files avoids the problem of the programs getting
optimised down to triviality before the stage of interest. Using the input file
to drive program logic is therefore recommended.


