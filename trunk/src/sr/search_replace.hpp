#ifndef SEARCH_REPLACE_HPP
#define SEARCH_REPLACE_HPP

#include "common/common.hpp"
#include "common/read_args.hpp"
#include "helpers/walk.hpp"
#include "helpers/transformation.hpp"
#include "coupling.hpp"
#include "agent.hpp"
#include "normal_agent.hpp"
#include "search_container_agent.hpp"
#include "green_grass_agent.hpp"
#include <set>

namespace SR 
{

class Conjecture;
class SpecialBase;
class StarBase;
class SlaveBase;
class SearchContainerBase;

class CompareReplace : virtual public InPlaceTransformation, 
                       public Filter 
{  
public:
    // Constructor and destructor. Search and replace patterns and couplings are
    // specified here, so that we have a fully confiugured functor.
    CompareReplace( TreePtr<Node> cp = TreePtr<Node>(),
                    TreePtr<Node> rp = TreePtr<Node>(),
                    bool im = true );
                    
    // Call this to set the patterns after construction. This should not be virtual since
    // the constructor calls it.
    void Configure( TreePtr<Node> cp,
                    TreePtr<Node> rp = TreePtr<Node>() );                
    virtual void ConfigureImpl();					
    
    // Stuff for soft nodes; support this base class in addition to whatever tree intermediate
    // is required. Call GetProgram() if program root needed; call DecidedCompare() to recurse
    // back into the general search algorithm.
    TreePtr<Node> GetContext() const { ASSERT(pcontext&&*pcontext); return *pcontext; }

    // Some self-testing
    static void Test();
        
    bool is_master;// TODO seems to be obsolete
    TreePtr<Node> compare_pattern;
    TreePtr<Node> replace_pattern;
    CompareReplace *master_ptr;
    TreePtr<Node> *pcontext;
    mutable CouplingKeys coupling_keys;
    mutable Set< TreePtr<Node> > dirty_grass;
    
    // Sets of nodes for debugging purposes. Checks should be positive, because identifiers are copied
    // shallowly and will appear in more than one set. Since they are const, preservation rules do not
    // apply to identifiers. Only use these when ReadArgs::assert_pedigree is true.
    Set< TreePtr<Node> > pattern_pedigree;            // Nodes from the replace pattern 
    mutable Set< TreePtr<Node> > duplicated_pedigree; // Nodes generated by duplication in replace 
    mutable Set< TreePtr<Node> > keyed_pedigree;      // Nodes found in coupling keys, essentially the input
    
    virtual void GetGraphInfo( vector<string> *labels, 
                               vector< TreePtr<Node> > *links ) const;

    static void SetMaxReps( int n, bool e ) { repetitions=n; rep_error=e; }
    const CompareReplace * GetOverallMaster() const
    {
        const CompareReplace *m = this;
        while( m->master_ptr )
            m = m->master_ptr;
        return m;
    }

private:
    bool is_configured; 
    static int repetitions;
    static bool rep_error;
private:
    // MatchingDecidedCompare ring
    friend class Conjecture;
    void FlushSoftPatternCaches( TreePtr<Node> pattern ) const;
public:
    // Compare ring (now trivial)
    bool Compare( const TreePtrInterface &x,
                  TreePtr<Node> pattern,
                  bool can_key = false ) const;
    virtual bool IsMatch( TreePtr<Node> context,       
                          TreePtr<Node> root );
public:
    TreePtr<Node> BuildReplace( TreePtr<Node> pattern ) const;
    TreePtr<Node> DuplicateSubtree( TreePtr<Node> source,
                                    TreePtr<Node> source_terminus = TreePtr<Node>(),
                                    TreePtr<Node> dest_terminus = TreePtr<Node>() ) const;
private:
    TreePtr<Node> DuplicateNode( TreePtr<Node> pattern,
    		                     bool force_dirty ) const;
    void KeyReplaceNodes( TreePtr<Node> pattern ) const;
    TreePtr<Node> ReplacePhase( TreePtr<Node> x ) const;
    // implementation ring: Do the actual search and replace
    bool SingleCompareReplace( TreePtr<Node> *proot );
    int RepeatingCompareReplace( TreePtr<Node> *proot );
public:
    // Functor style interface for RepeatingSearchReplace; implements Pass interface.
    using Transformation::operator();
    void operator()( TreePtr<Node> context, 
                     TreePtr<Node> *proot );

	friend class NormalAgent;
};


class SearchReplace : public CompareReplace
{
public:
    SearchReplace( TreePtr<Node> sp = TreePtr<Node>(),
                   TreePtr<Node> rp = TreePtr<Node>(),
                   bool im = true );
                   
    virtual void ConfigureImpl();                 
                    
    virtual void GetGraphInfo( vector<string> *labels, 
                               vector< TreePtr<Node> > *links ) const;
};


/// Coupling slave can read the master's CouplingKeys structure
struct CouplingSlave 
{
    virtual void SetCouplingsMaster( CouplingKeys *ck ) = 0;    
};

struct SlaveBase : virtual CouplingSlave, virtual InPlaceTransformation, virtual NormalAgent
{
    virtual TreePtr<Node> GetThrough() const = 0;
	virtual void ConfigureImpl() = 0; // For master to trigger configuration
};

template<typename ALGO>
struct SlaveIntermediate : public SlaveBase, public ALGO                                 
{
	SlaveIntermediate( TreePtr<Node> sp, TreePtr<Node> rp ) :
		ALGO( sp, rp, false )
	{}
    virtual void SetCouplingsMaster( CouplingKeys *ck )
    {
        ALGO::coupling_keys.SetMaster( ck ); 
    }
    virtual void GetGraphInfo( vector<string> *labels, 
                               vector< TreePtr<Node> > *links ) const
    {
        labels->push_back("through");
        links->push_back(GetThrough());
        ALGO::GetGraphInfo( labels, links );
    }
    virtual void ConfigureImpl()
	{
	    ALGO::ConfigureImpl();
	}		
};

template<typename ALGO, class PRE_RESTRICTION>
struct Slave : SlaveIntermediate<ALGO>, Special<PRE_RESTRICTION>
{
	SPECIAL_NODE_FUNCTIONS

	// SlaveSearchReplace must be constructed using constructor
	Slave( TreePtr<PRE_RESTRICTION> t, TreePtr<Node> sp, TreePtr<Node> rp ) :
		through( t ),
		SlaveIntermediate<ALGO>( sp, rp )
	{
	}

	TreePtr<PRE_RESTRICTION> through;
	virtual TreePtr<Node> GetThrough() const
	{
		return TreePtr<Node>( through );
	}
};

// Partial specialisation is an arse in C++
template<class PRE_RESTRICTION>
struct SlaveCompareReplace : Slave<CompareReplace, PRE_RESTRICTION>, virtual Node
{
    SlaveCompareReplace() : Slave<CompareReplace, PRE_RESTRICTION>( NULL, NULL, NULL ) {}      
    SlaveCompareReplace( TreePtr<PRE_RESTRICTION> t, TreePtr<Node> sp=TreePtr<Node>(), TreePtr<Node> rp=TreePtr<Node>() ) :
        Slave<CompareReplace, PRE_RESTRICTION>( t, sp, rp ) {}
};

template<class PRE_RESTRICTION>
struct SlaveSearchReplace : Slave<SearchReplace, PRE_RESTRICTION>, virtual Node
{
    SlaveSearchReplace() : Slave<SearchReplace, PRE_RESTRICTION>( NULL, NULL, NULL ) {}      
    SlaveSearchReplace( TreePtr<PRE_RESTRICTION> t, TreePtr<Node> sp=TreePtr<Node>(), TreePtr<Node> rp=TreePtr<Node>() ) :
        Slave<SearchReplace, PRE_RESTRICTION>( t, sp, rp ) {}
};


// The * wildcard can match more than one node of any type in a container
// In a Sequence, only a contiguous subsequence of 0 or more elements will match
// In a Collection, a sub-collection of 0 or more elements may be matched anywhere in the collection
// Only one Star is allowed in a Collection. Star must be templated on a type that is allowed
// in the collection. TODO a restrict pattern
struct StarBase : virtual Node, virtual NormalAgent 
{
    virtual TreePtr<Node> GetPattern() = 0;
    bool MatchRange( const CompareReplace *sr,
                       ContainerInterface &range,
                       bool can_key );
};


template<class PRE_RESTRICTION>
struct Star : StarBase, Special<PRE_RESTRICTION> 
{ 
    SPECIAL_NODE_FUNCTIONS 
    TreePtr<PRE_RESTRICTION> pattern; // TODO rename to "restriction"
    virtual TreePtr<Node> GetPattern() 
    {
        return pattern;
    }
};


struct OverlayBase : virtual Node, virtual NormalAgent
{
    virtual TreePtr<Node> GetThrough() const = 0;
    virtual TreePtr<Node> GetOverlay() const = 0;    
};


template<class PRE_RESTRICTION>
struct Overlay : OverlayBase, Special<PRE_RESTRICTION>
{
    SPECIAL_NODE_FUNCTIONS
    TreePtr<PRE_RESTRICTION> through;
    TreePtr<PRE_RESTRICTION> overlay;
    virtual TreePtr<Node> GetThrough() const 
    {
        return (TreePtr<Node>)through;
    }
    virtual TreePtr<Node> GetOverlay() const
    {
        return (TreePtr<Node>)overlay;
    }
};


struct InsertBase : virtual Node, virtual NormalAgent
{
    virtual SequenceInterface *GetInsert() = 0;    
};


template<class PRE_RESTRICTION>
struct Insert : InsertBase, Special<PRE_RESTRICTION>
{
    SPECIAL_NODE_FUNCTIONS
    Sequence<PRE_RESTRICTION> insert;
    virtual SequenceInterface *GetInsert()  
    {
        return &insert;
    }
};


struct EraseBase : virtual Node, virtual NormalAgent
{
    virtual SequenceInterface *GetErase() = 0;    
};


template<class PRE_RESTRICTION>
struct Erase : EraseBase, Special<PRE_RESTRICTION>
{
    SPECIAL_NODE_FUNCTIONS
    Sequence<PRE_RESTRICTION> erase;
    virtual SequenceInterface *GetErase()  
    {
        return &erase;
    }
};


// Tell soft nodes that a compare run is beginning and it can flush any caches it may have
struct Flushable
{
	virtual void FlushCache() {}
};


class SofSearchPatternCallbacks : Flushable
{
public:
    SofSearchPatternCallbacks() :
        current_sr( NULL ),
        current_can_key( false ),
        current_conj( NULL )
    {}
protected: // Call only from the soft node implementation in MyCompare()
    // Compare for child nodes in a normal context (i.e. in which the pattern must match
	// for an overall match to be possible, and so can be used to key a coupling)
	inline bool NormalCompare( const TreePtrInterface &x, const TreePtrInterface &pattern )
	{
		ASSERT( current_sr )("Cannot call NormalCompare() from other than MyCompare()");
		ASSERT( current_conj )("Cannot call NormalCompare() from other than MyCompare()");
		return Agent::AsAgent(pattern)->DecidedCompare( x, current_can_key, *current_conj );
	}
    // Compare for child nodes in an abnormal context (i.e. in which the pattern need not match
	// for an overall match to be possible, and so cannot be used to key a coupling)
	inline bool AbnormalCompare( const TreePtrInterface &x, const TreePtrInterface &pattern )
	{
		ASSERT( current_sr )("Cannot call AbnormalCompare() from other than MyNormalCompare()");
		return Agent::AsAgent(pattern)->Compare( x, false ); 
	}
    inline TreePtr<Node> *GetContext()
    {
        ASSERT( current_sr )("Cannot call GetContext() from other than MyCompare()");
        return current_sr->pcontext;
    }
    inline bool IsCanKey()
    {
        ASSERT( current_sr )("Cannot call IsCanKey() from other than MyCompare()");
        return current_can_key;
    }
    inline TreePtr<Node> GetCoupled( TreePtr<Node> pattern )
    {
        ASSERT( current_sr )("Cannot call GetCoupled() from other than MyCompare()");
        return current_sr->coupling_keys.GetCoupled( Agent::AsAgent(pattern) );
    }
protected:
    const CompareReplace *current_sr;
	bool current_can_key;
	Conjecture *current_conj; 
};


class SoftSearchPattern : public SofSearchPatternCallbacks,
                          public virtual NormalAgent
{
public:    
    virtual bool DecidedCompare( const CompareReplace *sr,
                                    const TreePtrInterface &x,
                                    bool can_key,
                                    Conjecture &conj )                                  
    {
        ASSERT( !current_sr )("DecidedCompare() recursion detected in soft node");
        ASSERT( !current_conj )("DecidedCompare() recursion detected in soft node");
        current_sr = sr;
        current_can_key = can_key;
        current_conj = &conj;   
        bool result = MyCompare( x );
        current_sr = NULL;
        current_conj = NULL;
        return result;
    }
    // Soft nodes should override this to implement their comparison function
    virtual bool MyCompare( const TreePtrInterface &x ) = 0;
};


class SoftSearchPatternSpecialKey : public SofSearchPatternCallbacks,
                                    public virtual NormalAgent
{
public:    
	// Return NULL for not found
	virtual shared_ptr<Key> DecidedCompare( const CompareReplace *sr,
											const TreePtrInterface &x,
											bool can_key,
											Conjecture &conj )
    {
        ASSERT( !current_sr )("DecidedCompare() recursion detected in soft node");
        ASSERT( !current_conj )("DecidedCompare() recursion detected in soft node");
        current_sr = sr;
        current_can_key = can_key;
        current_conj = &conj;   
        shared_ptr<Key> result = MyCompare( x );
        current_sr = NULL;
        current_conj = NULL;
        return result;
    }
    // Soft nodes should override this to implement their comparison function
    virtual shared_ptr<Key> MyCompare( const TreePtrInterface &x ) = 0;
};


class SoftReplacePattern : Flushable,
                           public virtual NormalAgent
{    
public:
    SoftReplacePattern() :
        current_sr( NULL )
    {}

    // Called when not coupled
	virtual TreePtr<Node> DuplicateSubtree( const CompareReplace *sr )
    {
        ASSERT( !current_sr )("DuplicateSubtree() recursion detected in soft node");
        current_sr = sr;
        TreePtr<Node> st = MyBuildReplace();
        current_sr = NULL;
        return st;
    }
	// Called when coupled, dest is coupling key
	virtual TreePtr<Node> GetOverlayPattern() 
	{ 
		return TreePtr<Node>(); // default implementation for weak modifiers 
								// so that couplings appear to override local functionality
	}	
    virtual TreePtr<Node> MyBuildReplace() = 0;
    
protected:    
    inline TreePtr<Node> DoBuildReplace( TreePtr<Node> pattern ) 
    {
        ASSERT( current_sr )("Cannot call DoBuildReplace() from other than MyBuildReplace()");     
        return Agent::AsAgent(pattern)->BuildReplace( pattern );
    }
private:    
    const CompareReplace *current_sr;       
};

};

#endif

